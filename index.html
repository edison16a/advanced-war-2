<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="icon" type="image/png" href="assets/blue_rocket.png" />
  <title>Advanced Wars</title>
  <style>
    :root{
      --bg:#0b1020;
      --panel:#111a33;
      --panel2:#0f1730;
      --text:#e8eeff;
      --muted:#a9b6e6;
      --accent:#5dd6ff;
      --good:#74ff8a;
      --warn:#ffd166;
      --bad:#ff5d7a;
      --grid:#1c2b57;
    }
    html,body{height:100%;margin:0;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
    #wrap{display:flex;align-items:stretch;justify-content:center;gap:8px;padding:12px;box-sizing:border-box;height:100%}
    #gameCol{display:flex;flex-direction:column;gap:10px;align-items:flex-start}
    canvas{background:#050814;border:1px solid #23346b;border-radius:10px;image-rendering:pixelated}
    #panel{
      width:360px;
      max-width:38vw;
      height:calc(100vh - 24px); /* keep the full panel in view */
      background:linear-gradient(180deg,var(--panel),var(--panel2));
      border:1px solid #23346b;
      border-radius:14px;
      padding:12px;
      box-sizing:border-box;
      display:flex;
      flex-direction:column;
      gap:10px;
      overflow:auto;
      scrollbar-width:none; /* hide scrollbar in Firefox */
    }
    #panel::-webkit-scrollbar{display:none;} /* hide scrollbar in WebKit */
    .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    .btn{
      background:#152252;border:1px solid #2a3f86;color:var(--text);
      padding:8px 10px;border-radius:10px;cursor:pointer;font-weight:600
    }
    .btn:hover{border-color:#4a67d6}
    .btn:active{transform:translateY(1px)}
    .btn.primary{background:#1b2c69;border-color:#4a67d6}
    .btn.good{background:#134d2a;border-color:#2bd37e}
    .btn.bad{background:#5a1630;border-color:#ff5d7a}
    .btn:disabled{opacity:.45;cursor:not-allowed}
    .tag{padding:2px 8px;border:1px solid #2a3f86;border-radius:999px;font-size:12px;color:var(--muted)}
    .big{font-size:18px;font-weight:800}
    .muted{color:var(--muted)}
    #log{
      flex:1;
      min-height:240px; /* give the log room so it doesn't collapse */
      max-height:45vh;
      overflow:auto;
      background:#0a1026;
      border:1px solid #23346b;
      border-radius:12px;
      padding:10px;
      line-height:1.25;
      scrollbar-width:none;
    }
    #log::-webkit-scrollbar{display:none;}
    #log .line{margin:0 0 8px 0}
    #log .p1{color:#7cc6ff}
    #log .p2{color:#ff8aa7}
    #help{display:none}
    .kv{display:grid;grid-template-columns:1fr auto;gap:6px 10px;font-size:13px}
    .sep{height:1px;background:#203368;margin:6px 0}
    .list{display:flex;flex-direction:column;gap:6px}
    .shopItem{
      display:flex;align-items:center;justify-content:space-between;gap:12px;
      background:#0b1433;border:1px solid #23346b;border-radius:12px;padding:10px 12px
    }
    .shopItem .name{font-weight:700}
    .shopItem .meta{font-size:12px;color:var(--muted);line-height:1.35}
    .pill{
      padding:3px 8px;border-radius:999px;font-size:12px;font-weight:700;border:1px solid #2a3f86;color:var(--text)
    }
    .pill.good{border-color:#2bd37e;color:#a9ffd1}
    .pill.warn{border-color:#ffd166;color:#ffe7a8}
    .pill.bad{border-color:#ff5d7a;color:#ffc1cd}
    /* NEW: Key/Legend panel */
    #keyBox{
      display:none;
      background:#0a1026;
      border:1px solid #23346b;
      border-radius:12px;
      padding:10px;
    }
    .legendRow{
      display:flex;align-items:center;justify-content:space-between;gap:10px;
      padding:6px 8px;border:1px solid #23346b;border-radius:10px;background:#08102a
    }
    .swatch{
      width:18px;height:18px;border-radius:4px;border:1px solid #23346b;flex:0 0 auto;
    }
    .abbr{
      font-weight:800;letter-spacing:.5px;font-size:12px;
      padding:2px 6px;border-radius:8px;border:1px solid #23346b;background:#0b1433
    }
    /* Panels under keybinds */
    /* Match the board width so the right panel sits closer to the canvas */
    #lowerPanels{width:100%;max-width:768px;display:flex;flex-direction:column;gap:12px}
    .floatingPanel{
      display:none;
      background:#0a1026;
      border:1px solid #23346b;
      border-radius:14px;
      padding:12px;
      box-sizing:border-box;
    }
    #shopBox{display:block}
    .floatingPanel .headerRow{display:flex;justify-content:space-between;align-items:flex-end;gap:10px;flex-wrap:wrap}
    .shopStats{display:flex;gap:10px;flex-wrap:wrap;font-size:12px;color:var(--muted)}
    .shopStats .pill{font-size:12px}
    .shopGrid{display:flex;flex-direction:column;gap:8px}
    #selKv{display:none}
    #selStats{display:flex;flex-direction:column;gap:6px}
    .selRow{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
    .selRow.center{justify-content:center}
    .selImgRow{display:flex;justify-content:center}
    .thumb{
      width:80px;height:80px;border-radius:10px;
      border:1px solid #23346b;background:#0b1433;
      display:flex;align-items:center;justify-content:center;
      box-sizing:border-box;
    }
    #battleOverlay{
      position:fixed;inset:0;background:rgba(5,8,20,0.9);
      display:none;align-items:center;justify-content:center;
      z-index:9999;
    }
    #battleBox{
      width:80vw;max-width:960px;
      display:flex;justify-content:space-between;align-items:center;
      gap:20px;padding:20px;
      background:#0a1026;border:1px solid #23346b;border-radius:16px;
      box-shadow:0 20px 50px rgba(0,0,0,0.45);
    }
    .battleSide{
      flex:1;display:flex;flex-direction:column;align-items:center;gap:10px;
    }
    .battleImg{
      width:150px;height:150px;
      background:#0b1433;border:1px solid #23346b;border-radius:16px;
      display:flex;align-items:center;justify-content:center;
      overflow:hidden;image-rendering:pixelated;
    }
    .battleImg img{width:100%;height:100%;object-fit:contain;image-rendering:pixelated;}
    .battleHP{
      width:180px;height:14px;background:#0b1433;border:1px solid #23346b;border-radius:8px;overflow:hidden;
    }
    .battleHPFill{
      height:100%;background:#74ff8a;transition:width 0.4s ease;
    }
    .battleLabel{font-weight:700}
    .battleDamage{font-weight:800;font-size:13px;color:#e8eeff;min-height:16px}
    .battleDamage.sub{font-weight:700;font-size:12px;color:#a9b6e6}
    .hitLeft{animation:hitLeft 0.35s ease;}
    .hitRight{animation:hitRight 0.35s ease;}
    @keyframes hitLeft{0%{transform:translateX(0);}50%{transform:translateX(18px);}100%{transform:translateX(0);}}
    @keyframes hitRight{0%{transform:translateX(0);}50%{transform:translateX(-18px);}100%{transform:translateX(0);}}

    /* Stats header */
    #statsGrid{display:grid;grid-template-columns:1fr 1fr;gap:10px}
    .playerCard{
      background:#0a1026;
      border:1px solid #23346b;
      border-radius:12px;
      padding:10px;
      display:flex;
      flex-direction:column;
      gap:8px;
      transition:border-color 0.2s ease, box-shadow 0.2s ease;
    }
    .playerCard.active{box-shadow:0 0 0 1px rgba(93,214,255,0.35);}
    .playerCardHeader{display:flex;align-items:center;gap:10px}
    .coAvatar.mini{width:48px;height:48px}
    .playerCardHeader{position:relative}
    .coTooltip{
      display:none;
      position:fixed;
      top:58px;left:50%;
      transform:translateX(-50%);
      z-index:20;
      background:#0b1433;
      border:1px solid #23346b;
      border-radius:10px;
      padding:8px 10px;
      width:260px;
      max-width:90vw;
      box-shadow:0 10px 25px rgba(0,0,0,0.4);
    }
    .coTooltip.show{display:block;}
    .playerText .playerName{font-weight:800;font-size:14px}
    .playerText .playerCO{font-size:12px;color:#a9b6e6}
    .playerStats{display:flex;gap:8px;flex-wrap:wrap}
    .pill.mini{font-size:12px;padding:4px 8px}
    .playerTopActions{display:flex;gap:6px;flex-wrap:wrap}
    .playerTopMeter{width:100%;max-width:220px}
    #panel>.sep:first-of-type{margin-top:4px;margin-bottom:6px}
    /* Characters & Income */
    #coSection{background:#0a1026;border:1px solid #23346b;border-radius:12px;padding:10px;display:flex;flex-direction:column;gap:8px}
    #coSection{display:none!important;}
    .coCards{display:flex;flex-direction:column;gap:10px}
    .coCard{background:#0b1433;border:1px solid #23346b;border-radius:10px;padding:10px;display:flex;flex-direction:column;gap:8px}
    .coRow{display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap}
    .coSelection{display:flex;gap:10px;align-items:flex-start;cursor:pointer}
    .coSelection:hover{border-color:#4a67d6}
    .coSelection{border:1px dashed #2a3f86;border-radius:10px;padding:8px}
    .coAvatar{
      width:56px;height:56px;border-radius:12px;
      background:linear-gradient(135deg,#1b2c69,#152252);
      border:1px solid #2a3f86;
      display:flex;align-items:center;justify-content:center;
      font-weight:800;color:#e8eeff;font-size:18px;flex-shrink:0;
      overflow:hidden;
    }
    .coAvatar img{width:100%;height:100%;object-fit:cover;display:block;}
    .coAvatar.editable{position:relative;cursor:pointer;}
    .coAvatar.editable::after{
      content:"✎";
      position:absolute;
      bottom:4px;right:4px;
      width:18px;height:18px;
      border-radius:6px;
      background:rgba(5,8,20,0.8);
      border:1px solid #4a67d6;
      color:#e8eeff;
      font-size:11px;
      display:flex;align-items:center;justify-content:center;
      opacity:0;transition:opacity 0.2s ease;
      pointer-events:none;
    }
    .coAvatar.editable:hover::after{opacity:1;}
    .coText{display:flex;flex-direction:column;gap:4px}
    .coName{font-weight:800;font-size:14px}
    .coBuff{font-size:12px;color:#a9b6e6;line-height:1.35}
    .coBuff.small{font-size:11px}
    .coPill{padding:4px 8px;border-radius:999px;font-size:12px;font-weight:700;border:1px solid #2a3f86}
    .coPill.p1{color:#a9d9ff;border-color:#4a67d6}
    .coPill.p2{color:#ffc1cd;border-color:#ff5d7a}
    .btn.tiny{padding:4px 8px;font-size:12px;border-radius:8px}
    .coHelp{font-size:12px;color:#a9b6e6;line-height:1.4}
    .abilityLine{display:flex;flex-wrap:wrap;gap:6px;align-items:flex-start;margin-top:2px}
    .abilityBadge{padding:3px 7px;border-radius:8px;border:1px solid #2a3f86;font-size:11px;font-weight:700;color:#e8eeff;background:#11204a}
    .abilityCopy{font-size:12px;color:#c9d4ff;line-height:1.35}
    .coMeter{position:relative;width:100%;height:10px;border-radius:999px;background:#0a1026;border:1px solid #23346b;overflow:hidden}
    .coMeterFill{position:absolute;inset:0;width:0%;background:linear-gradient(90deg,#4a67d6,#5dd6ff);border-radius:999px;transition:width 0.2s ease}
    .coMeterLabel{font-size:11px;color:#a9b6e6;margin-top:4px}
    .coActions{display:flex;gap:6px;flex-wrap:wrap}

    /* CO modal */
    #coModal{position:fixed;inset:0;background:rgba(5,8,20,0.8);display:none;align-items:center;justify-content:center;z-index:7000}
    #coModal .modalBox{width:90vw;max-width:720px;background:#0a1026;border:1px solid #23346b;border-radius:14px;padding:14px;box-shadow:0 20px 40px rgba(0,0,0,0.55);}
    .coList{display:flex;flex-direction:column;gap:10px;margin-top:10px;max-height:70vh;overflow:auto;padding-right:4px}
    .coList{scrollbar-width:none;}
    .coList::-webkit-scrollbar{display:none;}
    .coOption{display:grid;grid-template-columns:auto 1fr auto;gap:10px;align-items:center;background:#0b1433;border:1px solid #23346b;border-radius:10px;padding:10px}
    .coOption .coText{gap:2px}
    .coOption .coName{font-size:15px}
    .coOption .coBuff{font-size:12px}
    .coOption .coBuff.small{font-size:11px}

    /* Turn overlay */
    #turnOverlay{position:fixed;inset:0;display:none;align-items:center;justify-content:center;z-index:6500;pointer-events:none;background:radial-gradient(circle at 30% 30%,rgba(93,214,255,0.12),transparent 45%),radial-gradient(circle at 70% 70%,rgba(255,93,122,0.12),transparent 45%)}
    #turnOverlay .turnBox{min-width:320px;max-width:520px;background:#0b1433;border:1px solid #23346b;border-radius:16px;padding:16px;box-shadow:0 20px 40px rgba(0,0,0,0.45);transform:translateY(20px);opacity:0;transition:opacity 0.3s ease,transform 0.3s ease}
    #turnOverlay.show .turnBox{opacity:1;transform:translateY(0)}
    /* Map picker modal */
    #mapModal{
      position:fixed;inset:0;display:none;align-items:center;justify-content:center;
      background:rgba(5,8,20,0.8);z-index:9999;
    }
    #mapModal .modalBox{
      width:90vw;max-width:780px;
      background:#0a1026;border:1px solid #23346b;border-radius:16px;
      padding:16px;box-shadow:0 20px 40px rgba(0,0,0,0.5);
      display:flex;flex-direction:column;gap:12px;
      max-height:90vh;
      overflow:auto;
      scrollbar-width:none;
    }
    #mapModal .modalBox::-webkit-scrollbar{display:none;}
    .mapGrid{
      display:grid;
      grid-template-columns:repeat(auto-fit,minmax(220px,1fr));
      gap:10px;
    }
    .mapCard{
      background:#0b1433;border:1px solid #23346b;border-radius:12px;padding:10px;
      display:flex;flex-direction:column;gap:6px;
    }
    .mapCard .name{font-weight:800}
    .mapCard .meta{font-size:12px;color:var(--muted)}
    .mapCard button{align-self:flex-start}
    .customMapSection{
      background:#0b1433;
      border:1px solid #23346b;
      border-radius:12px;
      padding:10px;
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:8px;
      text-align:center;
    }
    .customPalette{display:flex;flex-wrap:wrap;gap:8px;justify-content:center}
    .tileSwatch{
      width:40px;height:40px;border-radius:10px;border:1px solid #23346b;
      display:flex;align-items:center;justify-content:center;
      cursor:pointer;
      background:#0a1026;
      background-size:cover;
      background-position:center;
      background-repeat:no-repeat;
    }
    .tileSwatch.active{box-shadow:0 0 0 2px var(--accent);}
    .customGrid{
      display:grid;
      grid-template-columns:repeat(16, 26px);
      grid-auto-rows:26px;
      gap:2px;
      background:#050814;
      padding:6px;
      border:1px solid #23346b;
      border-radius:10px;
      max-width:480px;
      overflow:auto;
      margin-left:auto;
      margin-right:auto;
    }
    .customCell{
      width:26px;height:26px;
      border-radius:6px;
      border:1px solid #23346b;
      cursor:pointer;
      box-sizing:border-box;
      display:flex;align-items:center;justify-content:center;
      font-size:12px;font-weight:700;color:var(--text);
      user-select:none;
    }
    .customActions{display:flex;flex-wrap:wrap;gap:8px;justify-content:center}
    .editableName{
      position:relative;
      cursor:pointer;
      display:inline-flex;
      align-items:center;
    }
    .editableName:hover{text-decoration:underline;}
    .editableName::after{
      content:"(edit)";
      font-size:11px;
      color:var(--muted);
      opacity:0;
      transition:opacity 0.15s ease;
      position:absolute;
      left:100%;
      top:50%;
      transform:translateY(-50%);
      margin-left:6px;
      pointer-events:none;
      white-space:nowrap;
    }
    .editableName:hover::after{opacity:1;}
    .turnMeta{display:flex;align-items:center;gap:8px;flex-wrap:wrap;margin-bottom:8px}
    .turnIncome{font-size:18px;font-weight:800}
    .turnCO{font-size:13px;color:#a9b6e6;line-height:1.35}
  </style>
</head>
<body>
  <div id="wrap">
    <div id="gameCol">
      <canvas id="c" width="768" height="576"></canvas>
      <div id="help">
        <div class="row">
          <span class="tag">Mouse</span><span>Select unit/building/tile, move, attack</span>
        </div>
        <div class="row">
          <span class="tag">Right Click</span><span>Cancel selection</span>
        </div>
        <div class="row">
          <span class="tag">E</span><span>End Turn</span>
          <span class="tag">B</span><span>Open Shop (on your Base)</span>
          <span class="tag">K</span><span>Open Key/Legend</span>
          <span class="tag">Esc</span><span>Close Shop / Close Key / Cancel</span>
        </div>
      </div>

      <div id="lowerPanels">
        <div id="shopBox" class="floatingPanel">
          <div class="headerRow">
            <div>
              <div class="big" style="font-size:16px">Base Shop</div>
              <div class="muted" id="shopHint">Build units on your base.</div>
            </div>
            <button class="btn" id="closeShopBtn">Close (Esc)</button>
          </div>
          <div class="sep"></div>
          <div class="shopGrid" id="shopList"></div>
        </div>

        <div id="keyBox" class="floatingPanel">
          <div class="headerRow">
            <div>
              <div class="big" style="font-size:16px">Key / Legend</div>
              <div class="muted">Terrain and unit abbreviations (press K to toggle)</div>
            </div>
            <button class="btn" id="closeKeyBtn">Close (Esc)</button>
          </div>
          <div class="sep"></div>

          <div class="big" style="font-size:14px">Terrain</div>
          <div class="list" id="terrainLegend"></div>

          <div class="sep"></div>

          <div class="big" style="font-size:14px">Units</div>
          <div class="list" id="unitLegend"></div>
        </div>
      </div>
    </div>

    <div id="panel">
      <div class="row" style="justify-content:center">
        <div style="display:flex;justify-content:center;width:100%;">
          <img src="assets/logo.png" alt="Game Logo" style="max-width:240px; height:auto; display:block;">
        </div>
      </div>



      <div id="statsGrid">
        <div class="playerCard" id="p1Card">
          <div class="playerCardHeader">
            <div class="coAvatar mini editable" id="p1TopAvatar" title="Change CO"></div>
            <div class="playerText">
              <div class="playerName editableName" id="p1NameLabel">Player 1</div>
              <div class="playerCO" id="p1TopCOName">Andy</div>
            </div>
            <div class="coTooltip" id="p1TopTooltip"></div>
          </div>
          <div class="playerStats">
            <span class="pill mini" id="p1Funds">Funds 0</span>
            <span class="pill mini" id="p1TopIncome">Income 0</span>
          </div>
          <div class="playerTopActions" id="p1TopActions">
            <button class="btn tiny primary" id="p1TopPower">Power</button>
            <button class="btn tiny primary" id="p1TopSuper">Super</button>
          </div>
          <div class="playerTopMeter coMeter playerTopMeter"><div class="coMeterFill" id="p1TopMeterFill"></div></div>
        </div>
        <div class="playerCard" id="p2Card">
          <div class="playerCardHeader">
            <div class="coAvatar mini editable" id="p2TopAvatar" title="Change CO"></div>
            <div class="playerText">
              <div class="playerName editableName" id="p2NameLabel">Player 2</div>
              <div class="playerCO" id="p2TopCOName">Andy</div>
            </div>
            <div class="coTooltip" id="p2TopTooltip"></div>
          </div>
          <div class="playerStats">
            <span class="pill mini" id="p2Funds">Funds 0</span>
            <span class="pill mini" id="p2TopIncome">Income 0</span>
          </div>
          <div class="playerTopActions" id="p2TopActions">
            <button class="btn tiny primary" id="p2TopPower">Power</button>
            <button class="btn tiny primary" id="p2TopSuper">Super</button>
          </div>
          <div class="playerTopMeter coMeter playerTopMeter"><div class="coMeterFill" id="p2TopMeterFill"></div></div>
        </div>
      </div>

      <div id="selectionBox">
        <div class="big" style="font-size:16px">Tile/Troop Info</div>
        <div class="muted" id="selHint">Click a unit, building, or tile.</div>
        <br>
        
        <div class="kv" id="selKv"></div>
        
        <div class="shopStats" id="selStats"></div>
      </div>

      <div class="sep"></div>

      <div class="row">
        <button class="btn primary" id="endTurnBtn">End Turn (E)</button>
        <button class="btn" id="newBtn">New Game</button>
        <button class="btn bad" id="resetBtn" title="Hard reset the match">Reset</button>
        <button class="btn" id="openShopBtn" title="Open your shop (cycles owned bases)">Open Shop (B)</button>
        <button class="btn" id="unselectBtn" title="Clear selection / close panels">ESC</button>
        <button class="btn" id="moveBtn" title="Hold to show move range (M)">Move (M)</button>
        <button class="btn" id="dmgBtn" title="Hold to show attack range (D)">Damage (D)</button>
        <button class="btn" id="rangeBtn" title="Hold to show move+attack when spent (S)">Range (S)</button>
        <button class="btn" id="keyBtn" title="Open unit/terrain legend">Key (K)</button>
      </div>

      <div class="sep"></div>

      <div id="coSection">
        <div class="big" style="font-size:16px">Powers</div>
        <div class="coHelp">Day-to-day buffs are always on. CO Power / Super are burst abilities (pretend the meter fills as you fight; trigger when full). Click a commander card to swap and preview their kit.</div>
        <div class="coCards">
          <div class="coCard" data-player="1">
            <div class="coRow">
              <div class="coPill p1">Player 1 (Blue)</div>
              <div style="flex:1;min-width:180px">
                <div class="coMeter"><div class="coMeterFill" id="p1MeterFill"></div></div>
                <div class="coMeterLabel" id="p1MeterLabel">Meter 0%</div>
              </div>
            </div>
            <div class="coSelection" data-player="1" id="p1COCard">
              <div class="coAvatar" id="p1COAvatar">P1</div>
              <div class="coText">
                <div class="coName" id="p1COName">Andy</div>
                <div class="coBuff" id="p1COSpecialty">No strengths or weaknesses.</div>
                <div class="coBuff small" id="p1COPower">CO Power: —</div>
                <div class="coBuff small" id="p1COSuper">Super CO Power: —</div>
              </div>
              <button class="btn tiny" data-player="1" id="p1ChooseCO">Choose</button>
            </div>
            <div class="coActions">
              <button class="btn tiny" id="p1PowerBtn">Power</button>
              <button class="btn tiny primary" id="p1SuperBtn">Super</button>
            </div>
          </div>

          <div class="coCard" data-player="2">
            <div class="coRow">
              <div class="coPill p2">Player 2 (Red)</div>
              <div style="flex:1;min-width:180px">
                <div class="coMeter"><div class="coMeterFill" id="p2MeterFill"></div></div>
                <div class="coMeterLabel" id="p2MeterLabel">Meter 0%</div>
              </div>
            </div>
            <div class="coSelection" data-player="2" id="p2COCard">
              <div class="coAvatar" id="p2COAvatar">P2</div>
              <div class="coText">
                <div class="coName" id="p2COName">Andy</div>
                <div class="coBuff" id="p2COSpecialty">No strengths or weaknesses.</div>
                <div class="coBuff small" id="p2COPower">CO Power: —</div>
                <div class="coBuff small" id="p2COSuper">Super CO Power: —</div>
              </div>
              <button class="btn tiny" data-player="2" id="p2ChooseCO">Choose</button>
            </div>
            <div class="coActions">
              <button class="btn tiny" id="p2PowerBtn">Power</button>
              <button class="btn tiny primary" id="p2SuperBtn">Super</button>
            </div>
          </div>
        </div>
      </div>

      <div class="sep"></div>

      <div class="big" style="font-size:16px">Battle Log</div>
      <div id="log"></div>
    </div>
  </div>

  <div id="battleOverlay">
    <div id="battleBox">
      <div class="battleSide" id="battleLeft">
        <div class="battleImg"><img id="battleLeftImg" alt=""></div>
        <div class="battleLabel" id="battleLeftLabel"></div>
        <div class="battleDamage" id="battleLeftDmg"></div>
        <div class="battleHP"><div class="battleHPFill" id="battleLeftHP"></div></div>
      </div>
      <div class="battleSide" id="battleRight">
        <div class="battleImg"><img id="battleRightImg" alt=""></div>
        <div class="battleLabel" id="battleRightLabel"></div>
        <div class="battleDamage sub" id="battleRightDmg"></div>
        <div class="battleHP"><div class="battleHPFill" id="battleRightHP"></div></div>
      </div>
    </div>
  </div>

  <div id="coModal">
    <div class="modalBox">
      <div class="headerRow">
        <div>
          <div class="big" style="font-size:16px">Choose CO</div>
          <div class="muted" id="coModalHint">Pick a commander to set their buffs.</div>
        </div>
        <br>
        <button class="btn" id="closeCoModal">Close (ESC)</button>
      </div>
      <div class="sep"></div>
      <div class="coList" id="coList"></div>
    </div>
  </div>

  <div id="mapModal">
    <div class="modalBox">
      <div class="headerRow" style="display:flex;flex-direction:column;align-items:center;gap:10px">
        <div class="big" style="font-size:18px;text-align:center;width:100%;">Choose a Map</div>
        <button class="btn" id="closeMapModal" style="width:100%;text-align:center;">Close</button>
      </div>
      <div class="mapGrid" id="mapList"></div>
      <div class="sep"></div>
      <div class="customMapSection">
        <div class="big" style="font-size:15px">Custom Map (16x12)</div>
        <div class="muted" style="font-size:12px">Click or drag to paint tiles.</div>
        <div class="customPalette" id="customPalette"></div>
        <div class="customGrid" id="customGrid"></div>
        <div class="customActions">
          <button class="btn" id="fillPlains">Fill Plains</button>
          <button class="btn" id="resetCustom">Reset</button>
          <button class="btn primary" id="applyCustomMap">Start Custom Map</button>
        </div>
      </div>
    </div>
  </div>

  <div id="turnOverlay">
    <div class="turnBox" id="turnOverlayBox">
      <div class="turnMeta">
        <span class="coPill p1" id="turnOverlayPlayer">Player</span>
        <span class="pill" id="turnOverlayDay">Day</span>
      </div>
      <div class="turnIncome" id="turnOverlayIncome">Income +0</div>
    </div>
  </div>

  <script>
  "use strict";

  /***********************************************************************
   * TurnGrid Tactics
   ***********************************************************************/

  /***********************************************************************
   * Constants & Utilities
   ***********************************************************************/
  const TILE = 48;
  const GRID_W = 16;
  const GRID_H = 12;

  const CANVAS_W = GRID_W * TILE;
  const CANVAS_H = GRID_H * TILE;

  const COLORS = {
    bg: "#050814",
    grid: "#1c2b57",

    // players
    p1: "#63baff",
    p2: "#ff6f90",
    p1Dark: "#1f4f8a",
    p2Dark: "#8a1f3f",

    // highlights
    move: "rgba(93, 214, 255, 0.22)",
    moveEdge: "rgba(93, 214, 255, 0.75)",
    atk: "rgba(255, 93, 122, 0.20)",
    atkEdge: "rgba(255, 93, 122, 0.75)",
    select: "rgba(116, 255, 138, 0.20)",
    selectEdge: "rgba(116, 255, 138, 0.75)",
    danger: "rgba(255, 209, 102, 0.20)",
    dangerEdge: "rgba(255, 209, 102, 0.75)"
  };

  const SPRITE_SOURCES = {
    INF: { 1:["assets/blue_inf.png","assets/blue_inf2.png"], 2:["assets/red_inf.png","assets/red_inf2.png"] },
    RECON:{ 1:["assets/blue_recon.png"], 2:["assets/red_recon.png"] },
    TANK:{ 1:["assets/blue_tank.png"], 2:["assets/red_tank.png"] },
    MDT: { 1:["assets/blue_mdtank.png"], 2:["assets/red_mdtank.png"] },
    ART: { 1:["assets/blue_art.png"], 2:["assets/red_art.png"] },
    RKT: { 1:["assets/blue_rocket.png"], 2:["assets/red_rocket.png"] }
  };
  const SPRITE_IMAGES = {};

  const BUILDING_SOURCES = {
    HQ:   { 1:"assets/blue_hq.png", 2:"assets/red_hq.png", 0:"assets/building.png" },
    BASE: { 1:"assets/blue_base.png", 2:"assets/red_base.png", 0:"assets/building.png" },
    CITY: { 1:"assets/blue_building.png", 2:"assets/red_building.png", 0:"assets/building.png" }
  };
  const BUILDING_IMAGES = {};

  const TERRAIN_SOURCES = {
    PLAINS: "assets/grass.png",
    FOREST: "assets/forest.png",
    MOUNTAIN: "assets/mountain.png",
    ROAD: "assets/road.png",
    WATER: "assets/water.png"
  };
  const TERRAIN_IMAGES = {};

  // NEW: deterministic hash helpers (avoid animated noise)
  function hash2(x, y, seed=1337){
    let n = (x * 374761393 + y * 668265263 + seed * 1442695040888963407n) % 2147483647;
    // Above used BigInt; normalize:
    n = Number((BigInt(x) * 374761393n + BigInt(y) * 668265263n + BigInt(seed) * 1013904223n) & 0x7fffffffn);
    return n;
  }
  function hashFloat01(x,y,seed=1337){
    const h = hash2(x,y,seed) % 100000;
    return h / 100000;
  }
  function hashInt(x,y,seed,mod){
    return Math.floor(hashFloat01(x,y,seed) * mod);
  }

  const TERRAIN = {
    PLAINS:  { id:"PLAINS",  name:"Grass",   moveCost:{foot:1,tread:1,tires:1}, def:0, color:"#143a2a" },
    FOREST:  { id:"FOREST",  name:"Forest",  moveCost:{foot:1,tread:2,tires:2}, def:1, color:"#0f2f21" },
    MOUNTAIN:{ id:"MOUNTAIN",name:"Mountain",moveCost:{foot:2,tread:99,tires:99},def:2, color:"#2a2b35" },
    ROAD:    { id:"ROAD",    name:"Road",    moveCost:{foot:1,tread:1,tires:1}, def:0, color:"#2a2f3a" },
    WATER:   { id:"WATER",   name:"Water",   moveCost:{foot:2,tread:99,tires:99},def:0, color:"#0a2542" }
  };

  const BUILDING = {
    CITY: { id:"CITY", name:"City", income:1000, def:1 },
    BASE: { id:"BASE", name:"Base", income:1000, def:1 },
    HQ:   { id:"HQ",   name:"HQ",   income:1000, def:3 }
  };

  // Unit definitions
  const UNIT_DEF = {
    INF: {
      id:"INF", name:"Infantry", abbr:"INF",
      cost: 1000,
      maxHP: 10,
      move: 3,
      movementType: "foot",
      rangeMin: 1, rangeMax: 1,
      canCapture: true,
      // Approximate Advance Wars-style values (scaled to 10hp system)
      baseAtk: { INF: 6, TANK: 1, MDT: 1, ART: 2, RKT: 2 },
      armor: 0
    },

    RECON: {
      id:"RECON", name:"Recon", abbr:"RCN",
      cost: 4000,
      maxHP: 10,
      move: 8,
      movementType: "tires",
      rangeMin: 1, rangeMax: 1,
      canCapture: false,
      baseAtk: { INF: 7, TANK: 1, MDT: 1, ART: 5, RKT: 6, RECON: 4 },
      armor: 0
    },

    // Tank #1 (existing)
    TANK: {
      id:"TANK", name:"Tank", abbr:"TNK",
      cost: 7000,
      maxHP: 10,
      move: 6,
      movementType: "tread",
      rangeMin: 1, rangeMax: 1,
      canCapture: false,
      baseAtk: { INF: 7, TANK: 5, MDT: 3, ART: 6, RKT: 6 },
      armor: 1
    },

    // NEW: Tank #2 (heavier)
    MDT: {
      id:"MDT", name:"Md Tank", abbr:"MDT",
      cost: 12000,
      maxHP: 10,
      move: 5,
      movementType: "tread",
      rangeMin: 1, rangeMax: 1,
      canCapture: false,
      baseAtk: { INF: 9, TANK: 8, MDT: 6, ART: 8, RKT: 8 },
      armor: 2
    },

    // Artillery (existing)
    ART: {
      id:"ART", name:"Artillery", abbr:"ART",
      cost: 6000,
      maxHP: 10,
      move: 5,
      movementType: "tread",
      rangeMin: 2, rangeMax: 3,
      canCapture: false,
      baseAtk: { INF: 8, TANK: 7, MDT: 5, ART: 7, RKT: 7 },
      armor: 0,
      indirect: true
    },

    // NEW: Rockets (longer-range indirect)
    RKT: {
      id:"RKT", name:"Rockets", abbr:"RKT",
      cost: 15000,
      maxHP: 10,
      move: 4,
      movementType: "tread",
      rangeMin: 3, rangeMax: 5,
      canCapture: false,
      baseAtk: { INF: 9, TANK: 8, MDT: 7, ART: 8, RKT: 7 },
      armor: 0,
      indirect: true
    }
  };

  // Explicit damage ranges (hp) per matchup at 10hp on 0-star terrain (includes luck).
  const DAMAGE_TABLE = {
    INF: {
      INF: [5,6],
      TANK: [0,1],
      MDT: [0,1],
      ART: [1,2],
      RKT: [2,3],
      RECON: [1,2]
    },
    RECON: {
      INF: [8,9], // tuned so grass cover still yields 7-8 per spec
      RECON: [3,4],
      TANK: [1,2],
      MDT: [0,1],
      ART: [4,5],
      RKT: [5,6]
    },
    TANK: {
      INF: [7,8],
      TANK: [5,6],
      MDT: [1,2],
      ART: [7,7],
      RKT: [8,8],
      RECON: [8,9]
    },
    MDT: {
      INF: [10,10],
      TANK: [8,9],
      MDT: [5,6],
      ART: [10,10],
      RKT: [10,10],
      RECON: [10,10]
    },
    ART: {
      INF: [9,10],
      TANK: [7,7],
      MDT: [4,5],
      ART: [7,8],
      RKT: [8,8],
      RECON: [8,8]
    },
    RKT: {
      INF: [9,10],
      TANK: [8,8],
      MDT: [5,6],
    ART: [8,9],
    RKT: [8,9],
    RECON: [8,9]
  }
  };

  const UNIT_BLURB = {
    INF: "Low-cost soldiers essential for capturing properties",
    MECH: "Heavy-duty foot soldiers equipped with anti-tank rockets to defend rugged terrain like mountains.",
    RECON: "Move fast to counter enemy infantry",
    ART: "Mobile, indirect cannons that pack a punch",
    TANK: "Versatile front-line tanks designed to lead the charge",
    MDT: "Heavily armored juggernauts capable of dealing lots of damage",
    RKT: "Long-range siege launchers that pack a crazy punch"
  };

  const PLAYERS = [
    { id:1, name:"Player 1", color:COLORS.p1, dark:COLORS.p1Dark },
    { id:2, name:"Player 2", color:COLORS.p2, dark:COLORS.p2Dark }
  ];

  const CO_DATA = {
    ANDY: {
      id:"ANDY",
      name:"Andy",
      img:"assets/andy.png",
      specialty:"Balanced: no passive buffs/penalties.",
      power:"Hyper Repair: Heals all owned units by 2 HP; Activating the ability refreshes spent units so they can act again this turn.",
      super:"Hyper Upgrade: Heals all owned units by 5 HP, all units gain +1 Move and +20% attack for the turn; Activating the ability refreshes spent units so they can act again this turn."
    },
    MAX: {
      id:"MAX",
      name:"Max",
      img:"assets/max.png",
      specialty:"Direct units +20% attack; indirect units -1 max range.",
      power:"Max Force: Direct units +1 Move and ~+40% attack this turn; Activating the ability refreshes spent units so they can act again this turn.",
      super:"Max Blast: Direct units +2 Move and ~+60% attack this turn; Activating the ability refreshes spent units so they can act again this turn."
    },
    SAMI: {
      id:"SAMI",
      name:"Sami",
      img:"assets/sami.png",
      specialty:"Infantry deal ~+20% damage; capture strength ~1.5× HP.",
      power:"Double Time: Infantry +1 Move, ~+50% damage, capture strength 2× HP; Activating the ability refreshes spent units so they can act again this turn.",
      super:"Victory March: Infantry +2 Move, ~+60% damage, captures complete in one turn; Activating the ability refreshes spent units so they can act again this turn."
    },
    NELL: {
      id:"NELL",
      name:"Nell",
      img:"assets/nell.png",
      specialty:"Adds 0–2 extra “luck” damage on every hit.",
      power:"Lucky Star: Luck range 0–4 extra damage; Activating the ability refreshes spent units so they can act again this turn.",
      super:"Lady Luck: Luck range 0–6 extra damage; Activating the ability refreshes spent units so they can act again this turn."
    },
    HACHI: {
      id:"HACHI",
      name:"Hachi",
      img:"assets/Hachi.png",
      specialty:"Units cost 10% less in shops.",
      power:"Barter: Units cost 50% less this turn; Activating the ability refreshes spent units so they can act again this turn.",
      super:"Merchant Union: Units cost 50% less this turn; Activating the ability refreshes spent units so they can act again this turn."
    }
  };

  function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }
  function inBounds(x,y){ return x>=0 && y>=0 && x<GRID_W && y<GRID_H; }
  function key(x,y){ return x + "," + y; }
  function parseKey(k){ const [x,y]=k.split(",").map(Number); return {x,y}; }
  function manhattan(a,b){ return Math.abs(a.x-b.x)+Math.abs(a.y-b.y); }
  function randInt(n){ return Math.floor(Math.random()*n); }
  function randBetween(min,max){ return min + randInt(max - min + 1); }

  /***********************************************************************
   * DOM handles
   ***********************************************************************/
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");

  canvas.width = CANVAS_W;
  canvas.height = CANVAS_H;

  const elCurPlayer = null;
  const elDay = null;
  const elP1Funds = document.getElementById("p1Funds");
  const elP2Funds = document.getElementById("p2Funds");
  const p1TopIncome = document.getElementById("p1TopIncome");
  const p2TopIncome = document.getElementById("p2TopIncome");
  const p1TopCOName = document.getElementById("p1TopCOName");
  const p2TopCOName = document.getElementById("p2TopCOName");
  const p1TopAvatar = document.getElementById("p1TopAvatar");
  const p2TopAvatar = document.getElementById("p2TopAvatar");
  const p1Card = document.getElementById("p1Card");
  const p2Card = document.getElementById("p2Card");
  const p1NameLabel = document.getElementById("p1NameLabel");
  const p2NameLabel = document.getElementById("p2NameLabel");
  const p1TopTooltip = document.getElementById("p1TopTooltip");
  const p2TopTooltip = document.getElementById("p2TopTooltip");
  const p1TopActions = document.getElementById("p1TopActions");
  const p2TopActions = document.getElementById("p2TopActions");
  const p1TopPower = document.getElementById("p1TopPower");
  const p2TopPower = document.getElementById("p2TopPower");
  const p1TopSuper = document.getElementById("p1TopSuper");
  const p2TopSuper = document.getElementById("p2TopSuper");
  const p1TopMeterFill = document.getElementById("p1TopMeterFill");
  const p2TopMeterFill = document.getElementById("p2TopMeterFill");
  const panelEl = document.getElementById("panel");
  function showTooltip(tt, anchor){
    if(!tt || !anchor || !panelEl) return;
    const panelRect = panelEl.getBoundingClientRect();
    const anchorRect = anchor.getBoundingClientRect();
    tt.style.position = "fixed";
    tt.style.top = `${anchorRect.bottom + 8}px`;
    let center = panelRect.left + panelRect.width/2;
    if(p1Card && p2Card){
      const r1 = p1Card.getBoundingClientRect();
      const r2 = p2Card.getBoundingClientRect();
      center = (r1.left + r2.right) / 2;
    }
    const width = tt.offsetWidth || 260;
    tt.style.left = `${center - width/2}px`;
    tt.classList.add("show");
  }
  function hideTooltip(tt){
    if(tt) tt.classList.remove("show");
  }

  const endTurnBtn = document.getElementById("endTurnBtn");
  const newBtn = document.getElementById("newBtn");
  const resetBtn = document.getElementById("resetBtn");
  const openShopBtn = document.getElementById("openShopBtn");
  const unselectBtn = document.getElementById("unselectBtn");
  const moveBtn = document.getElementById("moveBtn");
  const dmgBtn = document.getElementById("dmgBtn");
  const rangeBtn = document.getElementById("rangeBtn");

  const elSelHint = document.getElementById("selHint");
  const elSelKv = document.getElementById("selKv");
  const elSelStats = document.getElementById("selStats");

  const p1COName = document.getElementById("p1COName");
  const p2COName = document.getElementById("p2COName");
  const p1COSpecialty = document.getElementById("p1COSpecialty");
  const p2COSpecialty = document.getElementById("p2COSpecialty");
  const p1COPower = document.getElementById("p1COPower");
  const p2COPower = document.getElementById("p2COPower");
  const p1COSuper = document.getElementById("p1COSuper");
  const p2COSuper = document.getElementById("p2COSuper");
  const p1COAvatar = document.getElementById("p1COAvatar");
  const p2COAvatar = document.getElementById("p2COAvatar");
  const p1ChooseCO = document.getElementById("p1ChooseCO");
  const p2ChooseCO = document.getElementById("p2ChooseCO");
  const p1COCard = document.getElementById("p1COCard");
  const p2COCard = document.getElementById("p2COCard");
  const p1MeterFill = document.getElementById("p1MeterFill");
  const p2MeterFill = document.getElementById("p2MeterFill");
  const p1MeterLabel = document.getElementById("p1MeterLabel");
  const p2MeterLabel = document.getElementById("p2MeterLabel");
  const p1PowerBtn = document.getElementById("p1PowerBtn");
  const p2PowerBtn = document.getElementById("p2PowerBtn");
  const p1SuperBtn = document.getElementById("p1SuperBtn");
  const p2SuperBtn = document.getElementById("p2SuperBtn");

  const coModal = document.getElementById("coModal");
  const coModalHint = document.getElementById("coModalHint");
  const coList = document.getElementById("coList");
  const closeCoModal = document.getElementById("closeCoModal");

  const turnOverlay = document.getElementById("turnOverlay");
  const turnOverlayBox = document.getElementById("turnOverlayBox");
  const turnOverlayPlayer = document.getElementById("turnOverlayPlayer");
  const turnOverlayDay = document.getElementById("turnOverlayDay");
  const turnOverlayIncome = document.getElementById("turnOverlayIncome");
  const mapModal = document.getElementById("mapModal");
  const mapList = document.getElementById("mapList");
  const applyCustomMapBtn = document.getElementById("applyCustomMap");
  const closeMapModal = document.getElementById("closeMapModal");
  const customPalette = document.getElementById("customPalette");
  const customGridEl = document.getElementById("customGrid");
  const fillPlainsBtn = document.getElementById("fillPlains");
  const resetCustomBtn = document.getElementById("resetCustom");

  let coModalTarget = null;
  let turnOverlayTimer = null;
  let sKeyHeld = false, sBtnHeld = false;
  let dKeyHeld = false, dBtnHeld = false;
  let mKeyHeld = false, mBtnHeld = false;

  const shopBox = document.getElementById("shopBox");
  const shopList = document.getElementById("shopList");
  const closeShopBtn = document.getElementById("closeShopBtn");
  const shopHint = document.getElementById("shopHint");

  const keyBtn = document.getElementById("keyBtn");
  const keyBox = document.getElementById("keyBox");
  const closeKeyBtn = document.getElementById("closeKeyBtn");
  const terrainLegend = document.getElementById("terrainLegend");
  const unitLegend = document.getElementById("unitLegend");

  const logBox = document.getElementById("log");
  const helpBox = document.getElementById("help");
  const lowerPanels = document.getElementById("lowerPanels");
  const battleOverlay = document.getElementById("battleOverlay");
  const battleLeftImg = document.getElementById("battleLeftImg");
  const battleRightImg = document.getElementById("battleRightImg");
  const battleLeftHP = document.getElementById("battleLeftHP");
  const battleRightHP = document.getElementById("battleRightHP");
  const battleLeftLabel = document.getElementById("battleLeftLabel");
  const battleRightLabel = document.getElementById("battleRightLabel");
  const battleLeftDmg = document.getElementById("battleLeftDmg");
  const battleRightDmg = document.getElementById("battleRightDmg");

  /***********************************************************************
   * Game State
   ***********************************************************************/
  const Game = {
    day: 1,
    currentPlayer: 1,
    funds: { 1: 5000, 2: 5000 },

    terrain: [],
    buildings: [],

    units: [],

    sel: null,              // { type:"unit"/"building"/"tile", ... }
    phase: "IDLE",          // IDLE | MOVING | ATTACKING | SHOP
    moveMap: null,
    moveTiles: new Set(),
    path: [],
    atkTiles: new Set(),
    baseCycleIdx: { 1:0, 2:0 },

    hovered: { x:-1, y:-1 },
    gameOver: false,

    coChoice: { 1:"ANDY", 2:"ANDY" },
    coMeter: { 1:0, 2:0 },
    coState: { 1:null, 2:null },
    dmgDetail: false,
    selectedMap: "CLASSIC",
    customMapText: ""
  };

  /***********************************************************************
   * Entities
   ***********************************************************************/
  let UNIT_ID_SEQ = 1;

  function makeUnit(typeId, owner, x, y){
    const def = UNIT_DEF[typeId];
    const spriteList = getSpriteList(typeId, owner);
    const spriteIdx = typeId==="INF" && spriteList.length>1 ? randInt(spriteList.length) : 0;
    return {
      uid: UNIT_ID_SEQ++,
      typeId,
      def,
      owner,
      x, y,
      hp: def.maxHP,
      moved: false,
      acted: false,
      actionsLeft: 1,
      spriteIdx
    };
  }

  function unitAt(x,y){
    for(const u of Game.units){
      if(u.x===x && u.y===y) return u;
    }
    return null;
  }

  function buildingAt(x,y){
    if(!inBounds(x,y)) return null;
    return Game.buildings[y][x];
  }

  function terrainAt(x,y){
    if(!inBounds(x,y)) return TERRAIN.WATER;
    return Game.terrain[y][x];
  }

  function getSpriteList(typeId, ownerId){
    const byType = SPRITE_IMAGES[typeId];
    if(!byType) return [];
    return byType[ownerId] || [];
  }

  function getBuildingSprite(kindId, ownerId){
    const byKind = BUILDING_IMAGES[kindId];
    if(!byKind) return null;
    const key = (ownerId && byKind[ownerId]) ? ownerId : 0;
    return byKind[key] || null;
  }

  function getTerrainSprite(id){
    return TERRAIN_IMAGES[id] || null;
  }

  function makeBuildingNode(kindId, ownerId, size){
    const img = document.createElement("img");
    const sprite = getBuildingSprite(kindId, ownerId);
    if(sprite) img.src = sprite.src;
    img.width = size;
    img.height = size;
    img.className = "thumb";
    img.style.objectFit = "contain";
    img.style.background = "#0b1433";
    img.style.imageRendering = "pixelated";
    return img;
  }

  function makeTerrainNode(terrain, size){
    const img = document.createElement("img");
    const sprite = getTerrainSprite(terrain.id);
    if(sprite) img.src = sprite.src;
    img.width = size;
    img.height = size;
    img.className = "thumb";
    img.style.objectFit = "cover";
    img.style.imageRendering = "pixelated";
    return img;
  }

  function getUnitSpriteSrc(u){
    const list = getSpriteList(u.typeId, u.owner);
    if(!list.length) return "";
    const img = list[u.spriteIdx % list.length];
    return img ? img.src : "";
  }

  function getOwnedBases(playerId){
    const bases = [];
    for(let y=0;y<GRID_H;y++){
      for(let x=0;x<GRID_W;x++){
        const b = buildingAt(x,y);
        if(b && b.kindId==="BASE" && b.owner===playerId){
          bases.push({b,x,y});
        }
      }
    }
    bases.sort((a,b)=> (a.y - b.y) || (a.x - b.x));
    return bases;
  }

  function pickNextBase(playerId){
    const bases = getOwnedBases(playerId);
    if(!bases.length) return null;
    const idx = Game.baseCycleIdx[playerId] ?? 0;
    const choice = bases[idx % bases.length];
    Game.baseCycleIdx[playerId] = (idx + 1) % bases.length;
    return choice;
  }

  function autoOpenShopForCurrentPlayer(){
    if(Game.gameOver) return;
    const choice = pickNextBase(Game.currentPlayer);
    if(!choice) return;
    selectBuilding(choice.b, choice.x, choice.y);
    openShopIfOnOwnedBase();
  }

  function makeSpriteNode(typeId, ownerId, size){
    const img = new Image();
    const list = getSpriteList(typeId, ownerId);
    img.src = list[0]?.src || "";
    img.width = size;
    img.height = size;
    img.style.imageRendering = "pixelated";
    img.style.borderRadius = "8px";
    img.style.border = "1px solid #23346b";
    img.style.background = "#0b1433";
    return img;
  }

  function removeUnit(u){
    const idx = Game.units.findIndex(z => z.uid===u.uid);
    if(idx>=0) Game.units.splice(idx,1);
  }

  function owningPlayer(id){ return PLAYERS.find(p=>p.id===id) || PLAYERS[0]; }
  function setPlayerName(id, name){
    const clean = (name || "").trim() || `Player ${id}`;
    const p = PLAYERS.find(x=>x.id===id);
    if(p) p.name = clean;
    if(id===1 && p1NameLabel) p1NameLabel.textContent = clean;
    if(id===2 && p2NameLabel) p2NameLabel.textContent = clean;
  }

  /***********************************************************************
   * Tile defense (stars)
   ***********************************************************************/
  function defenseStarsForTerrainId(id){
    if(id==="ROAD" || id==="WATER") return 0; // road/bridge/water = 0
    if(id==="PLAINS") return 1;
    if(id==="FOREST") return 2;
    if(id==="MOUNTAIN") return 4;
    return 0;
  }

  function tileDefenseStat(x,y){
    const b = buildingAt(x,y);
    if(b){
      if(b.kindId==="HQ") return 4;
      if(b.kindId==="BASE" || b.kindId==="CITY") return 3;
      return 0;
    }
    const t = terrainAt(x,y);
    if(!t) return 0;
    return defenseStarsForTerrainId(t.id);
  }

  /***********************************************************************
   * Map Generation
   ***********************************************************************/
  function initEmptyLayers(){
    Game.terrain = Array.from({length:GRID_H}, ()=>Array.from({length:GRID_W}, ()=>TERRAIN.PLAINS));
    Game.buildings = Array.from({length:GRID_H}, ()=>Array.from({length:GRID_W}, ()=>null));
  }

  function placeBuilding(x,y, kindId, owner=null){
    Game.buildings[y][x] = {
      kindId,
      def: BUILDING[kindId],
      owner,
      capturePoints: 20
    };
  }

  function generateMapClassic(){
    initEmptyLayers();

    for(let y=0;y<GRID_H;y++){
      for(let x=0;x<GRID_W;x++){
        Game.terrain[y][x] = TERRAIN.PLAINS;
      }
    }

    const roadY = 5;
    for(let x=1;x<GRID_W-1;x++){
      Game.terrain[roadY][x] = TERRAIN.ROAD;
      Game.terrain[roadY+1][x] = TERRAIN.ROAD;
    }

    const forests = [
      {x:3,y:2},{x:4,y:2},{x:3,y:3},
      {x:11,y:2},{x:12,y:2},{x:12,y:3},
      {x:2,y:9},{x:3,y:9},{x:3,y:8},
      {x:12,y:9},{x:13,y:9},{x:12,y:8}
    ];
    for(const p of forests){
      if(inBounds(p.x,p.y)) Game.terrain[p.y][p.x] = TERRAIN.FOREST;
    }

    const mountains = [
      {x:7,y:2},{x:8,y:2},
      {x:7,y:9},{x:8,y:9},
      {x:7,y:5},{x:8,y:6}
    ];
    for(const p of mountains){
      if(inBounds(p.x,p.y)) Game.terrain[p.y][p.x] = TERRAIN.MOUNTAIN;
    }

    for(let x=0;x<3;x++){
      Game.terrain[0][x] = TERRAIN.WATER;
      Game.terrain[0][GRID_W-1-x] = TERRAIN.WATER;
      Game.terrain[GRID_H-1][x] = TERRAIN.WATER;
      Game.terrain[GRID_H-1][GRID_W-1-x] = TERRAIN.WATER;
    }

    placeBuilding(1,1,"HQ",1);
    placeBuilding(GRID_W-2, GRID_H-2, "HQ", 2);

    placeBuilding(2,1,"BASE",1);
    placeBuilding(1,2,"BASE",1);

    placeBuilding(GRID_W-3, GRID_H-2,"BASE",2);
    placeBuilding(GRID_W-2, GRID_H-3,"BASE",2);

    const cities = [
      {x:5,y:3},{x:10,y:3},
      {x:5,y:8},{x:10,y:8},
      {x:7,y:6},{x:8,y:5},
      {x:2,y:6},{x:13,y:6}
    ];
    for(const c of cities) placeBuilding(c.x,c.y,"CITY",null);
  }

  function generateMapRiverRun(){
    initEmptyLayers();
    for(let y=0;y<GRID_H;y++){
      for(let x=0;x<GRID_W;x++){
        Game.terrain[y][x] = (x===Math.floor(GRID_W/2)) ? TERRAIN.WATER : TERRAIN.PLAINS;
      }
    }
    for(let y=0;y<GRID_H;y++){
      Game.terrain[y][Math.floor(GRID_W/2)-1] = TERRAIN.ROAD;
      Game.terrain[y][Math.floor(GRID_W/2)+1] = TERRAIN.ROAD;
    }
    const forests = [
      {x:3,y:3},{x:4,y:4},{x:11,y:7},{x:12,y:6},{x:5,y:9},{x:10,y:2},
      {x:2,y:5},{x:13,y:5},{x:4,y:7},{x:11,y:4}
    ];
    for(const p of forests) if(inBounds(p.x,p.y)) Game.terrain[p.y][p.x] = TERRAIN.FOREST;
    const mountains = [{x:7,y:2},{x:8,y:2},{x:7,y:9},{x:8,y:9}];
    for(const p of mountains) if(inBounds(p.x,p.y)) Game.terrain[p.y][p.x] = TERRAIN.MOUNTAIN;
    placeBuilding(1,1,"HQ",1);
    placeBuilding(GRID_W-2, GRID_H-2, "HQ", 2);
    placeBuilding(2,1,"BASE",1);
    placeBuilding(1,2,"BASE",1);
    placeBuilding(GRID_W-3, GRID_H-2,"BASE",2);
    placeBuilding(GRID_W-2, GRID_H-3,"BASE",2);
    const cities = [
      {x:5,y:3},{x:10,y:8},
      {x:5,y:8},{x:10,y:3},
      {x:7,y:6},{x:8,y:5},
      {x:2,y:6},{x:13,y:6},
      {x:7,y:0},{x:8,y:11}
    ];
    for(const c of cities) placeBuilding(c.x,c.y,"CITY",null);
  }

  function generateMapMountainPass(){
    initEmptyLayers();
    for(let y=0;y<GRID_H;y++){
      for(let x=0;x<GRID_W;x++){
        Game.terrain[y][x] = TERRAIN.PLAINS;
      }
    }
    const passCols = [5,6,9,10];
    for(let y=2;y<GRID_H-2;y++){
      for(const x of passCols){
        Game.terrain[y][x] = TERRAIN.MOUNTAIN;
      }
    }
    for(let y=0;y<GRID_H;y++){
      Game.terrain[y][7] = TERRAIN.ROAD;
      Game.terrain[y][8] = TERRAIN.ROAD;
    }
    const forests = [
      {x:2,y:2},{x:3,y:3},{x:12,y:8},{x:11,y:9},{x:4,y:8},{x:11,y:2},
      {x:2,y:7},{x:13,y:4},{x:5,y:5},{x:10,y:6}
    ];
    for(const p of forests) if(inBounds(p.x,p.y)) Game.terrain[p.y][p.x] = TERRAIN.FOREST;
    placeBuilding(1,1,"HQ",1);
    placeBuilding(GRID_W-2, GRID_H-2, "HQ", 2);
    placeBuilding(2,2,"BASE",1);
    placeBuilding(2,3,"BASE",1);
    placeBuilding(GRID_W-3, GRID_H-3,"BASE",2);
    placeBuilding(GRID_W-3, GRID_H-4,"BASE",2);
    const cities = [
      {x:6,y:1},{x:9,y:1},{x:6,y:10},{x:9,y:10},
      {x:4,y:5},{x:11,y:5},{x:7,y:6},{x:8,y:6}
    ];
    for(const c of cities) placeBuilding(c.x,c.y,"CITY",null);
  }

  function generateMapIslandDash(){
    initEmptyLayers();
    for(let y=0;y<GRID_H;y++){
      for(let x=0;x<GRID_W;x++){
        Game.terrain[y][x] = TERRAIN.WATER;
      }
    }
    for(let y=2;y<GRID_H-2;y++){
      for(let x=2;x<GRID_W-2;x++){
        Game.terrain[y][x] = TERRAIN.PLAINS;
      }
    }
    for(let x=2;x<GRID_W-2;x++){
      Game.terrain[5][x] = TERRAIN.ROAD;
      Game.terrain[6][x] = TERRAIN.ROAD;
    }
    const forests = [{x:3,y:3},{x:12,y:3},{x:3,y:8},{x:12,y:8},{x:7,y:5},{x:8,y:6}];
    for(const p of forests) if(inBounds(p.x,p.y)) Game.terrain[p.y][p.x] = TERRAIN.FOREST;
    const mountains = [{x:7,y:3},{x:8,y:3},{x:7,y:8},{x:8,y:8}];
    for(const p of mountains) if(inBounds(p.x,p.y)) Game.terrain[p.y][p.x] = TERRAIN.MOUNTAIN;
    placeBuilding(2,2,"HQ",1);
    placeBuilding(GRID_W-3, GRID_H-3, "HQ", 2);
    placeBuilding(2,3,"BASE",1);
    placeBuilding(3,2,"BASE",1);
    placeBuilding(GRID_W-3, GRID_H-4,"BASE",2);
    placeBuilding(GRID_W-4, GRID_H-3,"BASE",2);
    const cities = [
      {x:5,y:4},{x:10,y:4},{x:5,y:7},{x:10,y:7},
      {x:7,y:4},{x:8,y:4},{x:7,y:7},{x:8,y:7}
    ];
    for(const c of cities) placeBuilding(c.x,c.y,"CITY",null);
  }

  function generateMapUrbanClash(){
    initEmptyLayers();
    for(let y=0;y<GRID_H;y++){
      for(let x=0;x<GRID_W;x++){
        Game.terrain[y][x] = TERRAIN.PLAINS;
      }
    }
    for(let y=3;y<GRID_H-3;y++){
      for(let x=4;x<GRID_W-4;x++){
        if((x+y)%2===0) Game.terrain[y][x] = TERRAIN.ROAD;
      }
    }
    const forests = [{x:2,y:2},{x:13,y:2},{x:2,y:9},{x:13,y:9}];
    forests.push({x:4,y:4},{x:11,y:4},{x:4,y:7},{x:11,y:7});
    for(const p of forests) if(inBounds(p.x,p.y)) Game.terrain[p.y][p.x] = TERRAIN.FOREST;
    const mountains = [{x:7,y:0},{x:8,y:0},{x:7,y:11},{x:8,y:11}];
    for(const p of mountains) if(inBounds(p.x,p.y)) Game.terrain[p.y][p.x] = TERRAIN.MOUNTAIN;
    placeBuilding(1,5,"HQ",1);
    placeBuilding(GRID_W-2, GRID_H-6, "HQ", 2);
    placeBuilding(1,4,"BASE",1);
    placeBuilding(1,6,"BASE",1);
    placeBuilding(GRID_W-2, GRID_H-7,"BASE",2);
    placeBuilding(GRID_W-2, GRID_H-5,"BASE",2);
    const cities = [];
    for(let x=4;x<GRID_W-4;x+=2){
      cities.push({x,y:2},{x,y:9});
    }
    cities.push({x:7,y:5},{x:8,y:6});
    for(const c of cities) placeBuilding(c.x,c.y,"CITY",null);
  }

  function generateMapBridgeBlitz(){
    initEmptyLayers();
    for(let y=0;y<GRID_H;y++){
      for(let x=0;x<GRID_W;x++){
        Game.terrain[y][x] = TERRAIN.PLAINS;
      }
    }
    for(let y=0;y<GRID_H;y++){
      Game.terrain[y][6] = TERRAIN.WATER;
      Game.terrain[y][9] = TERRAIN.WATER;
      Game.terrain[y][7] = TERRAIN.ROAD;
      Game.terrain[y][8] = TERRAIN.ROAD;
    }
    const forests = [
      {x:2,y:2},{x:3,y:3},{x:12,y:2},{x:13,y:3},
      {x:2,y:8},{x:3,y:9},{x:12,y:8},{x:13,y:9},
      {x:6,y:2},{x:6,y:9},{x:9,y:2},{x:9,y:9}
    ];
    for(const p of forests) if(inBounds(p.x,p.y)) Game.terrain[p.y][p.x] = TERRAIN.FOREST;
    const mountains = [{x:7,y:5},{x:8,y:6}];
    for(const p of mountains) if(inBounds(p.x,p.y)) Game.terrain[p.y][p.x] = TERRAIN.MOUNTAIN;
    placeBuilding(1,5,"HQ",1);
    placeBuilding(GRID_W-2, GRID_H-6,"HQ",2);
    placeBuilding(2,5,"BASE",1);
    placeBuilding(1,6,"BASE",1);
    placeBuilding(GRID_W-3, GRID_H-6,"BASE",2);
    placeBuilding(GRID_W-2, GRID_H-7,"BASE",2);
    const cities = [
      {x:4,y:2},{x:11,y:2},{x:4,y:9},{x:11,y:9},
      {x:7,y:3},{x:8,y:3},{x:7,y:8},{x:8,y:8},
      {x:5,y:6},{x:10,y:6}
    ];
    for(const c of cities) placeBuilding(c.x,c.y,"CITY",null);
  }

  function generateCustomMapFromText(text){
    initEmptyLayers();
    const parsed = parseCustomText(text || DEFAULT_CUSTOM_MAP);
    customGrid = parsed.terrain;
    customUnits = parsed.units;

    for(let y=0;y<GRID_H;y++){
      for(let x=0;x<GRID_W;x++){
        const ch = customGrid[y][x] ?? ".";
        switch(ch){
          case 'f': Game.terrain[y][x] = TERRAIN.FOREST; break;
          case 'm': Game.terrain[y][x] = TERRAIN.MOUNTAIN; break;
          case '=': Game.terrain[y][x] = TERRAIN.ROAD; break;
          case '~': Game.terrain[y][x] = TERRAIN.WATER; break;
          default: Game.terrain[y][x] = TERRAIN.PLAINS;
        }
        if("cbh12HR".includes(ch)){
          const kind = (ch==='c') ? "CITY" : (ch==='b'||ch==='1'||ch==='2') ? "BASE" : "HQ";
          const owner = (ch==='1'||ch==='H') ? 1 : (ch==='2'||ch==='R') ? 2 : null;
          placeBuilding(x,y,kind,owner);
        }
      }
    }
    // Ensure HQs exist
    const hasHQ1 = Game.buildings.flat().some(b=>b && b.kindId==="HQ" && b.owner===1);
    const hasHQ2 = Game.buildings.flat().some(b=>b && b.kindId==="HQ" && b.owner===2);
    if(!hasHQ1) placeBuilding(1,1,"HQ",1);
    if(!hasHQ2) placeBuilding(GRID_W-2, GRID_H-2,"HQ",2);

    // Place starting units from custom layer
    for(let y=0;y<GRID_H;y++){
      for(let x=0;x<GRID_W;x++){
        const u = unitFromChar(customUnits[y][x]);
        if(u){
          Game.units.push(makeUnit(u.unit, u.owner, x, y));
        }
      }
    }
  }

  // Custom map editor state
  const CUSTOM_TILES = [
    { id:"PLAINS", char:".", label:"Plains", color:"#1f4d36", layer:"terrain" },
    { id:"FOREST", char:"f", label:"Forest", color:"#19412d", layer:"terrain" },
    { id:"MOUNTAIN", char:"m", label:"Mountain", color:"#3a3b46", layer:"terrain" },
    { id:"ROAD", char:"=", label:"Road", color:"#3a3f4a", layer:"terrain" },
    { id:"WATER", char:"~", label:"Water", color:"#0f335c", layer:"terrain" },
    { id:"CITY", char:"c", label:"City", color:"#2b3a63", layer:"terrain" },
    { id:"BASE1", char:"1", label:"Base (Blue)", color:"#21406d", layer:"terrain" },
    { id:"BASE2", char:"2", label:"Base (Red)", color:"#6d213b", layer:"terrain" },
    { id:"HQ1", char:"H", label:"HQ (Blue)", color:"#2f4a86", layer:"terrain" },
    { id:"HQ2", char:"R", label:"HQ (Red)", color:"#8a2b2b", layer:"terrain" }
  ];

  const CUSTOM_UNITS = [
    { id:"P1_INF",  char:"A", label:"P1 Infantry",  layer:"unit", owner:1, unit:"INF", color:COLORS.p1Dark },
    { id:"P1_RECON",char:"B", label:"P1 Recon",     layer:"unit", owner:1, unit:"RECON", color:COLORS.p1Dark },
    { id:"P1_TANK", char:"C", label:"P1 Tank",      layer:"unit", owner:1, unit:"TANK", color:COLORS.p1Dark },
    { id:"P1_MDT",  char:"D", label:"P1 Md Tank",   layer:"unit", owner:1, unit:"MDT", color:COLORS.p1Dark },
    { id:"P1_ART",  char:"E", label:"P1 Artillery", layer:"unit", owner:1, unit:"ART", color:COLORS.p1Dark },
    { id:"P1_RKT",  char:"F", label:"P1 Rockets",   layer:"unit", owner:1, unit:"RKT", color:COLORS.p1Dark },
    { id:"SEP_UNIT",char:" ", label:"—", layer:"unit-sep" },
    { id:"P2_INF",  char:"a", label:"P2 Infantry",  layer:"unit", owner:2, unit:"INF", color:COLORS.p2Dark },
    { id:"P2_RECON",char:"b", label:"P2 Recon",     layer:"unit", owner:2, unit:"RECON", color:COLORS.p2Dark },
    { id:"P2_TANK", char:"c", label:"P2 Tank",      layer:"unit", owner:2, unit:"TANK", color:COLORS.p2Dark },
    { id:"P2_MDT",  char:"d", label:"P2 Md Tank",   layer:"unit", owner:2, unit:"MDT", color:COLORS.p2Dark },
    { id:"P2_ART",  char:"e", label:"P2 Artillery", layer:"unit", owner:2, unit:"ART", color:COLORS.p2Dark },
    { id:"P2_RKT",  char:"f", label:"P2 Rockets",   layer:"unit", owner:2, unit:"RKT", color:COLORS.p2Dark },
    { id:"UNIT_CLEAR", char:".", label:"Erase Unit", layer:"unit", color:"#0b1020" }
  ];

  const CUSTOM_ENTRIES = [...CUSTOM_TILES, ...CUSTOM_UNITS];

  let customGrid = [];
  let customUnits = [];
  let customTileSelection = CUSTOM_TILES[0];

  function gridToText(grid){
    return grid.map(row=>row.join("")).join("\n");
  }

  function gridToTextWithUnits(grid, units){
    const terrainText = gridToText(grid);
    if(!units || !units.length) return terrainText;
    const hasUnits = units.some(row=>row.some(ch=>ch !== "."));
    if(!hasUnits) return terrainText;
    const unitText = gridToText(units);
    return `${terrainText}\n---\n${unitText}`;
  }

  function textToGrid(text, fill="."){
    const out = Array.from({length:GRID_H}, ()=>Array.from({length:GRID_W}, ()=>fill));
    const lines = (text||"").split("\n");
    for(let y=0;y<Math.min(GRID_H, lines.length); y++){
      const row = lines[y];
      for(let x=0;x<Math.min(GRID_W, row.length); x++){
        out[y][x] = row[x] || fill;
      }
    }
    return out;
  }

  function splitCustomText(text){
    const parts = (text||"").split("\n---\n");
    return {
      terrainText: parts[0] || "",
      unitText: parts[1] || ""
    };
  }

  function parseCustomText(text){
    const { terrainText, unitText } = splitCustomText(text);
    return {
      terrain: textToGrid(terrainText, "."),
      units: textToGrid(unitText, ".")
    };
  }

  function tileByChar(ch){
    return CUSTOM_ENTRIES.find(t=>t.char===ch) || CUSTOM_TILES[0];
  }

  function initCustomGridFromText(text){
    const parsed = parseCustomText(text || DEFAULT_CUSTOM_MAP);
    customGrid = parsed.terrain;
    customUnits = parsed.units;
    if(customGridEl){
      renderCustomGrid();
    }
  }

  function terrainIdFromChar(ch){
    if(ch==="f") return "FOREST";
    if(ch==="m") return "MOUNTAIN";
    if(ch==="=") return "ROAD";
    if(ch==="~") return "WATER";
    return "PLAINS";
  }

  function buildingFromChar(ch){
    if(ch==="c") return { kind:"CITY", owner:null };
    if(ch==="b") return { kind:"BASE", owner:null };
    if(ch==="1") return { kind:"BASE", owner:1 };
    if(ch==="2") return { kind:"BASE", owner:2 };
    if(ch==="h") return { kind:"HQ", owner:null };
    if(ch==="H") return { kind:"HQ", owner:1 };
    if(ch==="R") return { kind:"HQ", owner:2 };
    return null;
  }

  function unitFromChar(ch){
    if(!ch || ch===".") return null;
    const unitEntry = CUSTOM_UNITS.find(u=>u.char===ch);
    if(!unitEntry || unitEntry.layer!=="unit") return null;
    return { owner: unitEntry.owner, unit: unitEntry.unit };
  }

  function setTileVisual(cell, terrainChar, unitChar=null){
    if(!cell) return;
    const tId = terrainIdFromChar(terrainChar);
    const t = TERRAIN[tId] || TERRAIN.PLAINS;
    const terrainSprite = getTerrainSprite(t.id);
    const b = buildingFromChar(terrainChar);
    const u = unitFromChar(unitChar);
    let bg = tileByChar(terrainChar).color;
    const imgs = [];
    const sizes = [];
    const positions = [];

    if(b){
      const sprite = getBuildingSprite(b.kind, b.owner ?? 0);
      if(sprite){
        imgs.push(`url(${sprite.src})`);
        sizes.push("cover");
        positions.push("center");
      }
    } else if(terrainSprite){
      imgs.push(`url(${terrainSprite.src})`);
      sizes.push("cover");
      positions.push("center");
    }

    if(u){
      const spriteList = getSpriteList(u.unit, u.owner);
      const sprite = spriteList[0];
      if(sprite){
        imgs.unshift(`url(${sprite.src})`);
        sizes.unshift("70%");
        positions.unshift("center");
      }
      const p = owningPlayer(u.owner);
      if(p) bg = p.dark;
    }
    cell.style.backgroundColor = bg;
    cell.style.backgroundImage = imgs.length ? imgs.join(", ") : "none";
    cell.style.backgroundSize = sizes.join(", ") || "cover";
    cell.style.backgroundPosition = positions.join(", ") || "center";
    cell.style.backgroundRepeat = "no-repeat";
    cell.textContent = "";
  }

  function paintCustomCell(x,y){
    if(!customGrid[y] || customGrid[y][x]===undefined) return;
    if(!customUnits[y]) customUnits[y] = Array.from({length:GRID_W}, ()=>".");
    if(customTileSelection.layer==="unit"){
      customUnits[y][x] = customTileSelection.char;
    } else {
      customGrid[y][x] = customTileSelection.char;
    }
    const idx = y*GRID_W + x;
    const cell = customGridEl ? customGridEl.children[idx] : null;
    if(cell){
      setTileVisual(cell, customGrid[y][x], customUnits[y][x]);
    }
  }

  function renderCustomPalette(){
    if(!customPalette) return;
    customPalette.innerHTML = "";
    for(const t of CUSTOM_ENTRIES){
      const btn = document.createElement("div");
      if(t.layer==="unit-sep"){
        btn.style.width = "100%";
        btn.style.height = "4px";
        btn.style.borderTop = "1px solid #23346b";
        btn.style.opacity = 0.5;
        customPalette.appendChild(btn);
        continue;
      }
      btn.className = "tileSwatch" + (customTileSelection.id===t.id ? " active" : "");
      if(t.layer==="unit"){
        setTileVisual(btn, ".", t.char);
      } else {
        setTileVisual(btn, t.char);
      }
      btn.title = t.label;
      btn.addEventListener("click", ()=>{
        customTileSelection = t;
        renderCustomPalette();
      });
      customPalette.appendChild(btn);
    }
  }

  function renderCustomGrid(){
    if(!customGridEl) return;
    customGridEl.innerHTML = "";
    let painting = false;
    const handlePaint = (e)=>{
      const cell = e.target;
      if(!cell.classList.contains("customCell")) return;
      const x = Number(cell.dataset.x);
      const y = Number(cell.dataset.y);
      paintCustomCell(x,y);
    };
    customGridEl.onmousedown = (e)=>{ painting=true; handlePaint(e); };
    customGridEl.onmouseup = ()=>{ painting=false; };
    customGridEl.onmouseleave = ()=>{ painting=false; };
    customGridEl.onmousemove = (e)=>{ if(painting) handlePaint(e); };
    for(let y=0;y<GRID_H;y++){
      for(let x=0;x<GRID_W;x++){
        const cell = document.createElement("div");
        cell.className = "customCell";
        const uChar = (customUnits[y] && customUnits[y][x]) || ".";
        setTileVisual(cell, customGrid[y][x], uChar);
        cell.dataset.x = String(x);
        cell.dataset.y = String(y);
        cell.addEventListener("mousedown", handlePaint);
        customGridEl.appendChild(cell);
      }
    }
    document.addEventListener("mouseup", ()=>{ painting=false; }, { once:true });
  }

  const MAPS = [
    { id:"CLASSIC", name:"Frontline Plains", desc:"Balanced lanes with central roads and forests.", gen:generateMapClassic, img:"assets/frontier.png" },
    { id:"RIVER", name:"River Run", desc:"Split by a river with flanking roads and bridges.", gen:generateMapRiverRun, img:"assets/river.png" },
    { id:"MOUNTAIN", name:"Mountain Pass", desc:"Narrow passes through heavy mountains.", gen:generateMapMountainPass, img:"assets/mountain_map.png" },
    { id:"ISLAND", name:"Island Dash", desc:"Central island brawl surrounded by water.", gen:generateMapIslandDash, img:"assets/island.png" },
    { id:"URBAN", name:"Urban Clash", desc:"Grid of roads and cities for close quarters.", gen:generateMapUrbanClash, img:"assets/urban.png" },
    { id:"BRIDGE", name:"Bridge Blitz", desc:"Two bridges with central high ground and forest flanks.", gen:generateMapBridgeBlitz, img:"assets/bridge.png" },
    { id:"CUSTOM", name:"Custom Map", desc:"Use the editor text to build your own layout.", gen:generateCustomMapFromText, img:null }
  ];

  /***********************************************************************
   * Game Initialization / Reset
   ***********************************************************************/
  function loadSprites(){
    for(const [typeId, owners] of Object.entries(SPRITE_SOURCES)){
      SPRITE_IMAGES[typeId] = {};
      for(const [ownerId, srcList] of Object.entries(owners)){
        SPRITE_IMAGES[typeId][ownerId] = srcList.map(src=>{
          const img = new Image();
          img.src = src;
          return img;
        });
      }
    }

    for(const [kindId, owners] of Object.entries(BUILDING_SOURCES)){
      BUILDING_IMAGES[kindId] = {};
      for(const [ownerId, src] of Object.entries(owners)){
        const img = new Image();
        img.src = src;
        BUILDING_IMAGES[kindId][ownerId] = img;
      }
    }

    for(const [id, src] of Object.entries(TERRAIN_SOURCES)){
      const img = new Image();
      img.src = src;
      TERRAIN_IMAGES[id] = img;
    }
  }

  const DEFAULT_CUSTOM_MAP =
`.~~~~~~~........
.~......f.......
.~.H....=....R..
.~......=.......
.~..c...=...c...
.~..b...==...b..
.~......==......
.~..c...=...c...
.~......=.......
.~.1....=....2..
.~......f.......
.~~~~~~~........`;

  function applySelectedMap(){
    const id = Game.selectedMap || "CLASSIC";
    const entry = MAPS.find(m=>m.id===id);
    if(id==="CUSTOM"){
      generateCustomMapFromText(Game.customMapText || DEFAULT_CUSTOM_MAP);
    } else if(entry && entry.gen){
      entry.gen();
    } else {
      generateMapClassic();
    }
  }

  function freshMatch(){
    Game.day = 1;
    Game.currentPlayer = 1;
    Game.funds = { 1: 5000, 2: 5000 };
    Game.units = [];
    Game.sel = null;
    Game.phase = "IDLE";
    Game.moveMap = null;
    Game.moveTiles = new Set();
    Game.path = [];
    Game.atkTiles = new Set();
    Game.baseCycleIdx = {1:0, 2:0};
    Game.hovered = {x:-1,y:-1};
    Game.gameOver = false;
    Game.coMeter = {1:0, 2:0};
    Game.coState = {1:null, 2:null};
    Game.coChoice = {1:"ANDY", 2:"ANDY"};
    sKeyHeld = false;
    sBtnHeld = false;
    dKeyHeld = false;
    dBtnHeld = false;
    mKeyHeld = false;
    mBtnHeld = false;
    updateRangePreview();
    if(!Game.customMapText) Game.customMapText = DEFAULT_CUSTOM_MAP;

    applySelectedMap();

    if(Game.selectedMap!=="CUSTOM"){
      // Starting units (balanced; includes some new unit types)
      Game.units.push(makeUnit("INF",1, 2,2));
      Game.units.push(makeUnit("INF",1, 3,1));
      Game.units.push(makeUnit("RECON",1, 3,2));
      Game.units.push(makeUnit("TANK",1, 2,3));
      Game.units.push(makeUnit("ART",1, 4,2));

      Game.units.push(makeUnit("INF",2, GRID_W-3, GRID_H-3));
      Game.units.push(makeUnit("INF",2, GRID_W-4, GRID_H-2));
      Game.units.push(makeUnit("RECON",2, GRID_W-4, GRID_H-4));
      Game.units.push(makeUnit("TANK",2, GRID_W-3, GRID_H-4));
      Game.units.push(makeUnit("ART",2, GRID_W-5, GRID_H-3));
    }

    clearLog();
    logLine("Match start. Player 1 begins.", 1);
    updateUI();
    renderLegend(); // NEW
    autoOpenShopForCurrentPlayer();
  }

  function hardReset(){
    UNIT_ID_SEQ = 1;
    freshMatch();
  }

  /***********************************************************************
   * Logging
   ***********************************************************************/
  function clearLog(){
    logBox.innerHTML = "";
  }

  function logLine(text, playerId=null){
    const p = document.createElement("p");
    p.className = "line " + (playerId===1 ? "p1" : playerId===2 ? "p2" : "");
    p.textContent = text;
    logBox.appendChild(p);
    logBox.scrollTop = logBox.scrollHeight;
  }

  function consumeAction(u){
    if(!u) return;
    if(typeof u.actionsLeft!=="number") u.actionsLeft = 1;
    u.actionsLeft = Math.max(0, u.actionsLeft - 1);
    if(u.actionsLeft > 0){
      u.moved = false;
      u.acted = false;
    } else {
      u.moved = true;
      u.acted = true;
    }
  }

  function refreshPlayerUnits(playerId, minActions=1){
    for(const u of Game.units){
      if(u.owner===playerId){
        const targetActions = Math.max(minActions, 1);
        u.actionsLeft = targetActions;
        u.moved = false;
        u.acted = false;
      }
    }
  }

  /***********************************************************************
   * Income & Turn Progression
   ***********************************************************************/
  function countOwnedIncome(playerId){
    let total = 0;
    for(let y=0;y<GRID_H;y++){
      for(let x=0;x<GRID_W;x++){
        const b = buildingAt(x,y);
        if(b && b.owner===playerId){
          total += b.def.income;
        }
      }
    }
    return total;
  }

  function resetUnitsForTurn(playerId){
    for(const u of Game.units){
      if(u.owner===playerId){
        const dbl = hasDoubleActions(playerId);
        u.moved = false;
        u.acted = false;
        u.actionsLeft = dbl ? 2 : 1;
      }
    }
  }

  function endTurn(){
    if(Game.gameOver) return;

    clearCOState(Game.currentPlayer);

    closeShop();
    closeKey(); // NEW

    clearSelection();

    Game.currentPlayer = (Game.currentPlayer===1) ? 2 : 1;

    if(Game.currentPlayer===1){
      Game.day += 1;
      logLine("— Day " + Game.day + " —", null);
    }

    const income = countOwnedIncome(Game.currentPlayer);
    Game.funds[Game.currentPlayer] += income;
    logLine(`${owningPlayer(Game.currentPlayer).name} receives $${income} funds (income).`, Game.currentPlayer);

    resetUnitsForTurn(Game.currentPlayer);
    grantCOMeter(Game.currentPlayer, 10);

    updateUI();
    autoOpenShopForCurrentPlayer();
    showTurnOverlay({
      playerId: Game.currentPlayer,
      day: Game.day,
      income,
      co: getCOChoice(Game.currentPlayer)
    });
  }

  /***********************************************************************
   * Selection & Phases
   ***********************************************************************/
  function clearSelection(){
    Game.sel = null;
    Game.phase = "IDLE";
    Game.moveMap = null;
    Game.moveTiles = new Set();
    Game.atkTiles = new Set();
    Game.path = [];
    elSelHint.textContent = "Click a unit, building, or tile.";
    elSelKv.innerHTML = "";
    elSelStats.innerHTML = "";
  }

  function selectUnit(u){
    if(Game.gameOver) return;
    clearSelection();
    Game.sel = { type:"unit", unit:u, x:u.x, y:u.y };
    updateSelectionPanel();
    computeMoveOverlayIfApplicable();
    computeAttackOverlayIfApplicable();
    if(canAttackThisTurn(u)){
      Game.phase = "ATTACKING";
    }
  }

  function selectBuilding(b, x, y){
    if(Game.gameOver) return;
    clearSelection();
    Game.sel = { type:"building", building:b, x, y };
    updateSelectionPanel();
  }

  // NEW: select tile (even empty) so we can show defense stat
  function selectTile(x,y){
    if(Game.gameOver) return;
    clearSelection();
    Game.sel = { type:"tile", x, y };
    updateSelectionPanel();
  }

  function updateSelectionPanel(){
    elSelKv.innerHTML = "";
    elSelStats.innerHTML = "";

    if(!Game.sel){
      elSelHint.textContent = "Click a unit, building, or tile.";
      return;
    }

    if(Game.sel.type==="unit"){
      const u = Game.sel.unit;
      const p = owningPlayer(u.owner);
      const hpPct = u.hp / u.def.maxHP;
      const { minR, maxR } = getRangeForUnit(u);
      const rangeText = formatRangeText(minR, maxR);
      const sprite = makeSpriteNode(u.typeId, u.owner, 80);
      const imgRow = document.createElement("div");
      imgRow.className = "selImgRow";
      imgRow.appendChild(sprite);
      const moveStatus = u.moved ? "Moved" : "Can Move";
      const canFire = canAttackThisTurn(u);
      let atkStatus = "Can Atk";
      if(u.acted) atkStatus = "Attacked";
      else if(isIndirectUnit(u) && u.moved) atkStatus = "No Atk (moved)";
      else if(u.owner!==Game.currentPlayer) atkStatus = "Enemy";
      else if(!canFire) atkStatus = "No Atk";
      const statusGood = (u.owner===Game.currentPlayer) && (!u.moved && !u.acted);

      elSelHint.textContent = "Press ESC to unselect";
      addKV("Owner", p.name);
      addKV("Type", `${u.def.name} (${u.def.abbr})`); // NEW: show abbr
      addKV("HP", `${u.hp}/${u.def.maxHP}`);
      addKV("Move", `${u.def.move} (${u.def.movementType})`);
      addKV("Range", rangeText);
      addKV("Status", `${moveStatus} / ${atkStatus}`);
      addKV("Damage", damageDisplayText(u.def.id).replace("Damage: ",""));

      const tile = terrainAt(u.x,u.y);
      addKV("Terrain", tile.name);
      const b = buildingAt(u.x,u.y);
      addKV("Tile Cover", formatStars(tileDefenseStat(u.x,u.y)));

      if(b){
        addKV("Building", b.def.name + (b.owner ? ` (Owned by P${b.owner})` : " (Neutral)"));
      }
      const blurb = UNIT_BLURB[u.def.id];
      if(blurb) addKV("Role", blurb);

      // Detailed stat pills similar to shop cards
      const pills = [];
      const typePill = document.createElement("span");
      typePill.className = "pill";
      typePill.textContent = u.def.name;
      pills.push(typePill);

      const hpPill = document.createElement("span");
      hpPill.className = "pill " + (hpPct>0.66 ? "good" : hpPct>0.33 ? "warn" : "bad");
      hpPill.textContent = `HP ${u.hp}/${u.def.maxHP}`;
      pills.push(hpPill);

      const dmgPill = document.createElement("span");
      dmgPill.className = "pill warn";
      dmgPill.style.cursor = "pointer";
      const setDmgText = ()=>{ dmgPill.textContent = damageDisplayText(u.def.id); };
      setDmgText();
      dmgPill.title = "Click to toggle detailed damage view";
      dmgPill.addEventListener("click", ()=>{
        Game.dmgDetail = !Game.dmgDetail;
        updateSelectionPanel();
      });
      pills.push(dmgPill);

      const capPill = document.createElement("span");
      capPill.className = "pill " + (u.def.canCapture ? "good" : "");
      capPill.textContent = u.def.canCapture ? "Can capture" : "No capture";
      pills.push(capPill);

      const movePill = document.createElement("span");
      movePill.className = "pill";
      movePill.textContent = `Move: ${u.def.move} (${u.def.movementType})`;

      const rangePill = document.createElement("span");
      rangePill.className = "pill";
      rangePill.textContent = `Range: ${rangeText}`;

      const statusPill = document.createElement("span");
      statusPill.className = "pill " + (statusGood ? "good" : "bad");
      statusPill.textContent = `Status: ${moveStatus} / ${atkStatus}`;

      const terrain = terrainAt(u.x,u.y);
      const terrainPill = document.createElement("span");
      terrainPill.className = "pill";
      terrainPill.textContent = `Terrain: ${terrain.name}`;

      const defPill = document.createElement("span");
      defPill.className = "pill";
      defPill.textContent = `Cover: ${formatStars(tileDefenseStat(u.x,u.y))}`;

      const row1 = document.createElement("div");
      row1.className = "selRow center";
      row1.appendChild(typePill);
      row1.appendChild(hpPill);

      const row2 = document.createElement("div");
      row2.className = "selRow center";
      row2.appendChild(dmgPill);
      row2.appendChild(capPill);

      const row3 = document.createElement("div");
      row3.className = "selRow center";
      row3.appendChild(movePill);
      row3.appendChild(rangePill);

      const row4 = document.createElement("div");
      row4.className = "selRow center";
      row4.appendChild(statusPill);
      row4.appendChild(terrainPill);
      row4.appendChild(defPill);

      setSelStats([imgRow, row1, row2, row3, row4]);
    } else if(Game.sel.type==="building") {
      const b = Game.sel.building;
      elSelHint.textContent = "Selected building.";

      const imgRow = document.createElement("div");
      imgRow.className = "selImgRow";
      imgRow.appendChild(makeBuildingNode(b.kindId, b.owner ?? 0, 80));

      const typePill = document.createElement("span");
      typePill.className = "pill";
      typePill.textContent = b.def.name;

      const ownerPill = document.createElement("span");
      ownerPill.className = "pill";
      ownerPill.textContent = b.owner ? `Owner: P${b.owner}` : "Owner: Neutral";

      const hpPill = document.createElement("span");
      hpPill.className = "pill warn";
      hpPill.textContent = `HP: ${b.capturePoints}/20`;

      const defPill = document.createElement("span");
      defPill.className = "pill";
      defPill.textContent = `Cover: ${formatStars(tileDefenseStat(Game.sel.x, Game.sel.y))}`;

      const terrainPill = document.createElement("span");
      terrainPill.className = "pill";
      terrainPill.textContent = `Terrain: ${terrainAt(Game.sel.x, Game.sel.y).name}`;

      const row1 = document.createElement("div");
      row1.className = "selRow center";
      row1.appendChild(typePill);
      row1.appendChild(ownerPill);
      row1.appendChild(hpPill);

      const row2 = document.createElement("div");
      row2.className = "selRow center";
      row2.appendChild(defPill);
      row2.appendChild(terrainPill);

      setSelStats([imgRow, row1, row2]);
    } else {
      // NEW: tile selection view
      elSelHint.textContent = "Selected tile.";
      const t = terrainAt(Game.sel.x, Game.sel.y);

      const imgRow = document.createElement("div");
      imgRow.className = "selImgRow";
      imgRow.appendChild(makeTerrainNode(t, 80));

      const terrainPill = document.createElement("span");
      terrainPill.className = "pill";
      terrainPill.textContent = `Terrain: ${t.name}`;

      const defPill = document.createElement("span");
      defPill.className = "pill";
      defPill.textContent = `Cover: ${formatStars(tileDefenseStat(Game.sel.x, Game.sel.y))}`;

      const row1 = document.createElement("div");
      row1.className = "selRow center";
      row1.appendChild(terrainPill);
      row1.appendChild(defPill);

      setSelStats([imgRow, row1]);
    }
  }

  function addKV(k,v){
    const a=document.createElement("div"); a.textContent=k;
    const b=document.createElement("div"); b.textContent=v;
    elSelKv.appendChild(a); elSelKv.appendChild(b);
  }

  function setSelStats(nodes){
    elSelStats.innerHTML = "";
    for(const n of nodes){
      elSelStats.appendChild(n);
    }
  }

  function panelsOpen(){
    return shopBox.style.display==="block" || keyBox.style.display==="block";
  }

  function updateHelpPosition(){
    if(!helpBox || !lowerPanels) return;
    const parent = helpBox.parentElement;
    if(!parent) return;
    if(panelsOpen()){
      if(helpBox.nextElementSibling){
        parent.appendChild(helpBox);
      }
    } else {
      parent.insertBefore(helpBox, lowerPanels);
    }
  }

  /***********************************************************************
   * CO selection & income panel
   ***********************************************************************/
  function getCOChoice(playerId){
    const id = Game.coChoice[playerId] || "ANDY";
    return CO_DATA[id] || CO_DATA.ANDY;
  }

  function setCOChoice(playerId, coId){
    if(!CO_DATA[coId]) return;
    Game.coChoice[playerId] = coId;
    renderCOSection();
    logLine(`${owningPlayer(playerId).name} selects ${CO_DATA[coId].name}.`, playerId);
  }

  function setCOAvatar(el, co, playerId){
    if(!el) return;
    const p = owningPlayer(playerId);
    el.style.borderColor = p.color;
    el.style.background = `linear-gradient(135deg, ${p.dark}, ${p.color}55)`;
    el.innerHTML = "";
    if(co.img){
      const img = document.createElement("img");
      img.src = co.img;
      img.alt = co.name;
      el.appendChild(img);
    } else {
      el.textContent = co.name.slice(0,1);
    }
  }

  function renderCOSection(){
    const co1 = getCOChoice(1);
    const co2 = getCOChoice(2);

    p1COName.textContent = co1.name;
    p2COName.textContent = co2.name;
    if(p1NameLabel) p1NameLabel.textContent = owningPlayer(1).name;
    if(p2NameLabel) p2NameLabel.textContent = owningPlayer(2).name;
    p1COSpecialty.innerHTML = `<div class="abilityLine"><span class="abilityBadge">Day-to-day</span><span class="abilityCopy">${co1.specialty}</span></div>`;
    p2COSpecialty.innerHTML = `<div class="abilityLine"><span class="abilityBadge">Day-to-day</span><span class="abilityCopy">${co2.specialty}</span></div>`;
    p1COPower.innerHTML = `<div class="abilityLine"><span class="abilityBadge">CO Power</span><span class="abilityCopy">${co1.power}</span></div>`;
    p2COPower.innerHTML = `<div class="abilityLine"><span class="abilityBadge">CO Power</span><span class="abilityCopy">${co2.power}</span></div>`;
    p1COSuper.innerHTML = `<div class="abilityLine"><span class="abilityBadge">Super CO</span><span class="abilityCopy">${co1.super}</span></div>`;
    p2COSuper.innerHTML = `<div class="abilityLine"><span class="abilityBadge">Super CO</span><span class="abilityCopy">${co2.super}</span></div>`;

    setCOAvatar(p1COAvatar, co1, 1);
    setCOAvatar(p2COAvatar, co2, 2);
    setCOAvatar(p1TopAvatar, co1, 1);
    setCOAvatar(p2TopAvatar, co2, 2);
    if(p1TopTooltip) p1TopTooltip.innerHTML = `${p1COSpecialty.innerHTML}${p1COPower.innerHTML}${p1COSuper.innerHTML}`;
    if(p2TopTooltip) p2TopTooltip.innerHTML = `${p2COSpecialty.innerHTML}${p2COPower.innerHTML}${p2COSuper.innerHTML}`;

    const m1 = Game.coMeter[1] ?? 0;
    const m2 = Game.coMeter[2] ?? 0;
    if(p1MeterFill) p1MeterFill.style.width = `${clamp(m1,0,100)}%`;
    if(p2MeterFill) p2MeterFill.style.width = `${clamp(m2,0,100)}%`;
    if(p1TopMeterFill) p1TopMeterFill.style.width = `${clamp(m1,0,100)}%`;
    if(p2TopMeterFill) p2TopMeterFill.style.width = `${clamp(m2,0,100)}%`;
    if(p1MeterLabel) p1MeterLabel.textContent = `Meter ${Math.round(m1)}%`;
    if(p2MeterLabel) p2MeterLabel.textContent = `Meter ${Math.round(m2)}%`;

    const powerCost = 60, superCost = 100;
    const p1State = Game.coState[1];
    const p2State = Game.coState[2];
    const p1PowerDisabled = m1 < powerCost || p1State;
    const p2PowerDisabled = m2 < powerCost || p2State;
    const p1SuperDisabled = m1 < superCost || p1State;
    const p2SuperDisabled = m2 < superCost || p2State;
    if(p1PowerBtn) p1PowerBtn.disabled = p1PowerDisabled;
    if(p2PowerBtn) p2PowerBtn.disabled = p2PowerDisabled;
    if(p1SuperBtn) p1SuperBtn.disabled = p1SuperDisabled;
    if(p2SuperBtn) p2SuperBtn.disabled = p2SuperDisabled;
    if(p1TopPower) p1TopPower.disabled = p1PowerDisabled;
    if(p2TopPower) p2TopPower.disabled = p2PowerDisabled;
    if(p1TopSuper) p1TopSuper.disabled = p1SuperDisabled;
    if(p2TopSuper) p2TopSuper.disabled = p2SuperDisabled;
  }

  function openCOModal(playerId){
    coModalTarget = playerId;
    if(coModalHint) coModalHint.textContent = `Assign a CO for Player ${playerId}`;
    renderCOList();
    if(coModal) coModal.style.display = "flex";
  }

  function closeCOModal(){
    if(coModal) coModal.style.display = "none";
    coModalTarget = null;
  }

  function renderCOList(){
    if(!coList) return;
    coList.innerHTML = "";
    const current = Game.coChoice[coModalTarget] || "ANDY";
    for(const coId of Object.keys(CO_DATA)){
      const co = CO_DATA[coId];
      const row = document.createElement("div");
      row.className = "coOption";

      const avatar = document.createElement("div");
      avatar.className = "coAvatar";
      setCOAvatar(avatar, co, coModalTarget || 1);

      const textBox = document.createElement("div");
      textBox.className = "coText";
      const name = document.createElement("div");
      name.className = "coName";
      name.textContent = co.name;
      const spec = document.createElement("div");
      spec.className = "coBuff";
      spec.innerHTML = `<div class="abilityLine"><span class="abilityBadge">Day-to-day</span><span class="abilityCopy">${co.specialty}</span></div>`;
      const power = document.createElement("div");
      power.className = "coBuff small";
      power.innerHTML = `<div class="abilityLine"><span class="abilityBadge">CO Power</span><span class="abilityCopy">${co.power}</span></div>`;
      const sup = document.createElement("div");
      sup.className = "coBuff small";
      sup.innerHTML = `<div class="abilityLine"><span class="abilityBadge">Super CO</span><span class="abilityCopy">${co.super}</span></div>`;

      textBox.appendChild(name);
      textBox.appendChild(spec);
      textBox.appendChild(power);
      textBox.appendChild(sup);

      const btn = document.createElement("button");
      btn.className = "btn tiny";
      btn.textContent = coId===current ? "Selected" : "Choose";
      if(coId===current) btn.classList.add("primary");
      btn.addEventListener("click", ()=>{
        if(coModalTarget){
          setCOChoice(coModalTarget, coId);
          closeCOModal();
        }
      });

      row.appendChild(avatar);
      row.appendChild(textBox);
      row.appendChild(btn);
      coList.appendChild(row);
    }
  }

  /***********************************************************************
   * CO meter & powers
   ***********************************************************************/
  const CO_POWER_COST = 60;
  const CO_SUPER_COST = 100;

  function grantCOMeter(playerId, amount){
    const cur = Game.coMeter[playerId] ?? 0;
    Game.coMeter[playerId] = clamp(cur + amount, 0, 100);
  }

  function clearCOState(playerId){
    Game.coState[playerId] = null;
  }

  function hasDoubleActions(playerId){
    return Game.coState[playerId] === "SUPER";
  }

  function updateRangePreview(){
    const sActive = sKeyHeld || sBtnHeld;
    const dActive = dKeyHeld || dBtnHeld;
    const mActive = mKeyHeld || mBtnHeld;
    if(rangeBtn) rangeBtn.classList.toggle("primary", sActive);
    if(dmgBtn) dmgBtn.classList.toggle("primary", dActive);
    if(moveBtn) moveBtn.classList.toggle("primary", mActive);
  }

  function grantExtraActions(playerId, minimum=2){
    for(const u of Game.units){
      if(u.owner===playerId){
        u.actionsLeft = Math.max(u.actionsLeft || 1, minimum);
        u.moved = false;
        u.acted = false;
      }
    }
  }

  function healPlayerUnits(playerId, amount){
    for(const u of Game.units){
      if(u.owner===playerId){
        u.hp = clamp(u.hp + amount, 0, u.def.maxHP);
      }
    }
  }

  function useCOPower(playerId, tier){
    const cost = tier==="SUPER" ? CO_SUPER_COST : CO_POWER_COST;
    if((Game.coMeter[playerId] ?? 0) < cost) return;
    if(Game.coState[playerId]) return; // already active
    Game.coMeter[playerId] -= cost;
    Game.coState[playerId] = tier;
    const co = getCOChoice(playerId);
    logLine(`${owningPlayer(playerId).name} activates ${co.name} ${tier==="SUPER" ? "Super CO Power" : "CO Power"}!`, playerId);
    if(co.id==="ANDY"){
      healPlayerUnits(playerId, tier==="SUPER" ? 5 : 2);
    }
    refreshPlayerUnits(playerId, tier==="SUPER" ? 2 : 1);
    renderCOSection();
    updateUI();
  }

  function showTurnOverlay({ playerId, day, income, co }){
    if(!turnOverlay || !turnOverlayBox) return;
    const pillClass = playerId===1 ? "coPill p1" : "coPill p2";
    turnOverlayPlayer.className = pillClass;
    turnOverlayPlayer.textContent = `Player ${playerId}`;
    turnOverlayDay.textContent = `Day ${day}`;
    turnOverlayIncome.textContent = `Income +$${income}`;

    if(turnOverlayTimer) clearTimeout(turnOverlayTimer);
    turnOverlay.classList.remove("show");
    void turnOverlay.offsetWidth;
    turnOverlay.style.display = "flex";
    requestAnimationFrame(()=>{ turnOverlay.classList.add("show"); });

    turnOverlayTimer = setTimeout(()=>{
      turnOverlay.classList.remove("show");
      setTimeout(()=>{ turnOverlay.style.display = "none"; }, 320);
    }, 500);
  }

  /***********************************************************************
   * Battle Overlay
   ***********************************************************************/
  function setHPBar(el, current, max){
    const pct = clamp(current / max, 0, 1);
    el.style.width = `${pct*100}%`;
    el.style.background = pct>0.66 ? "#74ff8a" : pct>0.33 ? "#ffd166" : "#ff5d7a";
  }

  /***********************************************************************
   * Map Picker
   ***********************************************************************/
  function renderMapPicker(){
    if(!mapList) return;
    initCustomGridFromText(Game.customMapText || DEFAULT_CUSTOM_MAP);
    mapList.innerHTML = "";
    renderCustomPalette();
    renderCustomGrid();
    for(const m of MAPS.filter(m=>m.id!=="CUSTOM")){
      const card = document.createElement("div");
      card.className = "mapCard";
      if(m.img){
        const img = document.createElement("img");
        img.src = m.img;
        img.alt = m.name;
        img.style.width = "100%";
        img.style.borderRadius = "10px";
        img.style.border = "1px solid #23346b";
        img.style.background = "#050814";
        img.style.objectFit = "cover";
        card.appendChild(img);
      }
      const name = document.createElement("div");
      name.className = "name";
      name.textContent = m.name;
      const meta = document.createElement("div");
      meta.className = "meta";
      meta.textContent = m.desc;
      const btn = document.createElement("button");
      btn.className = "btn primary";
      btn.textContent = "Play";
      btn.addEventListener("click", ()=>{
        Game.selectedMap = m.id;
        closeMapPicker();
        freshMatch();
      });
      card.appendChild(name);
      card.appendChild(meta);
      card.appendChild(btn);
      mapList.appendChild(card);
    }
  }

  function openMapPicker(){
    renderMapPicker();
    if(mapModal) mapModal.style.display = "flex";
  }

  function closeMapPicker(){
    if(mapModal) mapModal.style.display = "none";
  }

  function showBattleOverlay({ attacker, defender, atkBefore, atkAfter, defBefore, defAfter, attackerLabel, defenderLabel, attackerImg, defenderImg, atkMax, defMax, leftText="", rightText="" }){
    return new Promise(resolve=>{
      if(!battleOverlay) return resolve();
      // Force blue (P1) on left, red (P2) on right by swapping when needed
      let left = { img:attackerImg, label:attackerLabel, before:atkBefore, after:atkAfter, max:atkMax, dmg:leftText };
      let right = { img:defenderImg, label:defenderLabel, before:defBefore, after:defAfter, max:defMax, dmg:rightText };
      if(attacker && defender && attacker.owner===2 && defender.owner===1){
        left = { img:defenderImg, label:defenderLabel, before:defBefore, after:defAfter, max:defMax, dmg:rightText };
        right = { img:attackerImg, label:attackerLabel, before:atkBefore, after:atkAfter, max:atkMax, dmg:leftText };
      }

      battleOverlay.style.display = "flex";

      battleLeftImg.src = left.img || "";
      battleRightImg.src = right.img || "";
      battleLeftLabel.textContent = left.label;
      battleRightLabel.textContent = right.label;
      if(battleLeftDmg) battleLeftDmg.textContent = left.dmg;
      if(battleRightDmg) battleRightDmg.textContent = right.dmg;

      battleLeftImg.parentElement.classList.remove("hitLeft");
      battleRightImg.parentElement.classList.remove("hitRight");

      setHPBar(battleLeftHP, left.before, left.max || left.before || 1);
      setHPBar(battleRightHP, right.before, right.max || right.before || 1);

      void battleOverlay.offsetWidth; // reflow

      setTimeout(()=>{
        battleLeftImg.parentElement.classList.add("hitLeft");
        battleRightImg.parentElement.classList.add("hitRight");
        setHPBar(battleLeftHP, left.after, left.max || Math.max(left.before,1));
        setHPBar(battleRightHP, right.after, right.max || Math.max(right.before,1));
      }, 30);

      setTimeout(()=>{
        battleOverlay.style.display = "none";
        resolve();
      }, 1300);
    });
  }

  /***********************************************************************
   * Movement
   ***********************************************************************/
  const DIRS = [
    {dx:1,dy:0},{dx:-1,dy:0},{dx:0,dy:1},{dx:0,dy:-1}
  ];

  function isTileBlockedForMovement(x,y, movingUnit){
    const u = unitAt(x,y);
    if(!u) return false;
    return (u.uid !== movingUnit.uid);
  }

  function movementCost(unit, x, y){
    const t = terrainAt(x,y);
    const mtype = unit.def.movementType;
    const cost = t.moveCost[mtype] ?? 99;
    return cost;
  }

  function computeMoveOverlayIfApplicable(){
    Game.moveTiles = new Set();
    Game.moveMap = null;
    Game.atkTiles = new Set();
    Game.path = [];

    if(!Game.sel || Game.sel.type!=="unit") return;
    const u = Game.sel.unit;

    const start = {x:u.x,y:u.y};
    const maxMove = unitMovePoints(u);

    const dist = new Map();
    const prev = new Map();
    const open = [];

    const sk = key(start.x,start.y);
    dist.set(sk, 0);
    prev.set(sk, null);
    open.push({k:sk, cost:0});

    function pushOrUpdate(k,c){
      for(const it of open){
        if(it.k===k){
          if(c<it.cost){ it.cost=c; }
          return;
        }
      }
      open.push({k, cost:c});
    }

    while(open.length){
      open.sort((a,b)=>a.cost-b.cost);
      const cur = open.shift();
      if(!cur) break;
      const {x,y} = parseKey(cur.k);
      const curCost = cur.cost;

      if(dist.get(cur.k) !== curCost) continue;

      for(const d of DIRS){
        const nx=x+d.dx, ny=y+d.dy;
        if(!inBounds(nx,ny)) continue;

        const step = movementCost(u,nx,ny);
        if(step>=99) continue;
        if(isTileBlockedForMovement(nx,ny,u)) continue;

        const nc = curCost + step;
        if(nc > maxMove) continue;

        const nk = key(nx,ny);
        const old = dist.get(nk);
        if(old===undefined || nc < old){
          dist.set(nk,nc);
          prev.set(nk, cur.k);
          pushOrUpdate(nk,nc);
        }
      }
    }

    Game.moveMap = { dist, prev, startKey: sk };
    for(const k of dist.keys()){
      Game.moveTiles.add(k);
    }
  }

  function computeAttackOverlayIfApplicable(){
    Game.atkTiles = new Set();
    if(!Game.sel || Game.sel.type!=="unit") return;
    const u = Game.sel.unit;

    const canProjectAfterMove = !isIndirectUnit(u) && !NO_PROJECTION_ATTACK_UNITS.has(u.def.id);
    const useMoveProjection = (Game.moveTiles && Game.moveTiles.size && u.owner===Game.currentPlayer && !u.moved && canProjectAfterMove);
    const origins = [];

    if(useMoveProjection){
      for(const k of Game.moveTiles){
        origins.push(parseKey(k));
      }
    } else {
      origins.push({x:u.x, y:u.y});
    }

    for(const pos of origins){
      const tiles = computeAttackTilesFromPosition(u, pos);
      for(const k of tiles){
        Game.atkTiles.add(k);
      }
    }
  }

  function reconstructPath(toKey){
    if(!Game.moveMap) return [];
    const { prev, startKey } = Game.moveMap;

    const out = [];
    let cur = toKey;
    while(cur && cur!==startKey){
      out.push(cur);
      cur = prev.get(cur);
    }
    out.push(startKey);
    out.reverse();
    return out.map(parseKey);
  }

  /***********************************************************************
   * Attack Tiles
   ***********************************************************************/
  function computeAttackTilesFromPosition(unit, pos){
    const tiles = new Set();
    const { minR, maxR } = getRangeForUnit(unit);

    for(let y=0;y<GRID_H;y++){
      for(let x=0;x<GRID_W;x++){
        const d = Math.abs(x-pos.x)+Math.abs(y-pos.y);
        if(d>=minR && d<=maxR){
          tiles.add(key(x,y));
        }
      }
    }
    return tiles;
  }

  function enemyInRangeAt(unit, k){
    const {x,y} = parseKey(k);
    const target = unitAt(x,y);
    if(!target) return false;
    return target.owner !== unit.owner;
  }

  function isDirectUnit(u){ return !u.def.indirect; }
  function isIndirectUnit(u){ return !!u.def.indirect; }
  function isInfantry(u){ return u.def.id==="INF"; }

  const NO_PROJECTION_ATTACK_UNITS = new Set(["INF","RECON","TANK","MDT"]);

  function canMoveThisTurn(u){
    if(!u) return false;
    if(Game.gameOver) return false;
    if(u.owner !== Game.currentPlayer) return false;
    return !u.moved;
  }

  function canAttackThisTurn(u){
    if(!u) return false;
    if(Game.gameOver) return false;
    if(u.owner !== Game.currentPlayer) return false;
    if(u.acted) return false;
    if(isIndirectUnit(u) && u.moved) return false;
    return true;
  }

  function overlayVisibility(u){
    const sActive = (sKeyHeld || sBtnHeld) && u.moved && u.acted; // S only needed when fully spent
    const dActive = dKeyHeld || dBtnHeld;
    const mActive = mKeyHeld || mBtnHeld;
    let showMove = false;
    let showAtk = false;

    if((mActive && dActive) || sActive){
      showMove = true;
      showAtk = true;
    } else if(mActive){
      showMove = true;
    } else if(dActive){
      showAtk = true;
    } else {
      if(!u.moved && !u.acted){
        showMove = true;
        showAtk = true;
      } else if(u.moved && !u.acted){
        showAtk = true;
      } else if(!u.moved && u.acted){
        showMove = true;
      }
    }
    return { showMove, showAtk };
  }

  function unitMoveBonus(u){
    const co = getCOChoice(u.owner);
    const state = Game.coState[u.owner];
    let bonus = 0;
    if(co.id==="MAX" && isDirectUnit(u)){
      if(state==="SUPER") bonus += 2;
      else if(state==="POWER") bonus += 1;
    }
    if(co.id==="SAMI" && isInfantry(u)){
      if(state==="SUPER") bonus += 2;
      else if(state==="POWER") bonus += 1;
    }
    if(co.id==="ANDY" && state==="SUPER"){
      bonus += 1;
    }
    return bonus;
  }

  function unitMovePoints(u){
    return u.def.move + unitMoveBonus(u);
  }

  function getRangeForUnit(u){
    let minR = u.def.rangeMin;
    let maxR = u.def.rangeMax;
    const co = getCOChoice(u.owner);
    if(co.id==="MAX" && u.def.indirect){
      maxR = Math.max(minR, maxR-1);
    }
    return { minR, maxR };
  }

  function getDamageRangeEntry(attackerId, defenderId){
    const table = DAMAGE_TABLE[attackerId];
    if(!table) return null;
    return table[defenderId] || null;
  }

  function damageProfileText(attackerId){
    const order = ["INF","RECON","TANK","MDT","ART","RKT"];
    const table = DAMAGE_TABLE[attackerId];
    if(!table) return "Damage: —";
    const parts = [];
    for(const tid of order){
      const rng = table[tid];
      if(!rng) continue;
      const [a,b] = rng;
      const label = UNIT_DEF[tid]?.abbr || tid;
      parts.push(`${label} ${a}${a===b ? "" : `-${b}`}`);
    }
    return "Damage: " + parts.join(" • ");
  }

  // Show attack range text
  function formatRangeText(rangeMin, rangeMax){
    return `${rangeMin}-${rangeMax}`;
  }

  function formatStars(count){
    const stars = count>0 ? "⭐".repeat(count) : "—";
    return stars;
  }

  function damageRangeSimple(attackerId){
    const table = DAMAGE_TABLE[attackerId];
    if(!table) return {min:0, max:0};
    let min = Infinity, max = -Infinity;
    for(const rng of Object.values(table)){
      if(!rng) continue;
      min = Math.min(min, rng[0]);
      max = Math.max(max, rng[1]);
    }
    if(min===Infinity) return {min:0,max:0};
    return {min, max};
  }

  function damageDisplayText(attackerId){
    if(Game.dmgDetail){
      return damageProfileText(attackerId);
    }
    const {min,max} = damageRangeSimple(attackerId);
    return `Damage: ${min}-${max}`;
  }

  function attackMultiplier(attacker, defender){
    const co = getCOChoice(attacker.owner);
    const state = Game.coState[attacker.owner];
    const direct = isDirectUnit(attacker);
    let mult = 1;
    if(co.id==="MAX"){
      if(direct){
        if(state==="SUPER") mult = 1.6;
        else if(state==="POWER") mult = 1.4;
        else mult = 1.2;
      }
    }
    if(co.id==="SAMI" && isInfantry(attacker)){
      if(state==="SUPER") mult = 1.6;
      else if(state==="POWER") mult = 1.5;
      else mult = 1.2;
    }
    if(co.id==="ANDY" && state==="SUPER"){
      mult *= 1.2;
    }
    return mult;
  }

  function luckBonus(attacker){
    const co = getCOChoice(attacker.owner);
    const state = Game.coState[attacker.owner];
    if(co.id!=="NELL") return 0;
    if(state==="SUPER") return randInt(7); // 0-6
    if(state==="POWER") return randInt(5); // 0-4
    return randInt(3); // 0-2
  }

  /***********************************************************************
   * Combat
   ***********************************************************************/
  function terrainDefenseBonus(x,y){
    // Number of defense stars on the tile; converted to a flat % reduction elsewhere.
    const stars = tileDefenseStat(x,y);
    return stars;
  }

  function computeDamageRoll(attacker, defender){
    const stars = terrainDefenseBonus(defender.x, defender.y);
    // Terrain defense reduces damage, but keep it independent of current HP so
    // we apply the advertised ranges directly.
    const defScale = 1 - clamp(stars * 0.1, 0, 0.9);
    const mult = attackMultiplier(attacker, defender);

    const entry = getDamageRangeEntry(attacker.def.id, defender.def.id);
    if(entry){
      const [minBase, maxBase] = entry;

      const scaledMin = minBase * mult * defScale;
      const scaledMax = maxBase * mult * defScale;

      const min = clamp(Math.floor(scaledMin), 0, defender.def.maxHP);
      const max = clamp(Math.ceil(scaledMax), min, defender.def.maxHP);
      const roll = clamp(randBetween(min, max), min, defender.def.maxHP);
      return { roll, min, max };
    }

    // Fallback to legacy calculation if a matchup isn't defined.
    const atkBase = attacker.def.baseAtk[defender.def.id] ?? 4;
    let raw = atkBase * mult * defScale;

    const min = Math.max(0, Math.floor(raw * 0.85));
    const max = Math.max(min, Math.ceil(raw * 1.15));
    const roll = clamp(randBetween(min, max), min, defender.def.maxHP);
    return { roll, min, max };
  }

  function previewDamageRange(def){
    const table = DAMAGE_TABLE[def.id];
    if(table){
      let min = Infinity, max = -Infinity;
      for(const rng of Object.values(table)){
        if(!rng) continue;
        min = Math.min(min, rng[0]);
        max = Math.max(max, rng[1]);
      }
      if(min!==Infinity && max!==-Infinity){
        return { min, max };
      }
    }
    const vals = Object.values(def.baseAtk || {});
    const low = vals.length ? Math.min(...vals) : 4;
    const high = vals.length ? Math.max(...vals) : 4;
    const min = Math.max(0, Math.floor(low * 0.85));
    const max = Math.max(min, Math.ceil(high * 1.15));
    return { min, max };
  }

  function canRetaliate(defender, attacker){
    if(defender.def.indirect) return false;
    const d = manhattan({x:defender.x,y:defender.y},{x:attacker.x,y:attacker.y});
    const { minR, maxR } = getRangeForUnit(defender);
    return d>=minR && d<=maxR;
  }

  function damageLabel(roll, min, max, prefix=""){
    const span = (max - min) || 1;
    const hi = max - Math.max(1, Math.floor(span*0.2));
    const lo = min + Math.floor(span*0.2);
    let tag = "Decent!";
    if(roll >= hi) tag = "Lucky!";
    else if(roll <= lo) tag = "Glancing!";
    return `${prefix}${tag} ${roll} Damage Dealt`;
  }

  async function performAttack(attacker, defender){
    if(Game.gameOver) return;
    if(attacker.acted) return;
    if(isIndirectUnit(attacker) && attacker.moved) return;

    const defBefore = defender.hp;
    const atkBefore = attacker.hp;

    const { roll: dmgToDef, min: atkMin, max: atkMax } = computeDamageRoll(attacker, defender);
    const newDefHP = clamp(defender.hp - dmgToDef, 0, defender.def.maxHP);

    let dmgToAtk = 0, defMin=0, defMax=0;
    let newAtkHP = atkBefore;
    if(canRetaliate(defender, attacker) && newDefHP>0){
      const res = computeDamageRoll(defender, attacker);
      dmgToAtk = res.roll; defMin = res.min; defMax = res.max;
      newAtkHP = clamp(attacker.hp - dmgToAtk, 0, attacker.def.maxHP);
    }

    grantCOMeter(attacker.owner, 15);
    if(dmgToAtk>0) grantCOMeter(defender.owner, 10);

    const leftText = damageLabel(dmgToDef, atkMin, atkMax, "");
    const rightText = dmgToAtk>0 ? `Retaliated ${dmgToAtk} Damage` : "No Retaliation";

    await showBattleOverlay({
      attacker,
      defender,
      atkBefore,
      atkAfter: newAtkHP,
      defBefore,
      defAfter: newDefHP,
      attackerLabel: `${attacker.def.name}`,
      defenderLabel: `${defender.def.name}`,
      attackerImg: getUnitSpriteSrc(attacker),
      defenderImg: getUnitSpriteSrc(defender),
      atkMax: attacker.def.maxHP,
      defMax: defender.def.maxHP,
      leftText,
      rightText
    });

    defender.hp = newDefHP;
    logLine(`${owningPlayer(attacker.owner).name} ${attacker.def.name} hits ${defender.def.name} for ${dmgToDef} (roll ${atkMin}-${atkMax}).`, attacker.owner);

    if(defender.hp<=0){
      logLine(`${defender.def.name} destroyed.`, attacker.owner);
      removeUnit(defender);
      attacker.acted = true;
      return;
    }

    if(dmgToAtk>0){
      attacker.hp = newAtkHP;
      logLine(`${defender.def.name} retaliates for ${dmgToAtk} (roll ${defMin}-${defMax}).`, defender.owner);

      if(attacker.hp<=0){
        logLine(`${attacker.def.name} destroyed.`, defender.owner);
        removeUnit(attacker);
      } else {
        consumeAction(attacker);
      }
    } else {
      consumeAction(attacker);
    }

    renderCOSection();
  }

  /***********************************************************************
   * Capture Mechanics
   ***********************************************************************/
  async function tryCapture(unit){
    if(!unit.def.canCapture) return false;

    const b = buildingAt(unit.x, unit.y);
    if(!b) return false;

    if(b.owner === unit.owner && b.capturePoints===20) return false;

    const co = getCOChoice(unit.owner);
    const state = Game.coState[unit.owner];
    const before = b.capturePoints;
    let capturePower = unit.hp;
    if(co.id==="SAMI"){
      if(state==="SUPER"){
        capturePower = 99; // one-turn capture
      } else if(state==="POWER"){
        capturePower = unit.hp * 2;
      } else {
        capturePower = Math.floor(unit.hp * 1.5);
      }
    }
    const after = clamp(b.capturePoints - capturePower, 0, 20);

    const captureDelta = before - after;
    const capOverlay = {
      attacker: unit,
      defender: b,
      atkBefore: unit.hp,
      atkAfter: unit.hp,
      defBefore: before,
      defAfter: after,
      attackerLabel: `${unit.def.name}`,
      defenderLabel: `${b.def.name}`,
      attackerImg: getUnitSpriteSrc(unit),
      defenderImg: (getBuildingSprite(b.kindId, b.owner ?? 0)||{}).src || "",
      atkMax: unit.def.maxHP,
      defMax: 20,
      leftText: `Capture -${captureDelta} Points`,
      rightText: "No Retaliation"
    };

    // Ensure blue on left, red on right for capture overlay too.
    if(unit.owner===2){
      const swapped = {
        attacker: b,
        defender: unit,
        atkBefore: before,
        atkAfter: after,
        defBefore: unit.hp,
        defAfter: unit.hp,
        attackerLabel: `${b.def.name}`,
        defenderLabel: `${unit.def.name}`,
        attackerImg: capOverlay.defenderImg,
        defenderImg: capOverlay.attackerImg,
        atkMax: 20,
        defMax: unit.def.maxHP,
        leftText: capOverlay.leftText,
        rightText: capOverlay.rightText
      };
      await showBattleOverlay(swapped);
    } else {
      await showBattleOverlay(capOverlay);
    }

    grantCOMeter(unit.owner, 20);
    consumeAction(unit);

    b.capturePoints = after;
    logLine(`${owningPlayer(unit.owner).name} captures ${b.def.name}: ${b.capturePoints}/20 remaining.`, unit.owner);

    if(b.capturePoints<=0){
      b.owner = unit.owner;
      b.capturePoints = 20;
      logLine(`${b.def.name} captured by ${owningPlayer(unit.owner).name}.`, unit.owner);

      if(b.kindId==="HQ"){
        Game.gameOver = true;
        logLine(`${owningPlayer(unit.owner).name} wins by capturing the HQ.`, unit.owner);
      }
    }

    unit.acted = true;
    return true;
  }

  /***********************************************************************
   * Building / Shop
   ***********************************************************************/
  // UPDATED: include new units; keep existing list concept
  const SHOP_UNITS = ["INF","RECON","TANK","MDT","ART","RKT"];

  function canBuildFromBuilding(b, playerId){
    if(!b || b.owner!==playerId) return false;
    if(b.kindId==="BASE") return true;
    const co = getCOChoice(playerId);
    const state = Game.coState[playerId];
    if(co.id==="HACHI" && state==="SUPER" && b.kindId==="CITY") return true;
    return false;
  }

  function getUnitCost(def, playerId){
    const co = getCOChoice(playerId);
    const state = Game.coState[playerId];
    let cost = def.cost;
    if(co.id==="HACHI"){
      if(state==="POWER" || state==="SUPER") cost = Math.floor(cost * 0.5);
      else cost = Math.floor(cost * 0.9);
    }
    return cost;
  }

  function openShopIfOnOwnedBase(){
    if(Game.gameOver) return;
    if(!Game.sel || Game.sel.type!=="building") return;
    const b = Game.sel.building;
    if(!canBuildFromBuilding(b, Game.currentPlayer)) return;

    Game.phase = "SHOP";
    shopBox.style.display = "block";
    renderShop();
    updateHelpPosition();
  }

  function closeShop(){
    if(Game.phase==="SHOP"){
      Game.phase = "IDLE";
    }
    shopBox.style.display = "block";
    renderShop();
    updateHelpPosition();
  }

  function renderShop(){
    shopList.innerHTML = "";
    const funds = Game.funds[Game.currentPlayer];
    const validSel = Game.sel && Game.sel.type==="building" && canBuildFromBuilding(Game.sel.building, Game.currentPlayer);
    const baseX = validSel ? Game.sel.x : -1;
    const baseY = validSel ? Game.sel.y : -1;

    if(!validSel){
      shopHint.textContent = "Select your owned Base to build." + (getCOChoice(Game.currentPlayer).id==="HACHI" && Game.coState[Game.currentPlayer]==="SUPER" ? " (Cities allowed with Hachi Super)" : "");
    } else if(unitAt(baseX, baseY)){
      shopHint.textContent = "Base is occupied; move the unit off to build.";
    } else {
      shopHint.textContent = "Build units on your base" + (Game.sel.building.kindId==="CITY" ? " (Hachi Super)" : "") + " (tile must be empty).";
    }

    for(const id of SHOP_UNITS){
      const def = UNIT_DEF[id];
      const price = getUnitCost(def, Game.currentPlayer);
      const canAfford = funds >= price;
      const occupied = validSel && unitAt(baseX, baseY) !== null;

      const div = document.createElement("div");
      div.className = "shopItem";

      const left = document.createElement("div");
      left.style.display = "grid";
      left.style.gridTemplateColumns = "64px 1fr";
      left.style.gap = "10px";
      const sprite = makeSpriteNode(id, Game.currentPlayer, 64);
      left.appendChild(sprite);

      const info = document.createElement("div");
      const role = def.indirect ? "Indirect fire" : "Direct fire";
      const rangeLabel = formatRangeText(def.rangeMin, def.rangeMax);
      info.innerHTML = `<div class="name">${def.name} <span class="abbr">${def.abbr}</span></div>`;
      const statRow = document.createElement("div");
      statRow.className = "shopStats";
      statRow.style.marginTop = "8px";
      const dmgPill = document.createElement("span");
      dmgPill.className = "pill warn";
      dmgPill.style.cursor = "pointer";
      const setDmgText = ()=>{ dmgPill.textContent = damageDisplayText(def.id); };
      setDmgText();
      dmgPill.title = "Click to toggle detailed damage view";
      dmgPill.addEventListener("click", ()=>{
        Game.dmgDetail = !Game.dmgDetail;
        renderShop();
      });
      statRow.appendChild(dmgPill);

      const capPill = document.createElement("span");
      capPill.className = "pill " + (def.canCapture ? "good" : "");
      capPill.textContent = def.canCapture ? "Can capture" : "No capture";
      statRow.appendChild(capPill);

      const blurb = UNIT_BLURB[def.id];
      if(blurb){
        const desc = document.createElement("div");
        desc.className = "meta";
        desc.textContent = blurb;
        desc.style.marginBottom = "6px";
        info.appendChild(desc);
      }

      const moveRow = document.createElement("div");
      moveRow.className = "shopStats";
      moveRow.style.marginTop = "6px";
      const movePill = document.createElement("span");
      movePill.className = "pill good";
      movePill.textContent = `Move ${def.move} (${def.movementType})`;
      const rangePill = document.createElement("span");
      rangePill.className = "pill";
      rangePill.style.background = "#152252";
      rangePill.textContent = `Range ${rangeLabel}`;
      const rolePill = document.createElement("span");
      rolePill.className = "pill warn";
      rolePill.textContent = role;
      moveRow.appendChild(movePill);
      moveRow.appendChild(rangePill);
      moveRow.appendChild(rolePill);

      info.appendChild(statRow);
      info.appendChild(moveRow);
      left.appendChild(info);
      div.appendChild(left);

      const right = document.createElement("div");
      right.style.display = "flex";
      right.style.flexDirection = "column";
      right.style.alignItems = "flex-end";
      right.style.gap = "6px";
      const pill = document.createElement("span");
      pill.className = "pill " + (canAfford ? "good" : "bad");
      pill.textContent = canAfford ? "Affordable" : "Too expensive";
      right.appendChild(pill);

      const btn = document.createElement("button");
      btn.className = "btn good";
      btn.style.marginLeft = "0";
      btn.textContent = `$${price}`;
      btn.disabled = (!canAfford) || occupied || !validSel;

      btn.addEventListener("click", ()=>{
        buildUnitAtBase(id, baseX, baseY);
      });

      right.appendChild(btn);
      div.appendChild(right);

      shopList.appendChild(div);
    }
  }

  function buildUnitAtBase(typeId, x, y){
    if(Game.gameOver) return;

    const b = buildingAt(x,y);
    if(!b || !canBuildFromBuilding(b, Game.currentPlayer)) return;

    if(unitAt(x,y)){
      logLine("Cannot build: base tile occupied.", Game.currentPlayer);
      return;
    }

    const def = UNIT_DEF[typeId];
    const price = getUnitCost(def, Game.currentPlayer);
    if(Game.funds[Game.currentPlayer] < price){
      logLine("Cannot build: insufficient funds.", Game.currentPlayer);
      return;
    }

    Game.funds[Game.currentPlayer] -= price;
    const u = makeUnit(typeId, Game.currentPlayer, x, y);
    u.moved = true;
    u.acted = true;

    Game.units.push(u);
      logLine(`${owningPlayer(Game.currentPlayer).name} builds ${def.name} for $${price}.`, Game.currentPlayer);

    updateUI();
    renderShop();
  }

  /***********************************************************************
   * NEW: Key/Legend
   ***********************************************************************/
  function openKey(){
    keyBox.style.display = "block";
    renderLegend();
    updateHelpPosition();
  }
  function closeKey(){
    keyBox.style.display = "none";
    updateHelpPosition();
  }
  function toggleKey(){
    if(keyBox.style.display === "block") closeKey();
    else openKey();
  }

  function renderLegend(){
    terrainLegend.innerHTML = "";
    unitLegend.innerHTML = "";

    const terrainItems = [TERRAIN.PLAINS, TERRAIN.ROAD, TERRAIN.FOREST, TERRAIN.MOUNTAIN, TERRAIN.WATER];
    for(const t of terrainItems){
      const row = document.createElement("div");
      row.className = "legendRow";

      const left = document.createElement("div");
      left.style.display = "flex";
      left.style.alignItems = "center";
      left.style.gap = "10px";

      const sw = document.createElement("span");
      sw.className = "swatch";
      const img = getTerrainSprite(t.id);
      if(img){
        sw.style.backgroundImage = `url(${img.src})`;
        sw.style.backgroundSize = "cover";
      } else {
        sw.style.background = t.color;
      }

      const label = document.createElement("div");
      label.innerHTML = `<div style="font-weight:800">${t.name}</div><div class="muted" style="font-size:12px">Move: foot ${t.moveCost.foot}, tread ${t.moveCost.tread}, tires ${t.moveCost.tires ?? "—"}</div>`;

      left.appendChild(sw);
      left.appendChild(label);

      const right = document.createElement("div");
      const stars = defenseStarsForTerrainId(t.id);
      right.innerHTML = `<span class="pill">Cover: ${formatStars(stars)}</span>`;

      row.appendChild(left);
      row.appendChild(right);

      terrainLegend.appendChild(row);
    }

    for(const id of Object.keys(UNIT_DEF)){
      const u = UNIT_DEF[id];
      const row = document.createElement("div");
      row.className = "legendRow";

      const left = document.createElement("div");
      const rangeLabel = formatRangeText(u.rangeMin, u.rangeMax);
      const blurb = UNIT_BLURB[u.id];
      left.innerHTML = `<div style="font-weight:800">${u.name} <span class="abbr">${u.abbr}</span></div>
                        <div class="muted" style="font-size:12px">Cost ${u.cost} • Move ${u.move} • Range ${rangeLabel}${u.indirect ? " (Indirect)" : ""}</div>
                        ${blurb ? `<div class="muted" style="font-size:12px">${blurb}</div>` : ""}`;
      const right = document.createElement("div");
      right.innerHTML = `<span class="pill ${u.canCapture ? "good" : ""}">${u.canCapture ? "Can capture" : "No capture"}</span>`;

      row.appendChild(left);
      row.appendChild(right);
      unitLegend.appendChild(row);
    }
  }

  /***********************************************************************
   * Input Handling
   ***********************************************************************/
  function canvasToGrid(mx,my){
    const rect = canvas.getBoundingClientRect();
    const x = Math.floor((mx - rect.left) * (canvas.width / rect.width) / TILE);
    const y = Math.floor((my - rect.top) * (canvas.height / rect.height) / TILE);
    return {x,y};
  }

  async function onLeftClickGrid(x,y){
    if(Game.gameOver) return;

    if(Game.phase==="SHOP"){
      if(!(Game.sel && Game.sel.type==="building" && Game.sel.x===x && Game.sel.y===y)){
        closeShop();
      }
    }

    const u = unitAt(x,y);
    const b = buildingAt(x,y);

    if(Game.sel && Game.sel.type==="unit"){
      const su = Game.sel.unit;

      if(su.owner === Game.currentPlayer){
        const clickedKey = key(x,y);
        if(!su.moved && Game.moveTiles.has(clickedKey) && !(x===su.x && y===su.y)){
          const occ = unitAt(x,y);
          if(occ && occ.uid!==su.uid) return;

          const destK = key(x,y);
          const path = reconstructPath(destK);

          su.x = x; su.y = y;
          su.animMove = { path, start: performance.now(), step: 200 };
          su.moved = true;

          logLine(`${owningPlayer(su.owner).name} moves ${su.def.name}.`, su.owner);

          Game.atkTiles = computeAttackTilesFromPosition(su, {x,y});
          Game.phase = canAttackThisTurn(su) ? "ATTACKING" : "IDLE";
          computeAttackOverlayIfApplicable();
          updateSelectionPanel();
          updateUI();
          return;
        }

        if(!su.acted){
          if(canAttackThisTurn(su) && Game.atkTiles.has(clickedKey) && enemyInRangeAt(su,clickedKey)){
            const target = unitAt(x,y);
            if(target){
              await performAttack(su, target);

              if(!Game.units.some(z=>z.uid===su.uid)){
                clearSelection();
              } else {
                updateSelectionPanel();
              }
              computeAttackOverlayIfApplicable();
              updateUI();
              return;
            }
          }

          if(x===su.x && y===su.y){
            const did = await tryCapture(su);
            if(did){
              computeAttackOverlayIfApplicable();
              updateSelectionPanel();
              updateUI();
              return;
            }
          }
        }
      }
    }

    // selection order: unit -> building -> tile
    if(u){
      selectUnit(u);
      return;
    }
    if(b){
      selectBuilding(b, x, y);
      return;
    }

    // NEW: select empty tile instead of clearing (so defense stat shows)
    selectTile(x,y);
    updateUI();
  }

  function onRightClick(e){
    e.preventDefault();
    closeShop();
    closeKey();
    clearSelection();
    updateUI();
  }

  canvas.addEventListener("mousemove", (e)=>{
    const g = canvasToGrid(e.clientX, e.clientY);
    Game.hovered = g;

    if(Game.sel && Game.sel.type==="unit" && Game.moveTiles.size && Game.moveTiles.has(key(g.x,g.y))){
      Game.path = reconstructPath(key(g.x,g.y));
    } else {
      Game.path = [];
    }
  });

  canvas.addEventListener("mousedown", async (e)=>{
    if(e.button===2) return;
    const g = canvasToGrid(e.clientX, e.clientY);
    if(!inBounds(g.x,g.y)) return;
    await onLeftClickGrid(g.x,g.y);
  });

  canvas.addEventListener("contextmenu", onRightClick);

  window.addEventListener("keydown", (e)=>{
    if(e.key==="s" || e.key==="S"){
      sKeyHeld = true;
      updateRangePreview();
    } else if(e.key==="d" || e.key==="D"){
      dKeyHeld = true;
      updateRangePreview();
    } else if(e.key==="m" || e.key==="M"){
      mKeyHeld = true;
      updateRangePreview();
    }
    if(e.key==="e" || e.key==="E"){
      endTurn();
    } else if(e.key==="b" || e.key==="B"){
      const choice = pickNextBase(Game.currentPlayer);
      if(choice){
        selectBuilding(choice.b, choice.x, choice.y);
        openShopIfOnOwnedBase();
      } else {
        logLine("No owned Base available to open shop.", Game.currentPlayer);
      }
    } else if(e.key==="k" || e.key==="K"){
      toggleKey();
    } else if(e.key==="Escape"){
      closeCOModal();
      closeShop();
      closeKey();
      clearSelection();
      updateUI();
      updateHelpPosition();
    }
  });
  window.addEventListener("keyup", (e)=>{
    if(e.key==="s" || e.key==="S"){
      sKeyHeld = false;
      updateRangePreview();
    } else if(e.key==="d" || e.key==="D"){
      dKeyHeld = false;
      updateRangePreview();
    } else if(e.key==="m" || e.key==="M"){
      mKeyHeld = false;
      updateRangePreview();
    }
  });
  window.addEventListener("blur", ()=>{
    sKeyHeld = false;
    sBtnHeld = false;
    dKeyHeld = false;
    dBtnHeld = false;
    mKeyHeld = false;
    mBtnHeld = false;
    updateRangePreview();
  });

  /***********************************************************************
   * UI Buttons
   ***********************************************************************/
  endTurnBtn.addEventListener("click", endTurn);
  newBtn.addEventListener("click", openMapPicker);
  resetBtn.addEventListener("click", hardReset);
  openShopBtn.addEventListener("click", ()=>{ autoOpenShopForCurrentPlayer(); });
  unselectBtn.addEventListener("click", ()=>{
    closeShop();
    closeKey();
    clearSelection();
    updateUI();
    updateHelpPosition();
  });
  closeShopBtn.addEventListener("click", ()=>{ closeShop(); updateUI(); });
  keyBtn.addEventListener("click", ()=>{ toggleKey(); });
  if(rangeBtn){
    rangeBtn.addEventListener("mousedown", ()=>{ sBtnHeld = true; updateRangePreview(); });
    rangeBtn.addEventListener("mouseup", ()=>{ sBtnHeld = false; updateRangePreview(); });
    rangeBtn.addEventListener("mouseleave", ()=>{ sBtnHeld = false; updateRangePreview(); });
    rangeBtn.addEventListener("touchstart", (e)=>{ e.preventDefault(); sBtnHeld = true; updateRangePreview(); });
    rangeBtn.addEventListener("touchend", ()=>{ sBtnHeld = false; updateRangePreview(); });
  }
  if(dmgBtn){
    dmgBtn.addEventListener("mousedown", ()=>{ dBtnHeld = true; updateRangePreview(); });
    dmgBtn.addEventListener("mouseup", ()=>{ dBtnHeld = false; updateRangePreview(); });
    dmgBtn.addEventListener("mouseleave", ()=>{ dBtnHeld = false; updateRangePreview(); });
    dmgBtn.addEventListener("touchstart", (e)=>{ e.preventDefault(); dBtnHeld = true; updateRangePreview(); });
    dmgBtn.addEventListener("touchend", ()=>{ dBtnHeld = false; updateRangePreview(); });
  }
  if(moveBtn){
    moveBtn.addEventListener("mousedown", ()=>{ mBtnHeld = true; updateRangePreview(); });
    moveBtn.addEventListener("mouseup", ()=>{ mBtnHeld = false; updateRangePreview(); });
    moveBtn.addEventListener("mouseleave", ()=>{ mBtnHeld = false; updateRangePreview(); });
    moveBtn.addEventListener("touchstart", (e)=>{ e.preventDefault(); mBtnHeld = true; updateRangePreview(); });
    moveBtn.addEventListener("touchend", ()=>{ mBtnHeld = false; updateRangePreview(); });
  }
  closeKeyBtn.addEventListener("click", ()=>{ closeKey(); });
  if(p1ChooseCO) p1ChooseCO.addEventListener("click", ()=>openCOModal(1));
  if(p2ChooseCO) p2ChooseCO.addEventListener("click", ()=>openCOModal(2));
  if(p1COCard) p1COCard.addEventListener("click", ()=>openCOModal(1));
  if(p2COCard) p2COCard.addEventListener("click", ()=>openCOModal(2));
  if(p1NameLabel) p1NameLabel.addEventListener("click", ()=>{
    const val = prompt("Rename Player 1", owningPlayer(1).name);
    if(val!==null) setPlayerName(1, val);
  });
  if(p2NameLabel) p2NameLabel.addEventListener("click", ()=>{
    const val = prompt("Rename Player 2", owningPlayer(2).name);
    if(val!==null) setPlayerName(2, val);
  });
  if(closeMapModal) closeMapModal.addEventListener("click", closeMapPicker);
  if(applyCustomMapBtn) applyCustomMapBtn.addEventListener("click", ()=>{
    Game.selectedMap = "CUSTOM";
    Game.customMapText = gridToTextWithUnits(customGrid, customUnits);
    closeMapPicker();
    freshMatch();
  });
  if(fillPlainsBtn) fillPlainsBtn.addEventListener("click", ()=>{
    customGrid = Array.from({length:GRID_H}, ()=>Array.from({length:GRID_W}, ()=>"."));
    customUnits = Array.from({length:GRID_H}, ()=>Array.from({length:GRID_W}, ()=>"."));
    renderCustomGrid();
  });
  if(resetCustomBtn) resetCustomBtn.addEventListener("click", ()=>{
    initCustomGridFromText(DEFAULT_CUSTOM_MAP);
    renderCustomGrid();
  });
  if(p1TopAvatar){
    p1TopAvatar.addEventListener("click", ()=>openCOModal(1));
    p1TopAvatar.addEventListener("mouseenter", ()=>showTooltip(p1TopTooltip, p1TopAvatar));
    p1TopAvatar.addEventListener("mouseleave", ()=>hideTooltip(p1TopTooltip));
  }
  if(p2TopAvatar){
    p2TopAvatar.addEventListener("click", ()=>openCOModal(2));
    p2TopAvatar.addEventListener("mouseenter", ()=>showTooltip(p2TopTooltip, p2TopAvatar));
    p2TopAvatar.addEventListener("mouseleave", ()=>hideTooltip(p2TopTooltip));
  }
  if(p1PowerBtn) p1PowerBtn.addEventListener("click", ()=>useCOPower(1,"POWER"));
  if(p2PowerBtn) p2PowerBtn.addEventListener("click", ()=>useCOPower(2,"POWER"));
  if(p1SuperBtn) p1SuperBtn.addEventListener("click", ()=>useCOPower(1,"SUPER"));
  if(p2SuperBtn) p2SuperBtn.addEventListener("click", ()=>useCOPower(2,"SUPER"));
  if(p1TopPower) p1TopPower.addEventListener("click", ()=>useCOPower(1,"POWER"));
  if(p2TopPower) p2TopPower.addEventListener("click", ()=>useCOPower(2,"POWER"));
  if(p1TopSuper) p1TopSuper.addEventListener("click", ()=>useCOPower(1,"SUPER"));
  if(p2TopSuper) p2TopSuper.addEventListener("click", ()=>useCOPower(2,"SUPER"));
  if(closeCoModal) closeCoModal.addEventListener("click", closeCOModal);
  if(coModal) coModal.addEventListener("click", (e)=>{ if(e.target===coModal) closeCOModal(); });

  /***********************************************************************
   * UI Updates
   ***********************************************************************/
  function updateUI(){
    const cp = owningPlayer(Game.currentPlayer);
    const income1 = countOwnedIncome(1);
    const income2 = countOwnedIncome(2);
    const co1 = getCOChoice(1);
    const co2 = getCOChoice(2);

    if(p1TopIncome) p1TopIncome.textContent = `Income $${income1}`;
    if(p2TopIncome) p2TopIncome.textContent = `Income $${income2}`;
    elP1Funds.textContent = `Funds $${Game.funds[1]}`;
    elP2Funds.textContent = `Funds $${Game.funds[2]}`;
    if(p1TopCOName) p1TopCOName.textContent = co1.name;
    if(p2TopCOName) p2TopCOName.textContent = co2.name;
    setCOAvatar(p1TopAvatar, co1, 1);
    setCOAvatar(p2TopAvatar, co2, 2);

    if(p1Card){
      const active = Game.currentPlayer===1;
      p1Card.classList.toggle("active", active);
      p1Card.style.borderColor = active ? COLORS.p1 : "#23346b";
      p1Card.style.boxShadow = active ? "0 0 0 1px rgba(99,186,255,0.4)" : "none";
    }
    if(p2Card){
      const active = Game.currentPlayer===2;
      p2Card.classList.toggle("active", active);
      p2Card.style.borderColor = active ? COLORS.p2 : "#23346b";
      p2Card.style.boxShadow = active ? "0 0 0 1px rgba(255,95,140,0.4)" : "none";
    }
    renderCOSection();

    if(Game.sel && Game.sel.type==="unit"){
      const u = Game.sel.unit;
      computeMoveOverlayIfApplicable();
      computeAttackOverlayIfApplicable();
      Game.phase = canAttackThisTurn(u) ? "ATTACKING" : "IDLE";
    } else {
      Game.moveTiles = new Set();
      Game.atkTiles = new Set();
      Game.path = [];
    }

    endTurnBtn.disabled = Game.gameOver;

    if(Game.sel) updateSelectionPanel();

    renderShop();
  }

  /***********************************************************************
   * Rendering
   ***********************************************************************/
  function getUnitRenderPos(u, now){
    if(u && u.animMove && Array.isArray(u.animMove.path)){
      const { path, start, step } = u.animMove;
      const steps = path.length-1;
      if(steps>0){
        const elapsed = now - start;
        const seg = Math.floor(elapsed / step);
        if(seg >= steps){
          u.animMove = null;
          return { x:u.x, y:u.y };
        }
        const t = (elapsed % step) / step;
        const a = path[seg];
        const b = path[seg+1];
        if(a && b){
          return { x: a.x + (b.x - a.x)*t, y: a.y + (b.y - a.y)*t };
        } else {
          u.animMove = null;
        }
      } else {
        u.animMove = null;
      }
    }
    return { x:u.x, y:u.y };
  }

  function draw(ts){
    const now = ts || performance.now();
    ctx.clearRect(0,0,canvas.width,canvas.height);

    ctx.fillStyle = COLORS.bg;
    ctx.fillRect(0,0,canvas.width,canvas.height);

    drawTerrain();
    drawBuildings();
    drawOverlays();
    drawUnits(now);
    drawGrid();
    drawTopHUD();

    requestAnimationFrame(draw);
  }

  // NEW: clearer terrain rendering (road/water/grass distinct, deterministic patterns)
  function drawTerrain(){
    for(let y=0;y<GRID_H;y++){
      for(let x=0;x<GRID_W;x++){
        const t = Game.terrain[y][x];
        const px = x*TILE, py = y*TILE;
        const img = getTerrainSprite(t.id);
        if(img && img.complete){
          ctx.drawImage(img, px, py, TILE, TILE);
        } else {
          ctx.fillStyle = t.color;
          ctx.fillRect(px, py, TILE, TILE);
        }
      }
    }
  }

  function drawBuildings(){
    for(let y=0;y<GRID_H;y++){
      for(let x=0;x<GRID_W;x++){
        const b = Game.buildings[y][x];
        if(!b) continue;

        const owner = b.owner ?? 0;
        const baseX = x*TILE, baseY = y*TILE;
        const img = getBuildingSprite(b.kindId, owner);
        const margin = TILE*0.05;
        if(img && img.complete){
          ctx.drawImage(img, baseX+margin, baseY+margin, TILE-2*margin, TILE-2*margin);
        } else {
          // fallback simple plate
          ctx.fillStyle = "#0a0f26";
          ctx.fillRect(baseX+6, baseY+6, TILE-12, TILE-12);
          ctx.strokeStyle = "#23346b";
          ctx.strokeRect(baseX+6, baseY+6, TILE-12, TILE-12);
        }

        // capture indicator (above tile to avoid overlap)
        if(b.owner===null || b.capturePoints<20){
          const pct = b.capturePoints / 20;
          const barW = TILE-16;
          const barH = 6;
          const barX = baseX+8;
          const barY = Math.max(0, baseY-8);
          ctx.fillStyle = "#0b1433";
          ctx.fillRect(barX, barY, barW, barH);
          ctx.fillStyle = owner ? owningPlayer(owner).color : "#ffd166";
          ctx.fillRect(barX, barY, Math.floor(barW*pct), barH);
          ctx.strokeStyle = "#23346b";
          ctx.strokeRect(barX, barY, barW, barH);
        }
      }
    }
  }

  // NEW: clearer unit labels (abbr) and slightly improved silhouettes
  function drawUnits(now){
    for(const u of Game.units){
      const rp = getUnitRenderPos(u, now);
      const px = rp.x*TILE, py = rp.y*TILE;
      const p = owningPlayer(u.owner);
      const margin = TILE * 0.05; // 0.9x size to reveal tile edges
      const ux = px + margin;
      const uy = py + margin;
      const size = TILE - margin*2;

      // shadow
      ctx.globalAlpha = 0.35;
      ctx.fillStyle = "#000000";
      ctx.beginPath();
      ctx.ellipse(px+TILE/2, py+TILE/2+10, size*0.45, size*0.22, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = 1;

      // sprite draw (fallback to shapes if missing)
      const spriteList = getSpriteList(u.typeId, u.owner);
      const img = spriteList.length ? spriteList[u.spriteIdx % spriteList.length] : null;
      if(img && img.complete){
        ctx.drawImage(img, ux, uy, size, size);
      } else {
        ctx.fillStyle = p.dark;
        ctx.fillRect(ux, uy+4, size, size-10);
        ctx.fillStyle = p.color;
        ctx.fillRect(ux+2, uy+6, size-4, size-14);
      }

      // HP badge
      const hpPct = u.hp / u.def.maxHP;
      const overlayTop = Math.max(0, py-24);
      const centerX = px + TILE/2;

      // Name tag (smaller, stacked)
      const labelW = 46, labelH = 12;
      const labelX = centerX - labelW/2;
      const labelY = overlayTop;
      ctx.fillStyle = "#0a0f26";
      ctx.globalAlpha = 0.65;
      ctx.fillRect(labelX, labelY, labelW, labelH);
      ctx.globalAlpha = 1;
      ctx.strokeStyle = "#23346b";
      ctx.strokeRect(labelX, labelY, labelW, labelH);
      ctx.fillStyle = "#e8eeff";
      ctx.font = "bold 9px system-ui";
      ctx.fillText(`${u.def.abbr} - ${u.hp}`, labelX+4, labelY+9);

      // HP bar (stacked under name, smaller)
      const barW = 34, barH = 10;
      const badgeX = centerX - barW/2;
      const badgeY = labelY + labelH + 2;
      const badgeFillW = Math.max(0, Math.round((barW-2)*hpPct));
      ctx.fillStyle = "#0b1433";
      ctx.fillRect(badgeX, badgeY, barW, barH);
      ctx.fillStyle = hpPct>0.66 ? "#74ff8a" : hpPct>0.33 ? "#ffd166" : "#ff5d7a";
      ctx.fillRect(badgeX+1, badgeY+1, badgeFillW, barH-2);
      ctx.strokeStyle = "#23346b";
      ctx.strokeRect(badgeX, badgeY, barW, barH);

      // exhausted overlay
      if(u.owner===Game.currentPlayer && (u.moved || u.acted)){
        ctx.globalAlpha = 0.22;
        ctx.fillStyle = "#000000";
        ctx.fillRect(px,py,TILE,TILE);
        ctx.globalAlpha = 1;
      }
    }
  }

  function drawGrid(){
    ctx.strokeStyle = COLORS.grid;
    ctx.lineWidth = 1;
    for(let x=0;x<=GRID_W;x++){
      ctx.beginPath();
      ctx.moveTo(x*TILE, 0);
      ctx.lineTo(x*TILE, CANVAS_H);
      ctx.stroke();
    }
    for(let y=0;y<=GRID_H;y++){
      ctx.beginPath();
      ctx.moveTo(0, y*TILE);
      ctx.lineTo(CANVAS_W, y*TILE);
      ctx.stroke();
    }
  }

  function drawTopHUD(){
    if(Game.gameOver){
      ctx.fillStyle = "#0b1433";
      ctx.fillRect(CANVAS_W/2-220, CANVAS_H/2-40, 440, 80);
      ctx.strokeStyle = "#23346b";
      ctx.strokeRect(CANVAS_W/2-220, CANVAS_H/2-40, 440, 80);
      ctx.fillStyle = "#e8eeff";
      ctx.font = "bold 18px system-ui";
      ctx.fillText("GAME OVER", CANVAS_W/2-70, CANVAS_H/2-10);
      ctx.font = "14px system-ui";
      ctx.fillText("Press New Game to play again.", CANVAS_W/2-110, CANVAS_H/2+18);
    }
  }

  function drawOverlays(){
    const selUnit = Game.sel && Game.sel.type==="unit" ? Game.sel.unit : null;
    const { showMove, showAtk } = selUnit ? overlayVisibility(selUnit) : { showMove:false, showAtk:false };

    if(showMove && Game.moveTiles && Game.moveTiles.size){
      for(const k of Game.moveTiles){
        if(showAtk && Game.atkTiles && Game.atkTiles.has(k)) continue; // let red tiles dominate
        const {x,y} = parseKey(k);
        const px=x*TILE, py=y*TILE;
        ctx.fillStyle = COLORS.move;
        ctx.fillRect(px,py,TILE,TILE);
        ctx.strokeStyle = COLORS.moveEdge;
        ctx.strokeRect(px+1,py+1,TILE-2,TILE-2);
      }
    }

    if(showMove && Game.path && Game.path.length>1){
      ctx.strokeStyle = COLORS.selectEdge;
      ctx.lineWidth = 4;
      ctx.beginPath();
      for(let i=0;i<Game.path.length;i++){
        const p = Game.path[i];
        const cx = p.x*TILE + TILE/2;
        const cy = p.y*TILE + TILE/2;
        if(i===0) ctx.moveTo(cx,cy);
        else ctx.lineTo(cx,cy);
      }
      ctx.stroke();
      ctx.lineWidth = 1;
    }

    if(showAtk && Game.sel && Game.sel.type==="unit"){
      for(const k of Game.atkTiles){
        const {x,y} = parseKey(k);
        const px=x*TILE, py=y*TILE;
        ctx.fillStyle = COLORS.atk;
        ctx.fillRect(px,py,TILE,TILE);
        ctx.strokeStyle = COLORS.atkEdge;
        ctx.strokeRect(px+1,py+1,TILE-2,TILE-2);
      }
    }

    if(Game.sel){
      const x = Game.sel.type==="unit" ? Game.sel.unit.x : Game.sel.x;
      const y = Game.sel.type==="unit" ? Game.sel.unit.y : Game.sel.y;
      const px=x*TILE, py=y*TILE;
      ctx.fillStyle = COLORS.select;
      ctx.fillRect(px,py,TILE,TILE);
      ctx.strokeStyle = COLORS.selectEdge;
      ctx.lineWidth = 3;
      ctx.strokeRect(px+2,py+2,TILE-4,TILE-4);
      ctx.lineWidth = 1;
    }

    for(const u of Game.units){
      if(u.owner!==Game.currentPlayer) continue;
      if(!u.def.canCapture || u.acted) continue;
      const b = buildingAt(u.x, u.y);
      if(!b) continue;
      if(b.owner===u.owner && b.capturePoints===20) continue;
      const px=u.x*TILE, py=u.y*TILE;
      ctx.fillStyle = COLORS.danger;
      ctx.fillRect(px,py,TILE,TILE);
      ctx.strokeStyle = COLORS.warn;
      ctx.lineWidth = 3;
      ctx.strokeRect(px+2,py+2,TILE-4,TILE-4);
      ctx.lineWidth = 1;
    }

    if(inBounds(Game.hovered.x, Game.hovered.y)){
      const px=Game.hovered.x*TILE, py=Game.hovered.y*TILE;
      ctx.globalAlpha = 0.18;
      ctx.fillStyle = "#ffffff";
      ctx.fillRect(px,py,TILE,TILE);
      ctx.globalAlpha = 1;
    }
  }

  /***********************************************************************
   * Win Checks
   ***********************************************************************/
  function hasHQ(ownerId){
    for(let y=0;y<GRID_H;y++){
      for(let x=0;x<GRID_W;x++){
        const b = buildingAt(x,y);
        if(b && b.kindId==="HQ" && b.owner===ownerId) return true;
      }
    }
    return false;
  }

  function hasTroops(ownerId){
    return Game.units.some(u=>u.owner===ownerId);
  }

  function sanityWinCheck(){
    if(Game.gameOver) return;

    const p1HQ = hasHQ(1);
    const p2HQ = hasHQ(2);
    const p1Troops = hasTroops(1);
    const p2Troops = hasTroops(2);

    if(!p1HQ){
      Game.gameOver = true;
      logLine("Player 2 wins (Player 1 HQ lost).", 2);
    } else if(!p2HQ){
      Game.gameOver = true;
      logLine("Player 1 wins (Player 2 HQ lost).", 1);
    } else if(!p1Troops && p2Troops){
      Game.gameOver = true;
      logLine("Player 2 wins (Player 1 has no troops).", 2);
    } else if(!p2Troops && p1Troops){
      Game.gameOver = true;
      logLine("Player 1 wins (Player 2 has no troops).", 1);
    }
  }

  /***********************************************************************
   * Auto-open shop on base double click
   ***********************************************************************/
  canvas.addEventListener("dblclick", (e)=>{
    const g = canvasToGrid(e.clientX, e.clientY);
    if(!inBounds(g.x,g.y)) return;
    const b = buildingAt(g.x,g.y);
    if(b && b.kindId==="BASE" && b.owner===Game.currentPlayer){
      selectBuilding(b, g.x, g.y);
      openShopIfOnOwnedBase();
      updateUI();
    }
  });

  /***********************************************************************
   * Keep selection valid if unit dies
   ***********************************************************************/
  function validateSelection(){
    if(!Game.sel) return;
    if(Game.sel.type==="unit"){
      const uid = Game.sel.unit.uid;
      const still = Game.units.find(u=>u.uid===uid);
      if(!still){
        clearSelection();
        updateUI();
      } else {
        Game.sel.unit = still;
      }
    }
  }

  /***********************************************************************
   * Game Loop
   ***********************************************************************/
  function tick(){
    validateSelection();
    sanityWinCheck();
  }
  setInterval(tick, 120);

  /***********************************************************************
 * HOTFIX: Safe deterministic hash helpers (replaces buggy BigInt version)
 ***********************************************************************/
function hash2(x, y, seed = 1337) {
  // 32-bit integer hash (no BigInt)
  let h = (x | 0) * 374761393 ^ (y | 0) * 668265263 ^ (seed | 0) * 1442695041;
  h = (h ^ (h >>> 13)) | 0;
  h = (h * 1274126177) | 0;
  h = (h ^ (h >>> 16)) | 0;
  return h >>> 0; // unsigned
}
function hashFloat01(x, y, seed = 1337) {
  return (hash2(x, y, seed) % 100000) / 100000;
}
function hashInt(x, y, seed, mod) {
  return Math.floor(hashFloat01(x, y, seed) * mod);
}


  /***********************************************************************
   * Boot
   ***********************************************************************/
  loadSprites();
  hardReset();
  requestAnimationFrame(draw);

  </script>
</body>
</html>
