<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="icon" type="image/png" href="assets/blue_rocket.png" />
  <title>Advanced Wars</title>
  <style>
    :root{
      --bg:#0b1020;
      --panel:#111a33;
      --panel2:#0f1730;
      --text:#e8eeff;
      --muted:#a9b6e6;
      --accent:#5dd6ff;
      --good:#74ff8a;
      --warn:#ffd166;
      --bad:#ff5d7a;
      --grid:#1c2b57;
    }
    html,body{height:100%;margin:0;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
    #wrap{display:flex;align-items:stretch;justify-content:center;gap:8px;padding:12px;box-sizing:border-box;height:100%}
    #gameCol{display:flex;flex-direction:column;gap:10px;align-items:flex-start}
    canvas{background:#050814;border:1px solid #23346b;border-radius:10px;image-rendering:pixelated}
    #panel{
      width:360px;
      max-width:38vw;
      height:calc(100vh - 24px); /* keep the full panel in view */
      background:linear-gradient(180deg,var(--panel),var(--panel2));
      border:1px solid #23346b;
      border-radius:14px;
      padding:12px;
      box-sizing:border-box;
      display:flex;
      flex-direction:column;
      gap:10px;
      overflow:auto;
      scrollbar-width:none; /* hide scrollbar in Firefox */
    }
    #panel::-webkit-scrollbar{display:none;} /* hide scrollbar in WebKit */
    .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    .btn{
      background:#152252;border:1px solid #2a3f86;color:var(--text);
      padding:8px 10px;border-radius:10px;cursor:pointer;font-weight:600
    }
    .btn:hover{border-color:#4a67d6}
    .btn:active{transform:translateY(1px)}
    .btn.primary{background:#1b2c69;border-color:#4a67d6}
    .btn.good{background:#134d2a;border-color:#2bd37e}
    .btn.bad{background:#5a1630;border-color:#ff5d7a}
    .btn:disabled{opacity:.45;cursor:not-allowed}
    .tag{padding:2px 8px;border:1px solid #2a3f86;border-radius:999px;font-size:12px;color:var(--muted)}
    .big{font-size:18px;font-weight:800}
    .muted{color:var(--muted)}
    #log{
      flex:1;
      min-height:240px; /* give the log room so it doesn't collapse */
      max-height:45vh;
      overflow:auto;
      background:#0a1026;
      border:1px solid #23346b;
      border-radius:12px;
      padding:10px;
      line-height:1.25;
      scrollbar-width:none;
    }
    #log::-webkit-scrollbar{display:none;}
    #log .line{margin:0 0 8px 0}
    #log .p1{color:#7cc6ff}
    #log .p2{color:#ff8aa7}
    #help{display:none}
    .kv{display:grid;grid-template-columns:1fr auto;gap:6px 10px;font-size:13px}
    .sep{height:1px;background:#203368;margin:6px 0}
    .list{display:flex;flex-direction:column;gap:6px}
    .shopItem{
      display:flex;align-items:center;justify-content:space-between;gap:12px;
      background:#0b1433;border:1px solid #23346b;border-radius:12px;padding:10px 12px
    }
    .shopItem .name{font-weight:700}
    .shopItem .meta{font-size:12px;color:var(--muted);line-height:1.35}
    .pill{
      padding:3px 8px;border-radius:999px;font-size:12px;font-weight:700;border:1px solid #2a3f86;color:var(--text)
    }
    .pill.good{border-color:#2bd37e;color:#a9ffd1}
    .pill.warn{border-color:#ffd166;color:#ffe7a8}
    .pill.bad{border-color:#ff5d7a;color:#ffc1cd}
    .inputRow{display:flex;gap:8px;align-items:center;justify-content:center;flex-wrap:wrap}
    .numInput{
      background:#0b1433;border:1px solid #23346b;color:var(--text);
      border-radius:10px;padding:6px 10px;min-width:96px;box-sizing:border-box;
    }
    .numInput:focus{outline:1px solid var(--accent);}
    .mapSettingsBox{
      display:none;
      width:100%;
      background:#0b1433;
      border:1px solid #23346b;
      border-radius:12px;
      padding:10px;
      box-sizing:border-box;
      gap:8px;
      flex-direction:column;
    }
    /* NEW: Key/Legend panel */
    #keyBox{
      display:none;
      background:#0a1026;
      border:1px solid #23346b;
      border-radius:12px;
      padding:10px;
    }
    .legendRow{
      display:flex;align-items:center;justify-content:space-between;gap:10px;
      padding:6px 8px;border:1px solid #23346b;border-radius:10px;background:#08102a
    }
    .swatch{
      width:18px;height:18px;border-radius:4px;border:1px solid #23346b;flex:0 0 auto;
    }
    .abbr{
      font-weight:800;letter-spacing:.5px;font-size:12px;
      padding:2px 6px;border-radius:8px;border:1px solid #23346b;background:#0b1433
    }
    /* Panels under keybinds */
    /* Match the board width so the right panel sits closer to the canvas */
    #lowerPanels{width:100%;max-width:768px;display:flex;flex-direction:column;gap:12px}
    .floatingPanel{
      display:none;
      background:#0a1026;
      border:1px solid #23346b;
      border-radius:14px;
      padding:12px;
      box-sizing:border-box;
    }
    #shopBox{display:block}
    .floatingPanel .headerRow{display:flex;justify-content:space-between;align-items:flex-end;gap:10px;flex-wrap:wrap}
    .shopStats{display:flex;gap:10px;flex-wrap:wrap;font-size:12px;color:var(--muted)}
    .shopStats .pill{font-size:12px}
    .shopGrid{display:flex;flex-direction:column;gap:8px}
    #selKv{display:none}
    #selStats{display:flex;flex-direction:column;gap:6px}
    .selRow{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
    .selRow.center{justify-content:center}
    .selImgRow{display:flex;justify-content:center}
    .thumb{
      width:80px;height:80px;border-radius:10px;
      border:1px solid #23346b;background:#0b1433;
      display:flex;align-items:center;justify-content:center;
      box-sizing:border-box;
    }
    #battleOverlay{
      position:fixed;inset:0;background:rgba(5,8,20,0.9);
      display:none;align-items:center;justify-content:center;
      z-index:9999;
    }
    #battleBox{
      width:80vw;max-width:960px;
      display:flex;justify-content:space-between;align-items:center;
      gap:20px;padding:20px;
      background:#0a1026;border:1px solid #23346b;border-radius:16px;
      box-shadow:0 20px 50px rgba(0,0,0,0.45);
    }
    .battleSide{
      flex:1;display:flex;flex-direction:column;align-items:center;gap:10px;
    }
    .battleImg{
      width:150px;height:150px;
      background:#0b1433;border:1px solid #23346b;border-radius:16px;
      display:flex;align-items:center;justify-content:center;
      overflow:hidden;image-rendering:pixelated;
    }
    .battleImg img{width:100%;height:100%;object-fit:contain;image-rendering:pixelated;}
    .battleHP{
      width:180px;height:14px;background:#0b1433;border:1px solid #23346b;border-radius:8px;overflow:hidden;
    }
    .battleHPFill{
      height:100%;background:#74ff8a;transition:width 0.4s ease;
    }
    .battleLabel{font-weight:700}
    .battleDamage{font-weight:800;font-size:13px;color:#e8eeff;min-height:16px}
    .battleDamage.sub{font-weight:700;font-size:12px;color:#a9b6e6}
    .hitLeft{animation:hitLeft 0.35s ease;}
    .hitRight{animation:hitRight 0.35s ease;}
    @keyframes hitLeft{0%{transform:translateX(0);}50%{transform:translateX(18px);}100%{transform:translateX(0);}}
    @keyframes hitRight{0%{transform:translateX(0);}50%{transform:translateX(-18px);}100%{transform:translateX(0);}}

    /* Stats header */
    #statsGrid{display:grid;grid-template-columns:1fr 1fr;gap:10px}
    .playerCard{
      background:#0a1026;
      border:1px solid #23346b;
      border-radius:12px;
      padding:10px;
      display:flex;
      flex-direction:column;
      gap:8px;
      transition:border-color 0.2s ease, box-shadow 0.2s ease;
    }
    .playerCard.active{box-shadow:0 0 0 1px rgba(93,214,255,0.35);}
    .playerCardHeader{display:flex;align-items:center;gap:10px}
    .coAvatar.mini{width:48px;height:48px}
    .playerCardHeader{position:relative}
    .coTooltip{
      display:none;
      position:fixed;
      top:58px;left:50%;
      transform:translateX(-50%);
      z-index:20;
      background:#0b1433;
      border:1px solid #23346b;
      border-radius:10px;
      padding:8px 10px;
      width:260px;
      max-width:90vw;
      box-shadow:0 10px 25px rgba(0,0,0,0.4);
    }
    .coTooltip.show{display:block;}
    .playerText .playerName{font-weight:800;font-size:14px}
    .playerText .playerCO{font-size:12px;color:#a9b6e6}
    .playerStats{display:flex;gap:8px;flex-wrap:wrap}
    .pill.mini{font-size:12px;padding:4px 8px}
    .playerTopActions{display:flex;gap:6px;flex-wrap:wrap}
    .playerTopMeter{width:100%;max-width:220px}
    #panel>.sep:first-of-type{margin-top:4px;margin-bottom:6px}
    /* Characters & Income */
    #coSection{background:#0a1026;border:1px solid #23346b;border-radius:12px;padding:10px;display:flex;flex-direction:column;gap:8px}
    #coSection{display:none!important;}
    .coCards{display:flex;flex-direction:column;gap:10px}
    .coCard{background:#0b1433;border:1px solid #23346b;border-radius:10px;padding:10px;display:flex;flex-direction:column;gap:8px}
    .coRow{display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap}
    .coSelection{display:flex;gap:10px;align-items:flex-start;cursor:pointer}
    .coSelection:hover{border-color:#4a67d6}
    .coSelection{border:1px dashed #2a3f86;border-radius:10px;padding:8px}
    .coAvatar{
      width:56px;height:56px;border-radius:12px;
      background:linear-gradient(135deg,#1b2c69,#152252);
      border:1px solid #2a3f86;
      display:flex;align-items:center;justify-content:center;
      font-weight:800;color:#e8eeff;font-size:18px;flex-shrink:0;
      overflow:hidden;
    }
    .coAvatar img{width:100%;height:100%;object-fit:cover;display:block;}
    .coAvatar.editable{position:relative;cursor:pointer;}
    .coAvatar.editable::after{
      content:"✎";
      position:absolute;
      bottom:4px;right:4px;
      width:18px;height:18px;
      border-radius:6px;
      background:rgba(5,8,20,0.8);
      border:1px solid #4a67d6;
      color:#e8eeff;
      font-size:11px;
      display:flex;align-items:center;justify-content:center;
      opacity:0;transition:opacity 0.2s ease;
      pointer-events:none;
    }
    .coAvatar.editable:hover::after{opacity:1;}
    .coText{display:flex;flex-direction:column;gap:4px}
    .coName{font-weight:800;font-size:14px}
    .coBuff{font-size:12px;color:#a9b6e6;line-height:1.35}
    .coBuff.small{font-size:11px}
    .coPill{padding:4px 8px;border-radius:999px;font-size:12px;font-weight:700;border:1px solid #2a3f86}
    .coPill.p1{color:#a9d9ff;border-color:#4a67d6}
    .coPill.p2{color:#ffc1cd;border-color:#ff5d7a}
    .btn.tiny{padding:4px 8px;font-size:12px;border-radius:8px}
    .coHelp{font-size:12px;color:#a9b6e6;line-height:1.4}
    .abilityLine{display:flex;flex-wrap:wrap;gap:6px;align-items:flex-start;margin-top:2px}
    .abilityBadge{padding:3px 7px;border-radius:8px;border:1px solid #2a3f86;font-size:11px;font-weight:700;color:#e8eeff;background:#11204a}
    .abilityCopy{font-size:12px;color:#c9d4ff;line-height:1.35}
    .coMeter{position:relative;width:100%;height:10px;border-radius:999px;background:#0a1026;border:1px solid #23346b;overflow:hidden}
    .coMeterFill{position:absolute;inset:0;width:0%;background:linear-gradient(90deg,#4a67d6,#5dd6ff);border-radius:999px;transition:width 0.2s ease}
    .coMeterLabel{font-size:11px;color:#a9b6e6;margin-top:4px}
    .coActions{display:flex;gap:6px;flex-wrap:wrap}

    /* CO modal */
    #coModal{position:fixed;inset:0;background:rgba(5,8,20,0.8);display:none;align-items:center;justify-content:center;z-index:7000}
    #coModal .modalBox{width:90vw;max-width:720px;background:#0a1026;border:1px solid #23346b;border-radius:14px;padding:14px;box-shadow:0 20px 40px rgba(0,0,0,0.55);}
    .coList{display:flex;flex-direction:column;gap:10px;margin-top:10px;max-height:70vh;overflow:auto;padding-right:4px}
    .coList{scrollbar-width:none;}
    .coList::-webkit-scrollbar{display:none;}
    .coOption{display:grid;grid-template-columns:auto 1fr auto;gap:10px;align-items:center;background:#0b1433;border:1px solid #23346b;border-radius:10px;padding:10px}
    .coOption .coText{gap:2px}
    .coOption .coName{font-size:15px}
    .coOption .coBuff{font-size:12px}
    .coOption .coBuff.small{font-size:11px}

    /* Turn overlay */
    #turnOverlay{position:fixed;inset:0;display:none;align-items:center;justify-content:center;z-index:6500;pointer-events:none;background:radial-gradient(circle at 30% 30%,rgba(93,214,255,0.12),transparent 45%),radial-gradient(circle at 70% 70%,rgba(255,93,122,0.12),transparent 45%)}
    #turnOverlay .turnBox{min-width:320px;max-width:520px;background:#0b1433;border:1px solid #23346b;border-radius:16px;padding:16px;box-shadow:0 20px 40px rgba(0,0,0,0.45);transform:translateY(20px);opacity:0;transition:opacity 0.3s ease,transform 0.3s ease}
    #turnOverlay.show .turnBox{opacity:1;transform:translateY(0)}
    /* Map picker modal */
    #mapModal{
      position:fixed;inset:0;display:none;align-items:center;justify-content:center;
      background:rgba(5,8,20,0.8);z-index:9999;
    }
    #mapModal .modalBox{
      width:90vw;max-width:780px;
      background:#0a1026;border:1px solid #23346b;border-radius:16px;
      padding:16px;box-shadow:0 20px 40px rgba(0,0,0,0.5);
      display:flex;flex-direction:column;gap:12px;
      max-height:90vh;
      overflow:auto;
      scrollbar-width:none;
    }
    #mapModal .modalBox::-webkit-scrollbar{display:none;}
    .mapGrid{
      display:grid;
      grid-template-columns:repeat(auto-fit,minmax(220px,1fr));
      gap:10px;
    }
    .mapCard{
      background:#0b1433;border:1px solid #23346b;border-radius:12px;padding:10px;
      display:flex;flex-direction:column;gap:6px;
    }
    .mapCard .name{font-weight:800}
    .mapCard .meta{font-size:12px;color:var(--muted)}
    .mapCard button{align-self:flex-start}
    .customMapSection{
      background:#0b1433;
      border:1px solid #23346b;
      border-radius:12px;
      padding:10px;
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:8px;
      text-align:center;
    }
    .customPalette{
      display:flex;
      flex-direction:column;
      gap:10px;
      align-items:center;
    }
    .paletteRow{
      display:flex;
      flex-wrap:wrap;
      gap:8px;
      justify-content:center;
      width:100%;
    }
    .tileSwatch{
      width:56px;height:56px;border-radius:12px;border:1px solid #23346b;
      display:flex;align-items:center;justify-content:center;
      cursor:pointer;
      background:#0a1026;
      background-size:cover;
      background-position:center;
      background-repeat:no-repeat;
    }
    .tileSwatch.active{box-shadow:0 0 0 2px var(--accent);}
    .customGrid{
      display:grid;
      grid-template-columns:repeat(16, 36px);
      grid-auto-rows:36px;
      gap:2px;
      background:#050814;
      padding:10px;
      border:1px solid #23346b;
      border-radius:10px;
      max-width:640px;
      overflow:auto;
      margin-left:auto;
      margin-right:auto;
    }
    .nameEditInput{
      border:1px solid #4a67d6;
      border-radius:6px;
      padding:4px 8px;
      background:#0b1433;
      color:var(--text);
      outline:none;
      min-width:120px;
      max-width:160px;
      font-weight:800;
    }
    .customCell{
      width:36px;height:36px;
      border-radius:6px;
      border:1px solid #23346b;
      cursor:pointer;
      box-sizing:border-box;
      display:flex;align-items:center;justify-content:center;
      font-size:12px;font-weight:700;color:var(--text);
      user-select:none;
    }
    .customActions{display:flex;flex-wrap:wrap;gap:8px;justify-content:center}
    #damagePreview{
      position:fixed;
      padding:14px 16px;
      background:#0b1433;
      border:1px solid #4a67d6;
      border-radius:10px;
      color:#e8eeff;
      font-size:16px;
      pointer-events:none;
      z-index:8000;
      display:none;
      box-shadow:0 10px 24px rgba(0,0,0,0.45);
      white-space:nowrap;
      text-align:center;
    }
    .previewIcon{
      height:26px;
      width:auto;
      vertical-align:middle;
      margin-right:10px;
      image-rendering:pixelated;
    }
    .previewHeader{
      font-weight:800;
      margin-bottom:10px;
      text-align:center;
      font-size:18px;
    }
    .previewRow{
      display:flex;
      align-items:center;
      justify-content:center;
      gap:8px;
      margin-bottom:6px;
    }
    .editableName{
      position:relative;
      cursor:pointer;
      display:inline-flex;
      align-items:center;
    }
    .editableName:hover{text-decoration:underline;}
    .editableName::after{
      content:"(edit)";
      font-size:11px;
      color:var(--muted);
      opacity:0;
      transition:opacity 0.15s ease;
      position:absolute;
      left:100%;
      top:50%;
      transform:translateY(-50%);
      margin-left:6px;
      pointer-events:none;
      white-space:nowrap;
    }
    .editableName:hover::after{opacity:1;}
    .turnMeta{display:flex;align-items:center;gap:8px;flex-wrap:wrap;margin-bottom:8px}
    .turnIncome{font-size:18px;font-weight:800}
    .turnCO{font-size:13px;color:#a9b6e6;line-height:1.35}
  </style>
</head>
<body>
  <div id="wrap">
    <div id="gameCol">
      <canvas id="c" width="768" height="576"></canvas>
      <div id="help">
        <div class="row">
          <span class="tag">Mouse</span><span>Select unit/building/tile, move, attack</span>
        </div>
        <div class="row">
          <span class="tag">Right Click</span><span>Cancel selection</span>
        </div>
        <div class="row">
          <span class="tag">E</span><span>End Turn</span>
          <span class="tag">B</span><span>Open Shop (on your Base)</span>
          <span class="tag">K</span><span>Open Key/Legend</span>
          <span class="tag">Esc</span><span>Close Shop / Close Key / Cancel</span>
        </div>
      </div>

      <div id="lowerPanels">
        <div id="shopBox" class="floatingPanel">
          <div class="headerRow">
            <div>
              <div class="big" style="font-size:16px">Production Shop</div>
              <div class="muted" id="shopHint">Build units on your production tiles.</div>
            </div>
            <button class="btn" id="closeShopBtn">Close (Esc)</button>
          </div>
          <div class="sep"></div>
          <div class="shopGrid" id="shopList"></div>
        </div>

        <div id="keyBox" class="floatingPanel">
          <div class="headerRow">
            <div>
              <div class="big" style="font-size:16px">Key / Legend</div>
              <div class="muted">Terrain and unit abbreviations (press K to toggle)</div>
            </div>
            <button class="btn" id="closeKeyBtn">Close (Esc)</button>
          </div>
          <div class="sep"></div>

          <div class="big" style="font-size:14px">Terrain</div>
          <div class="list" id="terrainLegend"></div>

          <div class="sep"></div>

          <div class="big" style="font-size:14px">Units</div>
          <div class="list" id="unitLegend"></div>
        </div>
      </div>
    </div>

    <div id="panel">
      <div class="row" style="justify-content:center">
        <div style="display:flex;justify-content:center;width:100%;">
          <img src="assets/logo.png" alt="Game Logo" style="max-width:240px; height:auto; display:block;">
        </div>
      </div>



      <div id="statsGrid">
        <div class="playerCard" id="p1Card">
          <div class="playerCardHeader">
            <div class="coAvatar mini editable" id="p1TopAvatar" title="Change CO"></div>
            <div class="playerText">
              <div class="playerName editableName" id="p1NameLabel">Player 1</div>
              <div class="playerCO" id="p1TopCOName">Andy</div>
            </div>
            <div class="coTooltip" id="p1TopTooltip"></div>
          </div>
          <div class="playerStats">
            <span class="pill mini" id="p1Funds">Funds 0</span>
            <span class="pill mini" id="p1TopIncome">Income 0</span>
          </div>
          <div class="playerTopActions" id="p1TopActions">
            <button class="btn tiny primary" id="p1TopPower">Power</button>
            <button class="btn tiny primary" id="p1TopSuper">Super</button>
          </div>
          <div class="playerTopMeter coMeter playerTopMeter"><div class="coMeterFill" id="p1TopMeterFill"></div></div>
        </div>
        <div class="playerCard" id="p2Card">
          <div class="playerCardHeader">
            <div class="coAvatar mini editable" id="p2TopAvatar" title="Change CO"></div>
            <div class="playerText">
              <div class="playerName editableName" id="p2NameLabel">Player 2</div>
              <div class="playerCO" id="p2TopCOName">Andy</div>
            </div>
            <div class="coTooltip" id="p2TopTooltip"></div>
          </div>
          <div class="playerStats">
            <span class="pill mini" id="p2Funds">Funds 0</span>
            <span class="pill mini" id="p2TopIncome">Income 0</span>
          </div>
          <div class="playerTopActions" id="p2TopActions">
            <button class="btn tiny primary" id="p2TopPower">Power</button>
            <button class="btn tiny primary" id="p2TopSuper">Super</button>
          </div>
          <div class="playerTopMeter coMeter playerTopMeter"><div class="coMeterFill" id="p2TopMeterFill"></div></div>
        </div>
      </div>

      <div id="selectionBox">
        <div class="big" style="font-size:16px">Tile/Troop Info</div>
        <div class="muted" id="selHint">Click a unit, building, or tile.</div>
        <br>
        
        <div class="kv" id="selKv"></div>
        
        <div class="shopStats" id="selStats"></div>
      </div>

      <div class="sep"></div>

      <div class="row" style="justify-content:center; flex-wrap:wrap;">
        <button class="btn primary" id="endTurnBtn">End Turn (E)</button>
        <button class="btn" id="newBtn">New Game</button>
        <button class="btn bad" id="resetBtn" title="Hard reset the match">Reset</button>
        <button class="btn" id="openShopBtn" title="Open your shop (cycles owned bases)">Open Shop (B)</button>
        <button class="btn" id="moveBtn" title="Hold to show move range (M)">Move Range (M)</button>
        <button class="btn" id="dmgBtn" title="Hold to show attack range (D)">Damage Range (D)</button>
        <button class="btn" id="rangeBtn" title="Hold to show move+attack (S)">All Range (S)</button>
        <button class="btn" id="atkInfoBtn" title="Attack info overlay (Q)">Attack Info (Q)</button>
        <button class="btn" id="keyBtn" title="Open unit/terrain legend">Key (K)</button>
        <button class="btn" id="unselectBtn" title="Clear selection / close panels">Unselect/Escape (ESC)</button>
      </div>

      <div class="sep"></div>

      <div id="coSection">
        <div class="big" style="font-size:16px">Powers</div>
        <div class="coHelp">Day-to-day buffs are always on. CO Power / Super are burst abilities (pretend the meter fills as you fight; trigger when full). Click a commander card to swap and preview their kit.</div>
        <div class="coCards">
          <div class="coCard" data-player="1">
            <div class="coRow">
              <div class="coPill p1">Player 1 (Blue)</div>
              <div style="flex:1;min-width:180px">
                <div class="coMeter"><div class="coMeterFill" id="p1MeterFill"></div></div>
                <div class="coMeterLabel" id="p1MeterLabel">Meter 0%</div>
              </div>
            </div>
            <div class="coSelection" data-player="1" id="p1COCard">
              <div class="coAvatar" id="p1COAvatar">P1</div>
              <div class="coText">
                <div class="coName" id="p1COName">Andy</div>
                <div class="coBuff" id="p1COSpecialty">No strengths or weaknesses.</div>
                <div class="coBuff small" id="p1COPower">CO Power: —</div>
                <div class="coBuff small" id="p1COSuper">Super CO Power: —</div>
              </div>
              <button class="btn tiny" data-player="1" id="p1ChooseCO">Choose</button>
            </div>
            <div class="coActions">
              <button class="btn tiny" id="p1PowerBtn">Power</button>
              <button class="btn tiny primary" id="p1SuperBtn">Super</button>
            </div>
          </div>

          <div class="coCard" data-player="2">
            <div class="coRow">
              <div class="coPill p2">Player 2 (Red)</div>
              <div style="flex:1;min-width:180px">
                <div class="coMeter"><div class="coMeterFill" id="p2MeterFill"></div></div>
                <div class="coMeterLabel" id="p2MeterLabel">Meter 0%</div>
              </div>
            </div>
            <div class="coSelection" data-player="2" id="p2COCard">
              <div class="coAvatar" id="p2COAvatar">P2</div>
              <div class="coText">
                <div class="coName" id="p2COName">Andy</div>
                <div class="coBuff" id="p2COSpecialty">No strengths or weaknesses.</div>
                <div class="coBuff small" id="p2COPower">CO Power: —</div>
                <div class="coBuff small" id="p2COSuper">Super CO Power: —</div>
              </div>
              <button class="btn tiny" data-player="2" id="p2ChooseCO">Choose</button>
            </div>
            <div class="coActions">
              <button class="btn tiny" id="p2PowerBtn">Power</button>
              <button class="btn tiny primary" id="p2SuperBtn">Super</button>
            </div>
          </div>
        </div>
      </div>

      <div class="sep"></div>

      <div class="big" style="font-size:16px">Battle Log</div>
      <div id="log"></div>
    </div>
  </div>

  <div id="battleOverlay">
    <div id="battleBox">
      <div class="battleSide" id="battleLeft">
        <div class="battleImg"><img id="battleLeftImg" alt=""></div>
        <div class="battleLabel" id="battleLeftLabel"></div>
        <div class="battleDamage" id="battleLeftDmg"></div>
        <div class="battleHP"><div class="battleHPFill" id="battleLeftHP"></div></div>
      </div>
      <div class="battleSide" id="battleRight">
        <div class="battleImg"><img id="battleRightImg" alt=""></div>
        <div class="battleLabel" id="battleRightLabel"></div>
        <div class="battleDamage sub" id="battleRightDmg"></div>
        <div class="battleHP"><div class="battleHPFill" id="battleRightHP"></div></div>
      </div>
    </div>
  </div>

  <div id="coModal">
    <div class="modalBox">
      <div class="headerRow">
        <div>
          <div class="big" style="font-size:16px">Choose CO</div>
          <div class="muted" id="coModalHint">Pick a commander to set their buffs.</div>
        </div>
        <br>
        <button class="btn" id="closeCoModal">Close (ESC)</button>
      </div>
      <div class="sep"></div>
      <div class="coList" id="coList"></div>
    </div>
  </div>

  <div id="mapModal">
    <div class="modalBox">
      <div class="headerRow" style="display:flex;flex-direction:column;align-items:center;gap:10px">
        <div class="big" style="font-size:18px;text-align:center;width:100%;">Choose a Map</div>
        <div class="row" style="justify-content:center;gap:6px;flex-wrap:wrap">
          <button class="btn" id="botHumanBtn" title="2-Player local">2P</button>
          <button class="btn" id="botEasyBtn" title="vs Bot (Easy)">Bot Easy</button>
          <button class="btn" id="botMedBtn" title="vs Bot (Medium)">Bot Med</button>
          <button class="btn" id="botHardBtn" title="vs Bot (Hard)">Bot Hard</button>
        </div>
        <button class="btn" id="mapSettingsBtn" style="width:100%;text-align:center;">Settings</button>
        <div class="mapSettingsBox" id="mapSettingsBox">
          <div class="muted" style="font-size:12px;margin-bottom:6px">Starting funds apply on New Game; city income updates immediately.</div>
          <div class="inputRow" style="justify-content:center">
            <label class="muted" for="startFundsInput">Starting funds</label>
            <input class="numInput" id="startFundsInput" type="number" min="0" step="500" value="5000" />
            <label class="muted" for="cityIncomeInput">Income per city</label>
            <input class="numInput" id="cityIncomeInput" type="number" min="0" step="100" value="1000" />
          </div>
          <div class="inputRow" style="justify-content:center">
            <label class="muted" for="defaultIncomeInput">Extra income/round</label>
            <input class="numInput" id="defaultIncomeInput" type="number" min="0" step="100" value="0" />
          </div>
        </div>
        <button class="btn" id="closeMapModal" style="width:100%;text-align:center;">Close</button>
      </div>
      <div class="mapGrid" id="mapList"></div>
      <div class="sep"></div>
      <div class="customMapSection" id="customMapSection">
        <div class="big" style="font-size:15px">Custom Map (16x12)</div>
        <div class="muted" style="font-size:12px">Click or drag to paint tiles.</div>
        <div class="customPalette" id="customPalette"></div>
        <div class="customGrid" id="customGrid"></div>
        <div class="customActions">
          <button class="btn" id="fillPlains">Fill Plains</button>
          <button class="btn bad" id="resetCustom">Reset</button>
          <button class="btn primary" id="applyCustomMap">Start Custom Map</button>
        </div>
      </div>
    </div>
  </div>

  <div id="turnOverlay">
    <div class="turnBox" id="turnOverlayBox">
      <div class="turnMeta">
        <span class="coPill p1" id="turnOverlayPlayer">Player</span>
        <span class="pill" id="turnOverlayDay">Day</span>
      </div>
      <div class="turnIncome" id="turnOverlayIncome">Income +0</div>
    </div>
  </div>
  <div id="damagePreview"></div>

  <script>
  "use strict";

  /***********************************************************************
   * TurnGrid Tactics
   ***********************************************************************/

  /***********************************************************************
   * Constants & Utilities
   ***********************************************************************/
  const TILE = 48;
  const GRID_W = 16;
  const GRID_H = 12;

  const CANVAS_W = GRID_W * TILE;
  const CANVAS_H = GRID_H * TILE;

  const COLORS = {
    bg: "#050814",
    grid: "#1c2b57",

    // players
    p1: "#63baff",
    p2: "#ff6f90",
    p1Dark: "#1f4f8a",
    p2Dark: "#8a1f3f",

    // highlights
    move: "rgba(93, 214, 255, 0.22)",
    moveEdge: "rgba(93, 214, 255, 0.75)",
    atk: "rgba(255, 93, 122, 0.20)",
    atkEdge: "rgba(255, 93, 122, 0.75)",
    select: "rgba(116, 255, 138, 0.20)",
    selectEdge: "rgba(116, 255, 138, 0.75)",
    danger: "rgba(255, 209, 102, 0.20)",
    dangerEdge: "rgba(255, 209, 102, 0.75)"
  };

  const SPRITE_SOURCES = {
    INF: { 1:["assets/blue_inf.png","assets/blue_inf2.png"], 2:["assets/red_inf.png","assets/red_inf2.png"] },
    RECON:{ 1:["assets/blue_recon.png"], 2:["assets/red_recon.png"] },
    TANK:{ 1:["assets/blue_tank.png"], 2:["assets/red_tank.png"] },
    MDT: { 1:["assets/blue_mdtank.png"], 2:["assets/red_mdtank.png"] },
    ART: { 1:["assets/blue_art.png"], 2:["assets/red_art.png"] },
    RKT: { 1:["assets/blue_rocket.png"], 2:["assets/red_rocket.png"] },
    APC: { 1:["assets/blue_apc.png"], 2:["assets/red_apc.png"] },
    CRU: { 1:["assets/blue_cruiser.png"], 2:["assets/red_cruiser.png"] },
    SUB: { 1:["assets/blue_submarine.png"], 2:["assets/red_submarine.png"] },
    LND: { 1:["assets/blue_lander.png"], 2:["assets/red_lander.png"] },
    BSH: { 1:["assets/blue_battleship.png"], 2:["assets/red_battleship.png"] },
    FTR: { 1:["assets/blue_fighter.png"], 2:["assets/red_fighter.png"] },
    BMB: { 1:["assets/blue_bomber.png"], 2:["assets/red_bomber.png"] },
    BC:  { 1:["assets/blue_battle.png"], 2:["assets/red_battle.png"] },
    TC:  { 1:["assets/blue_transport.png"], 2:["assets/red_transport.png"] }
  };
  const SPRITE_IMAGES = {};

  const BUILDING_SOURCES = {
    HQ:   { 1:"assets/blue_hq.png", 2:"assets/red_hq.png", 0:"assets/building.png" },
    BASE: { 1:"assets/blue_base.png", 2:"assets/red_base.png", 0:"assets/building.png" },
    CITY: { 1:"assets/blue_building.png", 2:"assets/red_building.png", 0:"assets/building.png" },
    AIRPORT: { 1:"assets/blue_airport.png", 2:"assets/red_airport.png", 0:"assets/blue_airport.png" },
    SHIPPORT: { 1:"assets/blue_shipport.png", 2:"assets/red_shipport.png", 0:"assets/blue_shipport.png" }
  };
  const BUILDING_IMAGES = {};

  const TERRAIN_SOURCES = {
    PLAINS: "assets/grass.png",
    FOREST: "assets/forest.png",
    MOUNTAIN: "assets/mountain.png",
    ROAD: "assets/road.png",
    WATER: "assets/water.png"
  };
  const TERRAIN_IMAGES = {};

  // NEW: deterministic hash helpers (avoid animated noise)
  function hash2(x, y, seed=1337){
    let n = (x * 374761393 + y * 668265263 + seed * 1442695040888963407n) % 2147483647;
    // Above used BigInt; normalize:
    n = Number((BigInt(x) * 374761393n + BigInt(y) * 668265263n + BigInt(seed) * 1013904223n) & 0x7fffffffn);
    return n;
  }
  function hashFloat01(x,y,seed=1337){
    const h = hash2(x,y,seed) % 100000;
    return h / 100000;
  }
  function hashInt(x,y,seed,mod){
    return Math.floor(hashFloat01(x,y,seed) * mod);
  }

  const TERRAIN = {
    PLAINS:  { id:"PLAINS",  name:"Grass",   moveCost:{foot:1,tread:1,tires:1,sea:99,air:1}, def:0, color:"#143a2a" },
    FOREST:  { id:"FOREST",  name:"Forest",  moveCost:{foot:1,tread:2,tires:2,sea:99,air:1}, def:1, color:"#0f2f21" },
    MOUNTAIN:{ id:"MOUNTAIN",name:"Mountain",moveCost:{foot:2,tread:99,tires:99,sea:99,air:1},def:2, color:"#2a2b35" },
    ROAD:    { id:"ROAD",    name:"Road",    moveCost:{foot:1,tread:1,tires:1,sea:99,air:1}, def:0, color:"#2a2f3a" },
    WATER:   { id:"WATER",   name:"Water",   moveCost:{foot:2,tread:99,tires:99,sea:1,air:1},def:0, color:"#0a2542" }
  };

  const BUILDING = {
    CITY: { id:"CITY", name:"City", income:1000, def:1 },
    BASE: { id:"BASE", name:"Base", income:1000, def:1 },
    HQ:   { id:"HQ",   name:"HQ",   income:1000, def:3 },
    AIRPORT: { id:"AIRPORT", name:"Airport", income:1000, def:1 },
    SHIPPORT: { id:"SHIPPORT", name:"Ship Port", income:1000, def:1 }
  };

  // Unit definitions
  const UNIT_DEF = {
    INF: {
      id:"INF", name:"Infantry", abbr:"INF",
      cost: 1000,
      maxHP: 10,
      move: 3,
      movementType: "foot",
      rangeMin: 1, rangeMax: 1,
      canCapture: true,
      // Approximate Advance Wars-style values (scaled to 10hp system)
      baseAtk: { INF: 6, TANK: 1, MDT: 1, ART: 2, RKT: 2 },
      armor: 0
    },

    RECON: {
      id:"RECON", name:"Recon", abbr:"RCN",
      cost: 4000,
      maxHP: 10,
      move: 8,
      movementType: "tires",
      rangeMin: 1, rangeMax: 1,
      canCapture: false,
      baseAtk: { INF: 7, TANK: 1, MDT: 1, ART: 5, RKT: 6, RECON: 4 },
      armor: 0
    },

    // Tank #1 (existing)
    TANK: {
      id:"TANK", name:"Tank", abbr:"TNK",
      cost: 7000,
      maxHP: 10,
      move: 6,
      movementType: "tread",
      rangeMin: 1, rangeMax: 1,
      canCapture: false,
      baseAtk: { INF: 7, TANK: 5, MDT: 3, ART: 6, RKT: 6 },
      armor: 1
    },

    // NEW: Tank #2 (heavier)
    MDT: {
      id:"MDT", name:"Md Tank", abbr:"MDT",
      cost: 12000,
      maxHP: 10,
      move: 5,
      movementType: "tread",
      rangeMin: 1, rangeMax: 1,
      canCapture: false,
      baseAtk: { INF: 9, TANK: 8, MDT: 6, ART: 8, RKT: 8 },
      armor: 2
    },

    // Artillery (existing)
    ART: {
      id:"ART", name:"Artillery", abbr:"ART",
      cost: 6000,
      maxHP: 10,
      move: 5,
      movementType: "tread",
      rangeMin: 2, rangeMax: 3,
      canCapture: false,
      baseAtk: { INF: 8, TANK: 7, MDT: 5, ART: 7, RKT: 7 },
      armor: 0,
      indirect: true
    },

    // NEW: Rockets (longer-range indirect)
    RKT: {
      id:"RKT", name:"Rockets", abbr:"RKT",
      cost: 15000,
      maxHP: 10,
      move: 4,
      movementType: "tread",
      rangeMin: 3, rangeMax: 5,
      canCapture: false,
      baseAtk: { INF: 9, TANK: 8, MDT: 7, ART: 8, RKT: 7 },
      armor: 0,
      indirect: true
    },

    APC: {
      id:"APC", name:"APC", abbr:"APC",
      cost: 5000,
      maxHP: 10,
      move: 7,
      movementType: "tread",
      rangeMin: 1, rangeMax: 1,
      canCapture: false,
      baseAtk: {},
      armor: 0,
      transport: true,
      transportCapacity: 1,
      canAttack: false
    },

    CRU: {
      id:"CRU", name:"Cruiser", abbr:"CRU",
      cost: 18000,
      maxHP: 10,
      move: 6,
      movementType: "sea",
      rangeMin: 1, rangeMax: 1,
      canCapture: false,
      baseAtk: {},
      armor: 1
    },

    SUB: {
      id:"SUB", name:"Submarine", abbr:"SUB",
      cost: 20000,
      maxHP: 10,
      move: 5,
      movementType: "sea",
      rangeMin: 1, rangeMax: 1,
      canCapture: false,
      baseAtk: {},
      armor: 1
    },

    LND: {
      id:"LND", name:"Lander", abbr:"LND",
      cost: 12000,
      maxHP: 10,
      move: 6,
      movementType: "sea",
      rangeMin: 1, rangeMax: 1,
      canCapture: false,
      baseAtk: {},
      armor: 0,
      transport: true,
      transportCapacity: 2,
      canAttack: false
    },

    BSH: {
      id:"BSH", name:"Battleship", abbr:"BSH",
      cost: 28000,
      maxHP: 10,
      move: 5,
      movementType: "sea",
      rangeMin: 2, rangeMax: 6,
      canCapture: false,
      baseAtk: {},
      armor: 2,
      indirect: true
    },

    FTR: {
      id:"FTR", name:"Fighter", abbr:"FTR",
      cost: 20000,
      maxHP: 10,
      move: 9,
      movementType: "air",
      rangeMin: 1, rangeMax: 1,
      canCapture: false,
      baseAtk: {},
      armor: 1
    },

    BC: {
      id:"BC", name:"B-Copter", abbr:"BCP",
      cost: 9000,
      maxHP: 10,
      move: 6,
      movementType: "air",
      rangeMin: 1, rangeMax: 1,
      canCapture: false,
      baseAtk: {},
      armor: 1
    },

    TC: {
      id:"TC", name:"T-Copter", abbr:"TCP",
      cost: 5000,
      maxHP: 10,
      move: 6,
      movementType: "air",
      rangeMin: 1, rangeMax: 1,
      canCapture: false,
      baseAtk: {},
      armor: 0,
      transport: true,
      transportCapacity: 1,
      canAttack: false
    },

    BMB: {
      id:"BMB", name:"Bomber", abbr:"BMB",
      cost: 22000,
      maxHP: 10,
      move: 7,
      movementType: "air",
      rangeMin: 1, rangeMax: 1,
      canCapture: false,
      baseAtk: {},
      armor: 1
    }
  };

  // Explicit damage ranges (hp) per matchup at 10hp on 0-star terrain (includes luck).
  const DAMAGE_TABLE = {
    INF: {
      INF: [5,6],
      TANK: [0,1],
      MDT: [0,1],
      ART: [1,2],
      RKT: [2,3],
      APC: [1,2],
      RECON: [1,2]
    },
    RECON: {
      INF: [8,9], // tuned so grass cover still yields 7-8 per spec
      RECON: [3,4],
      TANK: [1,2],
      MDT: [0,1],
      ART: [4,5],
      RKT: [5,6],
      APC: [5,6]
    },
    TANK: {
      INF: [7,8],
      TANK: [5,6],
      MDT: [1,2],
      ART: [7,7],
      RKT: [8,8],
      APC: [7,8],
      RECON: [8,9]
    },
    MDT: {
      INF: [10,10],
      TANK: [8,9],
      MDT: [5,6],
      ART: [10,10],
      RKT: [10,10],
      APC: [10,11],
      RECON: [10,10]
    },
    ART: {
      INF: [9,10],
      TANK: [7,7],
      MDT: [4,5],
      ART: [7,8],
      RKT: [8,8],
      APC: [7,8],
      RECON: [8,8],
      BSH: [4,5],
      CRU: [6,7],
      SUB: [6,7],
      LND: [5,6]
    },
    RKT: {
      INF: [9,10],
      TANK: [8,8],
      MDT: [5,6],
      ART: [8,9],
      RKT: [8,9],
      RECON: [8,9],
      APC: [8,9],
      BSH: [5,6],
      CRU: [8,9],
      SUB: [8,9],
      LND: [6,7]
    },
    APC: {
      // unarmed; kept for completeness (no attack)
    },
    CRU: {
      SUB: [8,9],
      CRU: [2,3],
      BSH: [0,1],
      LND: [0,0]
    },
    SUB: {
      BSH: [5,6],
      CRU: [2,3],
      SUB: [5,6],
      LND: [9,10]
    },
    BSH: {
      BSH: [5,6],
      CRU: [4,5],
      LND: [9,10],
      SUB: [9,10],
      INF: [9,10],
      RECON: [9,10],
      TANK: [7,8],
      MDT: [5,6],
      ART: [8,9],
      RKT: [8,9],
      APC: [8,9]
    },
    FTR: {
      FTR: [5,6],
      BMB: [10,10],
      BC: [10,10],
      TC: [10,10]
    },
    BC: {
      FTR: [1,2],
      BMB: [2,3],
      BC: [4,5],
      TC: [8,9]
    },
    TC: {
      // unarmed
    },
    BMB: {
      BSH: [5,6],
      CRU: [5,6],
      LND: [9,10],
      SUB: [9,10],
      INF: [10,10],
      RECON: [10,10],
      TANK: [10,10],
      MDT: [9,10],
      ART: [10,10],
      RKT: [10,10],
      APC: [10,10]
    }
  };

  const UNIT_BLURB = {
    INF: "Low-cost soldiers essential for capturing properties",
    MECH: "Heavy-duty foot soldiers equipped with anti-tank rockets to defend rugged terrain like mountains.",
    RECON: "Move fast to counter enemy infantry",
    ART: "Mobile, indirect cannons that pack a punch",
    TANK: "Versatile front-line tanks designed to lead the charge",
    MDT: "Heavily armored juggernauts capable of dealing lots of damage",
    RKT: "Long-range siege launchers that pack a crazy punch",
    APC: "Transports one infantry; unarmed but fast on treads; left-click to load, right-click to unload",
    CRU: "Escort cruiser that hunts subs and swats air; best at sinking stealthy subs.",
    SUB: "Stealth assassin of the seas; primary counter to Battleships and Landers.",
    LND: "Non-combat transport that ferries two land units across the sea; Right-click to unload only onto land tiles.",
    BSH: "Indirect naval artillery; bombards sea and land from long range.",
    FTR: "Elite interceptor; dominates other air units (especially bombers).",
    BC: "Defensive battle copter that trades blows with other copters.",
    TC: "Unarmed transport copter; carries one infantry over any terrain. Right-click to unload",
    BMB: "Heavy bomber that crushes land and naval targets; vulnerable to fighters."
  };

  const PLAYERS = [
    { id:1, name:"Player 1", color:COLORS.p1, dark:COLORS.p1Dark },
    { id:2, name:"Player 2", color:COLORS.p2, dark:COLORS.p2Dark }
  ];

  const CO_DATA = {
    ANDY: {
      id:"ANDY",
      name:"Andy",
      img:"assets/andy.png",
      specialty:"Balanced: no passive buffs/penalties.",
      power:"Hyper Repair: Heals all owned units by 2 HP; Activating the ability refreshes spent units so they can act again this turn.",
      super:"Hyper Upgrade: Heals all owned units by 5 HP, all units gain +1 Move and +20% attack for the turn; Activating the ability refreshes spent units so they can act again this turn."
    },
    MAX: {
      id:"MAX",
      name:"Max",
      img:"assets/max.png",
      specialty:"Direct units +20% attack; indirect units -1 max range.",
      power:"Max Force: Direct units +1 Move and ~+40% attack this turn; Activating the ability refreshes spent units so they can act again this turn.",
      super:"Max Blast: Direct units +2 Move and ~+60% attack this turn; Activating the ability refreshes spent units so they can act again this turn."
    },
    SAMI: {
      id:"SAMI",
      name:"Sami",
      img:"assets/sami.png",
      specialty:"Infantry deal ~+20% damage; capture strength ~1.5× HP.",
      power:"Double Time: Infantry +1 Move, ~+50% damage, capture strength 2× HP; Activating the ability refreshes spent units so they can act again this turn.",
      super:"Victory March: Infantry +2 Move, ~+60% damage, captures complete in one turn; Activating the ability refreshes spent units so they can act again this turn."
    },
    NELL: {
      id:"NELL",
      name:"Nell",
      img:"assets/nell.png",
      specialty:"Adds 0–2 extra “luck” damage on every hit.",
      power:"Lucky Star: Luck range 0–4 extra damage; Activating the ability refreshes spent units so they can act again this turn.",
      super:"Lady Luck: Luck range 0–6 extra damage; Activating the ability refreshes spent units so they can act again this turn."
    },
    HACHI: {
      id:"HACHI",
      name:"Hachi",
      img:"assets/Hachi.png",
      specialty:"Units cost 10% less in shops.",
      power:"Barter: Units cost 50% less this turn; Activating the ability refreshes spent units so they can act again this turn.",
      super:"Merchant Union: Units cost 50% less this turn; Activating the ability refreshes spent units so they can act again this turn."
    }
  };

  function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }
  function inBounds(x,y){ return x>=0 && y>=0 && x<GRID_W && y<GRID_H; }
  function key(x,y){ return x + "," + y; }
  function parseKey(k){ const [x,y]=k.split(",").map(Number); return {x,y}; }
  function manhattan(a,b){ return Math.abs(a.x-b.x)+Math.abs(a.y-b.y); }
  function randInt(n){ return Math.floor(Math.random()*n); }
  function randBetween(min,max){ return min + randInt(max - min + 1); }

  /***********************************************************************
   * DOM handles
   ***********************************************************************/
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");

  canvas.width = CANVAS_W;
  canvas.height = CANVAS_H;

  const elCurPlayer = null;
  const elDay = null;
  const elP1Funds = document.getElementById("p1Funds");
  const elP2Funds = document.getElementById("p2Funds");
  const p1TopIncome = document.getElementById("p1TopIncome");
  const p2TopIncome = document.getElementById("p2TopIncome");
  const p1TopCOName = document.getElementById("p1TopCOName");
  const p2TopCOName = document.getElementById("p2TopCOName");
  const p1TopAvatar = document.getElementById("p1TopAvatar");
  const p2TopAvatar = document.getElementById("p2TopAvatar");
  const p1Card = document.getElementById("p1Card");
  const p2Card = document.getElementById("p2Card");
  const p1NameLabel = document.getElementById("p1NameLabel");
  const p2NameLabel = document.getElementById("p2NameLabel");
  const p1TopTooltip = document.getElementById("p1TopTooltip");
  const p2TopTooltip = document.getElementById("p2TopTooltip");
  const p1TopActions = document.getElementById("p1TopActions");
  const p2TopActions = document.getElementById("p2TopActions");
  const p1TopPower = document.getElementById("p1TopPower");
  const p2TopPower = document.getElementById("p2TopPower");
  const p1TopSuper = document.getElementById("p1TopSuper");
  const p2TopSuper = document.getElementById("p2TopSuper");
  const p1TopMeterFill = document.getElementById("p1TopMeterFill");
  const p2TopMeterFill = document.getElementById("p2TopMeterFill");
  const panelEl = document.getElementById("panel");
  function showTooltip(tt, anchor){
    if(!tt || !anchor || !panelEl) return;
    const panelRect = panelEl.getBoundingClientRect();
    const anchorRect = anchor.getBoundingClientRect();
    tt.style.position = "fixed";
    tt.style.top = `${anchorRect.bottom + 8}px`;
    let center = panelRect.left + panelRect.width/2;
    if(p1Card && p2Card){
      const r1 = p1Card.getBoundingClientRect();
      const r2 = p2Card.getBoundingClientRect();
      center = (r1.left + r2.right) / 2;
    }
    const width = tt.offsetWidth || 260;
    tt.style.left = `${center - width/2}px`;
    tt.classList.add("show");
  }
  function hideTooltip(tt){
    if(tt) tt.classList.remove("show");
  }

  const endTurnBtn = document.getElementById("endTurnBtn");
  const newBtn = document.getElementById("newBtn");
  const resetBtn = document.getElementById("resetBtn");
  const openShopBtn = document.getElementById("openShopBtn");
  const unselectBtn = document.getElementById("unselectBtn");
  const moveBtn = document.getElementById("moveBtn");
  const dmgBtn = document.getElementById("dmgBtn");
  const rangeBtn = document.getElementById("rangeBtn");
  const atkInfoBtn = document.getElementById("atkInfoBtn");
  const startFundsInput = document.getElementById("startFundsInput");
  const cityIncomeInput = document.getElementById("cityIncomeInput");
  const defaultIncomeInput = document.getElementById("defaultIncomeInput");
  const mapSettingsBtn = document.getElementById("mapSettingsBtn");
  const mapSettingsBox = document.getElementById("mapSettingsBox");

  const elSelHint = document.getElementById("selHint");
  const elSelKv = document.getElementById("selKv");
  const elSelStats = document.getElementById("selStats");

  const p1COName = document.getElementById("p1COName");
  const p2COName = document.getElementById("p2COName");
  const p1COSpecialty = document.getElementById("p1COSpecialty");
  const p2COSpecialty = document.getElementById("p2COSpecialty");
  const p1COPower = document.getElementById("p1COPower");
  const p2COPower = document.getElementById("p2COPower");
  const p1COSuper = document.getElementById("p1COSuper");
  const p2COSuper = document.getElementById("p2COSuper");
  const p1COAvatar = document.getElementById("p1COAvatar");
  const p2COAvatar = document.getElementById("p2COAvatar");
  const p1ChooseCO = document.getElementById("p1ChooseCO");
  const p2ChooseCO = document.getElementById("p2ChooseCO");
  const p1COCard = document.getElementById("p1COCard");
  const p2COCard = document.getElementById("p2COCard");
  const p1MeterFill = document.getElementById("p1MeterFill");
  const p2MeterFill = document.getElementById("p2MeterFill");
  const p1MeterLabel = document.getElementById("p1MeterLabel");
  const p2MeterLabel = document.getElementById("p2MeterLabel");
  const p1PowerBtn = document.getElementById("p1PowerBtn");
  const p2PowerBtn = document.getElementById("p2PowerBtn");
  const p1SuperBtn = document.getElementById("p1SuperBtn");
  const p2SuperBtn = document.getElementById("p2SuperBtn");

  const coModal = document.getElementById("coModal");
  const coModalHint = document.getElementById("coModalHint");
  const coList = document.getElementById("coList");
  const closeCoModal = document.getElementById("closeCoModal");

  const turnOverlay = document.getElementById("turnOverlay");
  const turnOverlayBox = document.getElementById("turnOverlayBox");
  const turnOverlayPlayer = document.getElementById("turnOverlayPlayer");
  const turnOverlayDay = document.getElementById("turnOverlayDay");
  const turnOverlayIncome = document.getElementById("turnOverlayIncome");
  const mapModal = document.getElementById("mapModal");
  const mapList = document.getElementById("mapList");
  const applyCustomMapBtn = document.getElementById("applyCustomMap");
  const closeMapModal = document.getElementById("closeMapModal");
  const customPalette = document.getElementById("customPalette");
  const customGridEl = document.getElementById("customGrid");
  const damagePreviewEl = document.getElementById("damagePreview");
  const botHumanBtn = document.getElementById("botHumanBtn");
  const botEasyBtn = document.getElementById("botEasyBtn");
  const botMedBtn = document.getElementById("botMedBtn");
  const botHardBtn = document.getElementById("botHardBtn");
  const fillPlainsBtn = document.getElementById("fillPlains");
  const resetCustomBtn = document.getElementById("resetCustom");

  let coModalTarget = null;
  let turnOverlayTimer = null;
  let sKeyHeld = false, sBtnHeld = false;
  let dKeyHeld = false, dBtnHeld = false;
  let mKeyHeld = false, mBtnHeld = false;
  const SAVE_KEY = "aw2_save_v1";
  let nameEditActive = false;
  let qKeyHeld = false;

  const shopBox = document.getElementById("shopBox");
  const shopList = document.getElementById("shopList");
  const closeShopBtn = document.getElementById("closeShopBtn");
  const shopHint = document.getElementById("shopHint");

  const keyBtn = document.getElementById("keyBtn");
  const keyBox = document.getElementById("keyBox");
  const closeKeyBtn = document.getElementById("closeKeyBtn");
  const terrainLegend = document.getElementById("terrainLegend");
  const unitLegend = document.getElementById("unitLegend");

  const logBox = document.getElementById("log");
  const helpBox = document.getElementById("help");
  const lowerPanels = document.getElementById("lowerPanels");
  const battleOverlay = document.getElementById("battleOverlay");
  const battleLeftImg = document.getElementById("battleLeftImg");
  const battleRightImg = document.getElementById("battleRightImg");
  const battleLeftHP = document.getElementById("battleLeftHP");
  const battleRightHP = document.getElementById("battleRightHP");
  const battleLeftLabel = document.getElementById("battleLeftLabel");
  const battleRightLabel = document.getElementById("battleRightLabel");
  const battleLeftDmg = document.getElementById("battleLeftDmg");
  const battleRightDmg = document.getElementById("battleRightDmg");

  /***********************************************************************
   * Game State
   ***********************************************************************/
  const Game = {
    day: 1,
    currentPlayer: 1,
    funds: { 1: 5000, 2: 5000 },
    startFunds: 5000,
    cityIncome: 1000,
    baseIncome: 0,

    terrain: [],
    buildings: [],

    units: [],

    sel: null,              // { type:"unit"/"building"/"tile", ... }
    phase: "IDLE",          // IDLE | MOVING | ATTACKING | SHOP
    moveMap: null,
    moveTiles: new Set(),
    path: [],
    atkTiles: new Set(),
    baseCycleIdx: { 1:0, 2:0 },

    hovered: { x:-1, y:-1 },
    gameOver: false,

    coChoice: { 1:"ANDY", 2:"ANDY" },
    coMeter: { 1:0, 2:0 },
    coState: { 1:null, 2:null },
    dmgDetail: false,
    selectedMap: "CLASSIC",
    customMapText: "",
    winner: null,
    winReason: null,
    botMode: "HUMAN", // HUMAN | EASY | MED | HARD
    shopCategory: "LAND"
  };

  /***********************************************************************
   * Entities
   ***********************************************************************/
  let UNIT_ID_SEQ = 1;

  function makeUnit(typeId, owner, x, y){
    const def = UNIT_DEF[typeId];
    const spriteList = getSpriteList(typeId, owner);
    const spriteIdx = typeId==="INF" && spriteList.length>1 ? randInt(spriteList.length) : 0;
    return {
      uid: UNIT_ID_SEQ++,
      typeId,
      def,
      owner,
      x, y,
      hp: def.maxHP,
      moved: false,
      acted: false,
      actionsLeft: 1,
      spriteIdx,
      cargo: def.transport ? [] : null
    };
  }

  function unitAt(x,y){
    for(const u of Game.units){
      if(u.x===x && u.y===y) return u;
    }
    return null;
  }

  function buildingAt(x,y){
    if(!inBounds(x,y)) return null;
    return Game.buildings[y][x];
  }

  function terrainAt(x,y){
    if(!inBounds(x,y)) return TERRAIN.WATER;
    return Game.terrain[y][x];
  }

  function getSpriteList(typeId, ownerId){
    const byType = SPRITE_IMAGES[typeId];
    if(!byType) return [];
    return byType[ownerId] || [];
  }

  function getBuildingSprite(kindId, ownerId){
    const byKind = BUILDING_IMAGES[kindId];
    if(!byKind) return null;
    const key = (ownerId && byKind[ownerId]) ? ownerId : 0;
    return byKind[key] || null;
  }

  function getTerrainSprite(id){
    return TERRAIN_IMAGES[id] || null;
  }

  function makeBuildingNode(kindId, ownerId, size){
    const img = document.createElement("img");
    const sprite = getBuildingSprite(kindId, ownerId);
    if(sprite) img.src = sprite.src;
    img.width = size;
    img.height = size;
    img.className = "thumb";
    img.style.objectFit = "contain";
    img.style.background = "#0b1433";
    img.style.imageRendering = "pixelated";
    return img;
  }

  function makeTerrainNode(terrain, size){
    const img = document.createElement("img");
    const sprite = getTerrainSprite(terrain.id);
    if(sprite) img.src = sprite.src;
    img.width = size;
    img.height = size;
    img.className = "thumb";
    img.style.objectFit = "cover";
    img.style.imageRendering = "pixelated";
    return img;
  }

  function getUnitSpriteSrc(u){
    const list = getSpriteList(u.typeId, u.owner);
    if(!list.length) return "";
    const img = list[u.spriteIdx % list.length];
    return img ? img.src : "";
  }

  function getOwnedProduction(playerId){
    const bases = [];
    for(let y=0;y<GRID_H;y++){
      for(let x=0;x<GRID_W;x++){
        const b = buildingAt(x,y);
        if(b && PRODUCTION_BUILDINGS.has(b.kindId) && b.owner===playerId){
          bases.push({b,x,y});
        }
      }
    }
    bases.sort((a,b)=> (a.y - b.y) || (a.x - b.x));
    return bases;
  }

  function pickNextBase(playerId){
    const bases = getOwnedProduction(playerId);
    if(!bases.length) return null;
    const idx = Game.baseCycleIdx[playerId] ?? 0;
    const choice = bases[idx % bases.length];
    Game.baseCycleIdx[playerId] = (idx + 1) % bases.length;
    return choice;
  }

  function autoOpenShopForCurrentPlayer(){
    if(Game.gameOver) return;
    const choice = pickNextBase(Game.currentPlayer);
    if(!choice) return;
    selectBuilding(choice.b, choice.x, choice.y);
    openShopIfOnOwnedBase();
  }

  /***********************************************************************
   * Bot Helpers
   ***********************************************************************/
  function isBotActiveForPlayer(pid){
    return pid===2 && Game.botMode && Game.botMode!=="HUMAN";
  }

  function allUnits(playerId){
    return Game.units.filter(u=>u.owner===playerId);
  }

  function nearestEnemy(u){
    let best=null, bestDist=1e9;
    for(const e of Game.units){
      if(e.owner===u.owner) continue;
      const d = manhattan({x:u.x,y:u.y},{x:e.x,y:e.y});
      if(d<bestDist){ bestDist=d; best=e; }
    }
    return best;
  }

  function reachableTilesFor(u){
    const tiles = new Set();
    const dist = new Map();
    const start = key(u.x,u.y);
    dist.set(start,0);
    tiles.add(start);
    const pq=[{k:start,c:0}];
    while(pq.length){
      const cur = pq.shift();
      const {x,y} = parseKey(cur.k);
      for(const d of DIRS){
        const nx=x+d.dx, ny=y+d.dy;
        if(!inBounds(nx,ny)) continue;
        const step = movementCost(u,nx,ny);
        if(step>=99) continue;
        if(isTileBlockedForMovement(nx,ny,u)) continue;
        const nc = cur.c + step;
        if(nc>unitMovePoints(u)) continue;
        const nk = key(nx,ny);
        if(!dist.has(nk) || nc<dist.get(nk)){
          dist.set(nk,nc);
          tiles.add(nk);
          pq.push({k:nk,c:nc});
        }
      }
    }
    return tiles;
  }

  function botPickMove(u, difficulty){
    const tiles = reachableTilesFor(u);
    if(!tiles.size) return {x:u.x,y:u.y};
    if(difficulty==="EASY"){
      const arr=[...tiles];
      const k=arr[randInt(arr.length)];
      return parseKey(k);
    }
    const target = nearestEnemy(u);
    if(!target) return {x:u.x,y:u.y};
    let best = {k:key(u.x,u.y), dist:1e9};
    for(const k of tiles){
      const {x,y} = parseKey(k);
      const d = manhattan({x,y},{x:target.x,y:target.y});
      if(d<best.dist){
        best={k, dist:d};
      }
    }
    return parseKey(best.k);
  }

  function botChooseAttack(u){
    const tiles = computeAttackTilesFromPosition(u, {x:u.x,y:u.y});
    let best=null;
    for(const k of tiles){
      if(!enemyInRangeAt(u,k)) continue;
      const t = unitAt(parseKey(k).x, parseKey(k).y);
      if(!t) continue;
      const dmg = computeDamageMinMax(u,t).max;
      if(!best || dmg > best.dmg){ best={k, tgt:t, dmg}; }
    }
    return best;
  }

  async function botTryAttack(u){
    const choice = botChooseAttack(u);
    if(choice){
      await performAttack(u, choice.tgt);
      return true;
    }
    return false;
  }

  function botTryMove(u, difficulty){
    const dest = botPickMove(u, difficulty);
    if(dest.x===u.x && dest.y===u.y) return false;
    if(unitAt(dest.x,dest.y)) return false;
    const path = [key(u.x,u.y), key(dest.x,dest.y)].map(parseKey);
    u.x = dest.x; u.y = dest.y;
    u.animMove = { path, start: performance.now(), step: 500 };
    u.moved = true;
    return true;
  }

  function botTryBuy(difficulty){
    if(Game.gameOver) return;
    const ownedBases = getOwnedProduction(2).filter(entry=>allowedCategoriesForBuilding(entry.b,2).includes("LAND"));
    const emptyBases = ownedBases.filter(b=>!unitAt(b.x,b.y));
    if(!emptyBases.length) return;
    const roll = Math.random();
    if(difficulty==="EASY" && roll>0.25) return;
    if(difficulty==="MED" && roll>0.6) return;
    // HARD buys often
    const choice = emptyBases[randInt(emptyBases.length)];
    const order = difficulty==="EASY" ? ["INF","RECON","TANK"] :
                  difficulty==="MED" ? ["TANK","ART","INF","RECON","MDT"] :
                  ["TANK","ART","MDT","INF","RECON","RKT"];
    for(const id of order){
      const cost = getUnitCost(UNIT_DEF[id],2);
      if(Game.funds[2] >= cost){
        buildUnitAtBase(id, choice.x, choice.y);
        break;
      }
    }
  }

  function botMaybeUsePower(difficulty){
    if(difficulty!=="HARD") return;
    const meter = Game.coMeter[2] ?? 0;
    if(meter>=CO_POWER_COST){
      useCOPower(2,"POWER");
    }
  }

  async function runBotTurn(difficulty){
    // simple async loop: move/attack units then buy then end turn
    if(Game.gameOver || Game.currentPlayer!==2) return;
    botMaybeUsePower(difficulty);
    const units = allUnits(2);
    for(const u of units){
      if(Game.gameOver) break;
      if(u.acted && u.moved) continue;
      const acted = await botTryAttack(u);
      await new Promise(r=>setTimeout(r, 180)); 
      if(!acted){
        botTryMove(u, difficulty);
        await botTryAttack(u);
      }
    }
    botTryBuy(difficulty);
    await new Promise(r=>setTimeout(r, 180));
    if(!Game.gameOver) endTurn();
  }

  function makeSpriteNode(typeId, ownerId, size){
    const img = new Image();
    const list = getSpriteList(typeId, ownerId);
    img.src = list[0]?.src || "";
    img.width = size;
    img.height = size;
    img.style.imageRendering = "pixelated";
    img.style.borderRadius = "8px";
    img.style.border = "1px solid #23346b";
    img.style.background = "#0b1433";
    return img;
  }

  function removeUnit(u){
    const idx = Game.units.findIndex(z => z.uid===u.uid);
    if(u.cargo){
      const cargos = Array.isArray(u.cargo) ? u.cargo : [u.cargo];
      for(const c of cargos){
        if(c) logLine(`${c.def?.name || c.typeId} lost with ${u.def.name}.`, c.owner);
      }
      u.cargo = Array.isArray(u.cargo) ? [] : null;
    }
    if(idx>=0) Game.units.splice(idx,1);
  }

  function owningPlayer(id){ return PLAYERS.find(p=>p.id===id) || PLAYERS[0]; }
  function setPlayerName(id, name, force=false){
    const clean = (name || "").trim() || `Player ${id}`;
    const p = PLAYERS.find(x=>x.id===id);
    if(p) p.name = clean;
    if(id===1 && p1NameLabel && (force || !p1NameLabel.dataset.editing)) p1NameLabel.textContent = clean;
    if(id===2 && p2NameLabel && (force || !p2NameLabel.dataset.editing)) p2NameLabel.textContent = clean;
  }

  /***********************************************************************
   * Tile defense (stars)
   ***********************************************************************/
  function defenseStarsForTerrainId(id){
    if(id==="ROAD" || id==="WATER") return 0; // road/bridge/water = 0
    if(id==="PLAINS") return 1;
    if(id==="FOREST") return 2;
    if(id==="MOUNTAIN") return 4;
    return 0;
  }

  function tileDefenseStat(x,y){
    const b = buildingAt(x,y);
    if(b){
      if(b.kindId==="HQ") return 4;
      if(b.kindId==="BASE" || b.kindId==="CITY" || b.kindId==="AIRPORT" || b.kindId==="SHIPPORT") return 3;
      return 0;
    }
    const t = terrainAt(x,y);
    if(!t) return 0;
    return defenseStarsForTerrainId(t.id);
  }

  /***********************************************************************
   * Map Generation
   ***********************************************************************/
  function initEmptyLayers(){
    Game.terrain = Array.from({length:GRID_H}, ()=>Array.from({length:GRID_W}, ()=>TERRAIN.PLAINS));
    Game.buildings = Array.from({length:GRID_H}, ()=>Array.from({length:GRID_W}, ()=>null));
  }

  function makeCharGrid(fill="."){
    return Array.from({length:GRID_H}, ()=>Array.from({length:GRID_W}, ()=>fill));
  }
  function setChar(grid, x, y, ch){
    if(!grid || !grid[y] || grid[y][x]===undefined) return;
    grid[y][x] = ch;
  }
  function mirrorChars(grid, points, ch){
    for(const p of points){
      setChar(grid, p.x, p.y, ch);
      setChar(grid, GRID_W-1-p.x, GRID_H-1-p.y, ch);
    }
  }

  function placeBuilding(x,y, kindId, owner=null){
    Game.buildings[y][x] = {
      kindId,
      def: BUILDING[kindId],
      owner,
      capturePoints: 20
    };
  }

  function generateMapClassic(){
    initEmptyLayers();

    for(let y=0;y<GRID_H;y++){
      for(let x=0;x<GRID_W;x++){
        Game.terrain[y][x] = TERRAIN.PLAINS;
      }
    }

    const roadY = 5;
    for(let x=1;x<GRID_W-1;x++){
      Game.terrain[roadY][x] = TERRAIN.ROAD;
      Game.terrain[roadY+1][x] = TERRAIN.ROAD;
    }

    const forests = [
      {x:3,y:2},{x:4,y:2},{x:3,y:3},
      {x:11,y:2},{x:12,y:2},{x:12,y:3},
      {x:2,y:9},{x:3,y:9},{x:3,y:8},
      {x:12,y:9},{x:13,y:9},{x:12,y:8}
    ];
    for(const p of forests){
      if(inBounds(p.x,p.y)) Game.terrain[p.y][p.x] = TERRAIN.FOREST;
    }

    const mountains = [
      {x:7,y:2},{x:8,y:2},
      {x:7,y:9},{x:8,y:9},
      {x:7,y:5},{x:8,y:6}
    ];
    for(const p of mountains){
      if(inBounds(p.x,p.y)) Game.terrain[p.y][p.x] = TERRAIN.MOUNTAIN;
    }

    for(let x=0;x<3;x++){
      Game.terrain[0][x] = TERRAIN.WATER;
      Game.terrain[0][GRID_W-1-x] = TERRAIN.WATER;
      Game.terrain[GRID_H-1][x] = TERRAIN.WATER;
      Game.terrain[GRID_H-1][GRID_W-1-x] = TERRAIN.WATER;
    }

    placeBuilding(1,1,"HQ",1);
    placeBuilding(GRID_W-2, GRID_H-2, "HQ", 2);

    placeBuilding(2,1,"BASE",1);
    placeBuilding(1,2,"BASE",1);

    placeBuilding(GRID_W-3, GRID_H-2,"BASE",2);
    placeBuilding(GRID_W-2, GRID_H-3,"BASE",2);

    const cities = [
      {x:5,y:3},{x:10,y:3},
      {x:5,y:8},{x:10,y:8},
      {x:7,y:6},{x:8,y:5},
      {x:2,y:6},{x:13,y:6}
    ];
    for(const c of cities) placeBuilding(c.x,c.y,"CITY",null);
  }

  function generateMapRiverRun(){
    initEmptyLayers();
    for(let y=0;y<GRID_H;y++){
      for(let x=0;x<GRID_W;x++){
        Game.terrain[y][x] = (x===Math.floor(GRID_W/2)) ? TERRAIN.WATER : TERRAIN.PLAINS;
      }
    }
    for(let y=0;y<GRID_H;y++){
      Game.terrain[y][Math.floor(GRID_W/2)-1] = TERRAIN.ROAD;
      Game.terrain[y][Math.floor(GRID_W/2)+1] = TERRAIN.ROAD;
    }
    const forests = [
      {x:3,y:3},{x:4,y:4},{x:11,y:7},{x:12,y:6},{x:5,y:9},{x:10,y:2},
      {x:2,y:5},{x:13,y:5},{x:4,y:7},{x:11,y:4}
    ];
    for(const p of forests) if(inBounds(p.x,p.y)) Game.terrain[p.y][p.x] = TERRAIN.FOREST;
    const mountains = [{x:7,y:2},{x:8,y:2},{x:7,y:9},{x:8,y:9}];
    for(const p of mountains) if(inBounds(p.x,p.y)) Game.terrain[p.y][p.x] = TERRAIN.MOUNTAIN;
    placeBuilding(1,1,"HQ",1);
    placeBuilding(GRID_W-2, GRID_H-2, "HQ", 2);
    placeBuilding(2,1,"BASE",1);
    placeBuilding(1,2,"BASE",1);
    placeBuilding(GRID_W-3, GRID_H-2,"BASE",2);
    placeBuilding(GRID_W-2, GRID_H-3,"BASE",2);
    const cities = [
      {x:5,y:3},{x:10,y:8},
      {x:5,y:8},{x:10,y:3},
      {x:7,y:6},{x:8,y:5},
      {x:2,y:6},{x:13,y:6},
      {x:7,y:0},{x:8,y:11}
    ];
    for(const c of cities) placeBuilding(c.x,c.y,"CITY",null);
  }

  function generateMapMountainPass(){
    initEmptyLayers();
    for(let y=0;y<GRID_H;y++){
      for(let x=0;x<GRID_W;x++){
        Game.terrain[y][x] = TERRAIN.PLAINS;
      }
    }
    const passCols = [5,6,9,10];
    for(let y=2;y<GRID_H-2;y++){
      for(const x of passCols){
        Game.terrain[y][x] = TERRAIN.MOUNTAIN;
      }
    }
    for(let y=0;y<GRID_H;y++){
      Game.terrain[y][7] = TERRAIN.ROAD;
      Game.terrain[y][8] = TERRAIN.ROAD;
    }
    const forests = [
      {x:2,y:2},{x:3,y:3},{x:12,y:8},{x:11,y:9},{x:4,y:8},{x:11,y:2},
      {x:2,y:7},{x:13,y:4},{x:5,y:5},{x:10,y:6}
    ];
    for(const p of forests) if(inBounds(p.x,p.y)) Game.terrain[p.y][p.x] = TERRAIN.FOREST;
    placeBuilding(1,1,"HQ",1);
    placeBuilding(GRID_W-2, GRID_H-2, "HQ", 2);
    placeBuilding(2,2,"BASE",1);
    placeBuilding(2,3,"BASE",1);
    placeBuilding(GRID_W-3, GRID_H-3,"BASE",2);
    placeBuilding(GRID_W-3, GRID_H-4,"BASE",2);
    const cities = [
      {x:6,y:1},{x:9,y:1},{x:6,y:10},{x:9,y:10},
      {x:4,y:5},{x:11,y:5},{x:7,y:6},{x:8,y:6}
    ];
    for(const c of cities) placeBuilding(c.x,c.y,"CITY",null);
  }

  function generateMapIslandDash(){
    initEmptyLayers();
    for(let y=0;y<GRID_H;y++){
      for(let x=0;x<GRID_W;x++){
        Game.terrain[y][x] = TERRAIN.WATER;
      }
    }
    for(let y=2;y<GRID_H-2;y++){
      for(let x=2;x<GRID_W-2;x++){
        Game.terrain[y][x] = TERRAIN.PLAINS;
      }
    }
    for(let x=2;x<GRID_W-2;x++){
      Game.terrain[5][x] = TERRAIN.ROAD;
      Game.terrain[6][x] = TERRAIN.ROAD;
    }
    const forests = [{x:3,y:3},{x:12,y:3},{x:3,y:8},{x:12,y:8},{x:7,y:5},{x:8,y:6}];
    for(const p of forests) if(inBounds(p.x,p.y)) Game.terrain[p.y][p.x] = TERRAIN.FOREST;
    const mountains = [{x:7,y:3},{x:8,y:3},{x:7,y:8},{x:8,y:8}];
    for(const p of mountains) if(inBounds(p.x,p.y)) Game.terrain[p.y][p.x] = TERRAIN.MOUNTAIN;
    placeBuilding(2,2,"HQ",1);
    placeBuilding(GRID_W-3, GRID_H-3, "HQ", 2);
    placeBuilding(2,3,"BASE",1);
    placeBuilding(3,2,"BASE",1);
    placeBuilding(GRID_W-3, GRID_H-4,"BASE",2);
    placeBuilding(GRID_W-4, GRID_H-3,"BASE",2);
    const cities = [
      {x:5,y:4},{x:10,y:4},{x:5,y:7},{x:10,y:7},
      {x:7,y:4},{x:8,y:4},{x:7,y:7},{x:8,y:7}
    ];
    for(const c of cities) placeBuilding(c.x,c.y,"CITY",null);
  }

  function generateMapUrbanClash(){
    initEmptyLayers();
    for(let y=0;y<GRID_H;y++){
      for(let x=0;x<GRID_W;x++){
        Game.terrain[y][x] = TERRAIN.PLAINS;
      }
    }
    for(let y=3;y<GRID_H-3;y++){
      for(let x=4;x<GRID_W-4;x++){
        if((x+y)%2===0) Game.terrain[y][x] = TERRAIN.ROAD;
      }
    }
    const forests = [{x:2,y:2},{x:13,y:2},{x:2,y:9},{x:13,y:9}];
    forests.push({x:4,y:4},{x:11,y:4},{x:4,y:7},{x:11,y:7});
    for(const p of forests) if(inBounds(p.x,p.y)) Game.terrain[p.y][p.x] = TERRAIN.FOREST;
    const mountains = [{x:7,y:0},{x:8,y:0},{x:7,y:11},{x:8,y:11}];
    for(const p of mountains) if(inBounds(p.x,p.y)) Game.terrain[p.y][p.x] = TERRAIN.MOUNTAIN;
    placeBuilding(1,5,"HQ",1);
    placeBuilding(GRID_W-2, GRID_H-6, "HQ", 2);
    placeBuilding(1,4,"BASE",1);
    placeBuilding(1,6,"BASE",1);
    placeBuilding(GRID_W-2, GRID_H-7,"BASE",2);
    placeBuilding(GRID_W-2, GRID_H-5,"BASE",2);
    const cities = [];
    for(let x=4;x<GRID_W-4;x+=2){
      cities.push({x,y:2},{x,y:9});
    }
    cities.push({x:7,y:5},{x:8,y:6});
    for(const c of cities) placeBuilding(c.x,c.y,"CITY",null);
  }

  function generateMapBridgeBlitz(){
    initEmptyLayers();
    for(let y=0;y<GRID_H;y++){
      for(let x=0;x<GRID_W;x++){
        Game.terrain[y][x] = TERRAIN.PLAINS;
      }
    }
    for(let y=0;y<GRID_H;y++){
      Game.terrain[y][6] = TERRAIN.WATER;
      Game.terrain[y][9] = TERRAIN.WATER;
      Game.terrain[y][7] = TERRAIN.ROAD;
      Game.terrain[y][8] = TERRAIN.ROAD;
    }
    const forests = [
      {x:2,y:2},{x:3,y:3},{x:12,y:2},{x:13,y:3},
      {x:2,y:8},{x:3,y:9},{x:12,y:8},{x:13,y:9},
      {x:6,y:2},{x:6,y:9},{x:9,y:2},{x:9,y:9}
    ];
    for(const p of forests) if(inBounds(p.x,p.y)) Game.terrain[p.y][p.x] = TERRAIN.FOREST;
    const mountains = [{x:7,y:5},{x:8,y:6}];
    for(const p of mountains) if(inBounds(p.x,p.y)) Game.terrain[p.y][p.x] = TERRAIN.MOUNTAIN;
    placeBuilding(1,5,"HQ",1);
    placeBuilding(GRID_W-2, GRID_H-6,"HQ",2);
    placeBuilding(2,5,"BASE",1);
    placeBuilding(1,6,"BASE",1);
    placeBuilding(GRID_W-3, GRID_H-6,"BASE",2);
    placeBuilding(GRID_W-2, GRID_H-7,"BASE",2);
    const cities = [
      {x:4,y:2},{x:11,y:2},{x:4,y:9},{x:11,y:9},
      {x:7,y:3},{x:8,y:3},{x:7,y:8},{x:8,y:8},
      {x:5,y:6},{x:10,y:6}
    ];
    for(const c of cities) placeBuilding(c.x,c.y,"CITY",null);
  }

  function generateMapSkyRidge(){
    const g = makeCharGrid(".");
    for(let x=2;x<14;x++){
      setChar(g,x,5,"=");
      setChar(g,x,6,"=");
    }
    mirrorChars(g, [
      {x:6,y:2},{x:7,y:3},{x:8,y:4},{x:9,y:5},
      {x:6,y:7},{x:7,y:8},{x:5,y:6},{x:8,y:7}
    ], "m");
    mirrorChars(g, [
      {x:3,y:4},{x:5,y:3},{x:4,y:5},{x:3,y:7},{x:5,y:8}
    ], "f");
    mirrorChars(g, [
      {x:4,y:4},{x:7,y:5},{x:8,y:6},{x:2,y:7}
    ], "c");

    setChar(g,1,1,"H");
    setChar(g,14,10,"R");
    setChar(g,2,1,"1");
    setChar(g,1,3,"1");
    setChar(g,13,10,"2");
    setChar(g,14,8,"2");
    setChar(g,3,5,"P");
    setChar(g,12,6,"q");
    setChar(g,5,2,"c");
    setChar(g,10,9,"c");
    setChar(g,7,5,"c");
    setChar(g,8,6,"c");

    generateCustomMapFromText(gridToText(g));
  }

  function generateMapCliffLanding(){
    const g = makeCharGrid(".");
    for(let y=1;y<GRID_H-1;y++){
      setChar(g,7,y,"=");
      if(y>=3 && y<=8){
        setChar(g,6,y,"=");
        setChar(g,8,y,"=");
      }
    }
    for(let x=3;x<13;x++){
      setChar(g,x,5,"=");
    }
    mirrorChars(g, [
      {x:5,y:1},{x:6,y:2},{x:7,y:3},{x:5,y:4},{x:6,y:5},{x:4,y:6},
      {x:8,y:5},{x:7,y:6}
    ], "m");
    mirrorChars(g, [
      {x:3,y:2},{x:4,y:4},{x:2,y:7},{x:3,y:8},{x:5,y:7}
    ], "f");

    setChar(g,1,2,"H");
    setChar(g,14,9,"R");
    setChar(g,3,2,"1");
    setChar(g,1,4,"1");
    setChar(g,12,9,"2");
    setChar(g,14,7,"2");
    setChar(g,4,5,"P");
    setChar(g,11,6,"q");
    mirrorChars(g, [{x:4,y:2},{x:5,y:3},{x:6,y:8}], "c");
    setChar(g,7,4,"c");
    setChar(g,8,7,"c");

    generateCustomMapFromText(gridToText(g));
  }

  function generateMapSummitRunway(){
    const g = makeCharGrid(".");
    for(let x=0;x<GRID_W;x++){
      if(x>2 && x<13){
        setChar(g,x,5,"=");
        setChar(g,x,6,"=");
      }
    }
    mirrorChars(g, [
      {x:5,y:2},{x:6,y:3},{x:7,y:3},{x:8,y:3},
      {x:5,y:4},{x:9,y:4},{x:5,y:7},{x:9,y:7},
      {x:6,y:8},{x:7,y:8},{x:8,y:8}
    ], "m");
    mirrorChars(g, [
      {x:4,y:2},{x:4,y:8},{x:3,y:5},{x:3,y:6},{x:6,y:5}
    ], "f");
    mirrorChars(g, [
      {x:2,y:9},{x:2,y:2},{x:7,y:5}
    ], "c");

    setChar(g,1,1,"H");
    setChar(g,14,10,"R");
    setChar(g,2,2,"1");
    setChar(g,2,3,"1");
    setChar(g,13,9,"2");
    setChar(g,13,8,"2");
    setChar(g,5,5,"P");
    setChar(g,10,6,"q");
    setChar(g,7,6,"c");
    setChar(g,8,5,"c");

    generateCustomMapFromText(gridToText(g));
  }

  function generateMapHarborSkies(){
    const g = makeCharGrid(".");
    // Wide central sea
    for(let y=1;y<GRID_H-1;y++){
      for(let x=5;x<=10;x++){
        setChar(g,x,y,"~");
      }
    }
    // Narrow mid bridge
    setChar(g,7,5,"=");
    setChar(g,7,6,"=");
    setChar(g,8,5,"=");
    setChar(g,8,6,"=");
    // Coast detailing
    mirrorChars(g, [{x:4,y:3},{x:4,y:8}], "f");
    mirrorChars(g, [{x:3,y:5},{x:4,y:6}], "m");
    mirrorChars(g, [{x:2,y:2},{x:2,y:9},{x:4,y:2},{x:4,y:9}], "c");

    // Key structures
    setChar(g,1,5,"H");
    setChar(g,14,6,"R");
    setChar(g,2,4,"1");
    setChar(g,2,7,"1");
    setChar(g,13,4,"2");
    setChar(g,13,7,"2");
    setChar(g,3,2,"P");
    setChar(g,12,9,"q");
    setChar(g,5,5,"S"); // on water edge
    setChar(g,10,6,"t");
    mirrorChars(g, [{x:2,y:5},{x:3,y:8},{x:5,y:2},{x:5,y:9}], "c");
    setChar(g,7,1,"c");
    setChar(g,8,10,"c");

    generateCustomMapFromText(gridToText(g));
  }

  function generateMapTwinHarbors(){
    const g = makeCharGrid(".");
    // Large central gulf with thin crossing
    for(let y=1;y<GRID_H-1;y++){
      for(let x=4;x<=11;x++){
        setChar(g,x,y,"~");
      }
    }
    setChar(g,7,4,"=");
    setChar(g,8,4,"=");
    setChar(g,7,7,"=");
    setChar(g,8,7,"=");
    // Terrain on flanks
    mirrorChars(g, [{x:2,y:3},{x:2,y:8}], "m");
    mirrorChars(g, [{x:3,y:5},{x:3,y:6}], "f");
    mirrorChars(g, [{x:1,y:2},{x:1,y:9}], "c");

    setChar(g,1,5,"H");
    setChar(g,14,6,"R");
    setChar(g,2,4,"1");
    setChar(g,2,7,"1");
    setChar(g,13,4,"2");
    setChar(g,13,7,"2");
    setChar(g,2,2,"P");
    setChar(g,13,9,"q");
    setChar(g,4,6,"S");
    setChar(g,11,5,"t");
    mirrorChars(g, [{x:2,y:6},{x:3,y:2},{x:3,y:9}], "c");
    setChar(g,7,1,"c");
    setChar(g,8,10,"c");

    generateCustomMapFromText(gridToText(g));
  }

  function generateMapIslandWings(){
    const g = makeCharGrid(".");
    // Oceanic center with small bridge
    for(let y=0;y<GRID_H;y++){
      for(let x=4;x<=11;x++){
        setChar(g,x,y,"~");
      }
    }
    setChar(g,7,5,"=");
    setChar(g,8,6,"=");
    // Coast and high ground on sides
    mirrorChars(g, [{x:2,y:3},{x:2,y:8}], "m");
    mirrorChars(g, [{x:1,y:4},{x:1,y:7}], "f");

    setChar(g,1,5,"H");
    setChar(g,14,6,"R");
    setChar(g,2,4,"1");
    setChar(g,2,7,"1");
    setChar(g,13,4,"2");
    setChar(g,13,7,"2");
    setChar(g,2,2,"P");
    setChar(g,13,9,"q");
    setChar(g,4,6,"S");
    setChar(g,11,5,"t");
    mirrorChars(g, [{x:3,y:2},{x:3,y:9},{x:6,y:5}], "c");
    setChar(g,7,1,"c");
    setChar(g,8,10,"c");

    generateCustomMapFromText(gridToText(g));
  }

  function generateMapGrandArmada(){
    const g = makeCharGrid(".");
    for(let y=2;y<=9;y++){
      if(y>=4 && y<=7){
        for(let x=6;x<=9;x++) setChar(g,x,y,"~");
      } else {
        setChar(g,7,y,"~");
        setChar(g,8,y,"~");
      }
    }
    mirrorChars(g, [
      {x:4,y:2},{x:5,y:3},{x:4,y:4},{x:5,y:8},{x:4,y:9}
    ], "m");
    mirrorChars(g, [
      {x:3,y:5},{x:3,y:6},{x:6,y:2},{x:6,y:9}
    ], "f");
    for(let x=0;x<GRID_W;x++){
      setChar(g,x,1,"=");
      setChar(g,x,10,"=");
    }

    setChar(g,1,1,"H");
    setChar(g,14,10,"R");
    setChar(g,2,2,"1");
    setChar(g,2,4,"1");
    setChar(g,13,9,"2");
    setChar(g,13,7,"2");
    setChar(g,4,5,"P");
    setChar(g,11,6,"q");
    setChar(g,6,5,"S");
    setChar(g,9,6,"t");
    mirrorChars(g, [{x:5,y:1},{x:5,y:10},{x:7,y:5}], "c");
    setChar(g,8,6,"c");

    generateCustomMapFromText(gridToText(g));
  }

  function generateMapFjordFront(){
    const g = makeCharGrid(".");
    // Wide central fjord; only tiny crossings
    for(let y=1;y<GRID_H-1;y++){
      for(let x=4;x<=11;x++){
        setChar(g,x,y,"~");
      }
    }
    // Staggered bridges to keep naval focus
    setChar(g,7,3,"=");
    setChar(g,8,8,"=");

    mirrorChars(g, [
      {x:3,y:2},{x:3,y:9}
    ], "m");
    mirrorChars(g, [
      {x:2,y:3},{x:2,y:8}
    ], "f");

    setChar(g,1,1,"H");
    setChar(g,14,10,"R");
    setChar(g,2,2,"1");
    setChar(g,2,3,"1");
    setChar(g,13,9,"2");
    setChar(g,13,8,"2");
    setChar(g,4,4,"P");
    setChar(g,11,7,"q");
    setChar(g,5,6,"S");
    setChar(g,10,5,"t");
    mirrorChars(g, [{x:3,y:6},{x:5,y:2},{x:5,y:9}], "c");
    setChar(g,7,5,"c");

    generateCustomMapFromText(gridToText(g));
  }

  function generateMapArchipelagoFront(){
    const g = makeCharGrid(".");
    // Broad middle sea; minimal land crossovers
    for(let y=1;y<GRID_H-1;y++){
      for(let x=3;x<=12;x++){
        setChar(g,x,y,"~");
      }
    }
    setChar(g,7,5,"=");
    setChar(g,8,6,"=");
    mirrorChars(g, [
      {x:2,y:3},{x:2,y:8}
    ], "m");
    mirrorChars(g, [
      {x:1,y:4},{x:1,y:7}
    ], "f");

    setChar(g,1,1,"H");
    setChar(g,14,10,"R");
    setChar(g,2,2,"1");
    setChar(g,2,4,"1");
    setChar(g,13,9,"2");
    setChar(g,13,7,"2");
    setChar(g,3,2,"P");
    setChar(g,12,9,"q");
    setChar(g,4,6,"S");
    setChar(g,11,5,"t");
    mirrorChars(g, [{x:2,y:6},{x:3,y:2},{x:3,y:9}], "c");
    setChar(g,7,1,"c");
    setChar(g,8,10,"c");

    generateCustomMapFromText(gridToText(g));
  }

  function generateCustomMapFromText(text){
    initEmptyLayers();
    const parsed = parseCustomText(text || DEFAULT_CUSTOM_MAP);
    customGrid = parsed.terrain;
    customUnits = parsed.units;

    for(let y=0;y<GRID_H;y++){
      for(let x=0;x<GRID_W;x++){
        const ch = customGrid[y][x] ?? ".";
        const tId = terrainIdFromChar(ch);
        Game.terrain[y][x] = TERRAIN[tId] || TERRAIN.PLAINS;

        const bInfo = buildingFromChar(ch);
        if(bInfo){
          placeBuilding(x,y,bInfo.kind,bInfo.owner);
          if(bInfo.kind==="SHIPPORT"){
            Game.terrain[y][x] = TERRAIN.WATER;
          } else if(bInfo.kind==="AIRPORT"){
            Game.terrain[y][x] = TERRAIN.PLAINS;
          }
        }
      }
    }
    // Ensure HQs exist
    const hasHQ1 = Game.buildings.flat().some(b=>b && b.kindId==="HQ" && b.owner===1);
    const hasHQ2 = Game.buildings.flat().some(b=>b && b.kindId==="HQ" && b.owner===2);
    if(!hasHQ1) placeBuilding(1,1,"HQ",1);
    if(!hasHQ2) placeBuilding(GRID_W-2, GRID_H-2,"HQ",2);

    // Place starting units from custom layer
    for(let y=0;y<GRID_H;y++){
      for(let x=0;x<GRID_W;x++){
        const u = unitFromChar(customUnits[y][x]);
        if(u){
          Game.units.push(makeUnit(u.unit, u.owner, x, y));
        }
      }
    }
  }

  // Custom map editor state
  const CUSTOM_TILES = [
    { id:"PLAINS", char:".", label:"Plains", color:"#1f4d36", layer:"terrain" },
    { id:"FOREST", char:"f", label:"Forest", color:"#19412d", layer:"terrain" },
    { id:"MOUNTAIN", char:"m", label:"Mountain", color:"#3a3b46", layer:"terrain" },
    { id:"ROAD", char:"=", label:"Road", color:"#3a3f4a", layer:"terrain" },
    { id:"WATER", char:"~", label:"Water", color:"#0f335c", layer:"terrain" },
    { id:"CITY", char:"c", label:"City", color:"#2b3a63", layer:"terrain" },
    { id:"BASE1", char:"1", label:"Base (Blue)", color:"#21406d", layer:"terrain" },
    { id:"BASE2", char:"2", label:"Base (Red)", color:"#6d213b", layer:"terrain" },
    { id:"HQ1", char:"H", label:"HQ (Blue)", color:"#2f4a86", layer:"terrain" },
    { id:"HQ2", char:"R", label:"HQ (Red)", color:"#8a2b2b", layer:"terrain" },
    { id:"AIRPORT", char:"p", label:"Airport (Neutral)", color:"#2c4f78", layer:"terrain" },
    { id:"AIRPORT1", char:"P", label:"Airport (Blue)", color:"#1f5f96", layer:"terrain" },
    { id:"AIRPORT2", char:"q", label:"Airport (Red)", color:"#7a3153", layer:"terrain" },
    { id:"SHIPPORT", char:"s", label:"Ship Port (Neutral)", color:"#18425a", layer:"terrain" },
    { id:"SHIPPORT1", char:"S", label:"Ship Port (Blue)", color:"#1c6a7d", layer:"terrain" },
    { id:"SHIPPORT2", char:"t", label:"Ship Port (Red)", color:"#7d2f46", layer:"terrain" }
  ];

  const CUSTOM_UNITS = [
    { id:"P1_INF",  char:"A", label:"P1 Infantry",  layer:"unit", owner:1, unit:"INF", color:COLORS.p1Dark },
    { id:"P1_RECON",char:"B", label:"P1 Recon",     layer:"unit", owner:1, unit:"RECON", color:COLORS.p1Dark },
    { id:"P1_TANK", char:"C", label:"P1 Tank",      layer:"unit", owner:1, unit:"TANK", color:COLORS.p1Dark },
    { id:"P1_MDT",  char:"D", label:"P1 Md Tank",   layer:"unit", owner:1, unit:"MDT", color:COLORS.p1Dark },
    { id:"P1_ART",  char:"E", label:"P1 Artillery", layer:"unit", owner:1, unit:"ART", color:COLORS.p1Dark },
    { id:"P1_RKT",  char:"F", label:"P1 Rockets",   layer:"unit", owner:1, unit:"RKT", color:COLORS.p1Dark },
    { id:"P1_APC",  char:"G", label:"P1 APC",       layer:"unit", owner:1, unit:"APC", color:COLORS.p1Dark },
    { id:"P1_CRU",  char:"H", label:"P1 Cruiser",   layer:"unit", owner:1, unit:"CRU", color:COLORS.p1Dark },
    { id:"P1_SUB",  char:"I", label:"P1 Submarine", layer:"unit", owner:1, unit:"SUB", color:COLORS.p1Dark },
    { id:"P1_LND",  char:"J", label:"P1 Lander",    layer:"unit", owner:1, unit:"LND", color:COLORS.p1Dark },
    { id:"P1_BSH",  char:"K", label:"P1 Battleship",layer:"unit", owner:1, unit:"BSH", color:COLORS.p1Dark },
    { id:"P1_FTR",  char:"L", label:"P1 Fighter",   layer:"unit", owner:1, unit:"FTR", color:COLORS.p1Dark },
    { id:"P1_BC",   char:"M", label:"P1 B-Copter",  layer:"unit", owner:1, unit:"BC",  color:COLORS.p1Dark },
    { id:"P1_TC",   char:"N", label:"P1 T-Copter",  layer:"unit", owner:1, unit:"TC",  color:COLORS.p1Dark },
    { id:"P1_BMB",  char:"O", label:"P1 Bomber",    layer:"unit", owner:1, unit:"BMB", color:COLORS.p1Dark },
    { id:"P2_INF",  char:"a", label:"P2 Infantry",  layer:"unit", owner:2, unit:"INF", color:COLORS.p2Dark },
    { id:"P2_RECON",char:"b", label:"P2 Recon",     layer:"unit", owner:2, unit:"RECON", color:COLORS.p2Dark },
    { id:"P2_TANK", char:"c", label:"P2 Tank",      layer:"unit", owner:2, unit:"TANK", color:COLORS.p2Dark },
    { id:"P2_MDT",  char:"d", label:"P2 Md Tank",   layer:"unit", owner:2, unit:"MDT", color:COLORS.p2Dark },
    { id:"P2_ART",  char:"e", label:"P2 Artillery", layer:"unit", owner:2, unit:"ART", color:COLORS.p2Dark },
    { id:"P2_RKT",  char:"f", label:"P2 Rockets",   layer:"unit", owner:2, unit:"RKT", color:COLORS.p2Dark },
    { id:"P2_APC",  char:"g", label:"P2 APC",       layer:"unit", owner:2, unit:"APC", color:COLORS.p2Dark },
    { id:"P2_CRU",  char:"h", label:"P2 Cruiser",   layer:"unit", owner:2, unit:"CRU", color:COLORS.p2Dark },
    { id:"P2_SUB",  char:"i", label:"P2 Submarine", layer:"unit", owner:2, unit:"SUB", color:COLORS.p2Dark },
    { id:"P2_LND",  char:"j", label:"P2 Lander",    layer:"unit", owner:2, unit:"LND", color:COLORS.p2Dark },
    { id:"P2_BSH",  char:"k", label:"P2 Battleship",layer:"unit", owner:2, unit:"BSH", color:COLORS.p2Dark },
    { id:"P2_FTR",  char:"l", label:"P2 Fighter",   layer:"unit", owner:2, unit:"FTR", color:COLORS.p2Dark },
    { id:"P2_BC",   char:"m", label:"P2 B-Copter",  layer:"unit", owner:2, unit:"BC",  color:COLORS.p2Dark },
    { id:"P2_TC",   char:"n", label:"P2 T-Copter",  layer:"unit", owner:2, unit:"TC",  color:COLORS.p2Dark },
    { id:"P2_BMB",  char:"o", label:"P2 Bomber",    layer:"unit", owner:2, unit:"BMB", color:COLORS.p2Dark }
  ];

  const CUSTOM_ENTRIES = [...CUSTOM_TILES, ...CUSTOM_UNITS];

  let customGrid = [];
  let customUnits = [];
  let customTileSelection = CUSTOM_TILES[0];

  function gridToText(grid){
    return grid.map(row=>row.join("")).join("\n");
  }

  function gridToTextWithUnits(grid, units){
    const terrainText = gridToText(grid);
    if(!units || !units.length) return terrainText;
    const hasUnits = units.some(row=>row.some(ch=>ch !== "."));
    if(!hasUnits) return terrainText;
    const unitText = gridToText(units);
    return `${terrainText}\n---\n${unitText}`;
  }

  function textToGrid(text, fill="."){
    const out = Array.from({length:GRID_H}, ()=>Array.from({length:GRID_W}, ()=>fill));
    const lines = (text||"").split("\n");
    for(let y=0;y<Math.min(GRID_H, lines.length); y++){
      const row = lines[y];
      for(let x=0;x<Math.min(GRID_W, row.length); x++){
        out[y][x] = row[x] || fill;
      }
    }
    return out;
  }

  function splitCustomText(text){
    const parts = (text||"").split("\n---\n");
    return {
      terrainText: parts[0] || "",
      unitText: parts[1] || ""
    };
  }

  function parseCustomText(text){
    const { terrainText, unitText } = splitCustomText(text);
    return {
      terrain: textToGrid(terrainText, "."),
      units: textToGrid(unitText, ".")
    };
  }

  function tileByChar(ch){
    return CUSTOM_ENTRIES.find(t=>t.char===ch) || CUSTOM_TILES[0];
  }

  function saveGameState(){
    try{
      const data = {
        day: Game.day,
        currentPlayer: Game.currentPlayer,
        funds: Game.funds,
        terrain: Game.terrain.map(row=>row.map(t=>t.id)),
        buildings: Game.buildings.map(row=>row.map(b=> b ? { kindId:b.kindId, owner:b.owner, capturePoints:b.capturePoints } : null)),
        units: Game.units.map(u=>{
          const base = {
            typeId: u.typeId,
            owner: u.owner,
            x: u.x, y: u.y,
            hp: u.hp,
            moved: u.moved,
            acted: u.acted,
            actionsLeft: u.actionsLeft,
            spriteIdx: u.spriteIdx
          };
          if(u.cargo){
            base.cargo = Array.isArray(u.cargo)
              ? u.cargo.map(c=> c ? ({
                typeId: c.typeId,
                owner: c.owner,
                hp: c.hp,
                spriteIdx: c.spriteIdx
              }) : null)
              : {
                typeId: u.cargo.typeId,
                owner: u.cargo.owner,
                hp: u.cargo.hp,
                spriteIdx: u.cargo.spriteIdx
              };
          } else {
            base.cargo = null;
          }
          return base;
        }),
        coChoice: Game.coChoice,
        coMeter: Game.coMeter,
        coState: Game.coState,
        startFunds: Game.startFunds,
        cityIncome: Game.cityIncome,
        baseIncome: Game.baseIncome,
        selectedMap: Game.selectedMap,
        customMapText: Game.customMapText,
        baseCycleIdx: Game.baseCycleIdx,
        gameOver: Game.gameOver,
        winner: Game.winner,
        winReason: Game.winReason
      };
      data.playerNames = {
        1: owningPlayer(1).name,
        2: owningPlayer(2).name
      };
      data.botMode = Game.botMode;
      data.shopCategory = Game.shopCategory;
      localStorage.setItem(SAVE_KEY, JSON.stringify(data));
    } catch(err){
      console.warn("Save failed", err);
    }
  }

  function syncIncomeInputs(){
    if(startFundsInput) startFundsInput.value = Game.startFunds ?? 5000;
    if(cityIncomeInput) cityIncomeInput.value = Game.cityIncome ?? 1000;
    if(defaultIncomeInput) defaultIncomeInput.value = Game.baseIncome ?? 0;
  }

  function applyIncomeInputs(){
    const parseVal = (el, fallback)=>{
      const n = parseInt(el ? el.value : "", 10);
      const val = Number.isFinite(n) ? Math.max(0, n) : fallback;
      if(el) el.value = val;
      return val;
    };
    Game.startFunds = parseVal(startFundsInput, Game.startFunds ?? 5000);
    Game.cityIncome = parseVal(cityIncomeInput, Game.cityIncome ?? 1000);
    Game.baseIncome = parseVal(defaultIncomeInput, Game.baseIncome ?? 0);
    saveGameState();
  }

  function loadGameState(){
    try{
      const raw = localStorage.getItem(SAVE_KEY);
      if(!raw) return false;
      const data = JSON.parse(raw);
      initEmptyLayers();
      Game.day = data.day || 1;
      Game.currentPlayer = data.currentPlayer || 1;
      Game.funds = data.funds || {1:5000,2:5000};
      Game.startFunds = Number.isFinite(data.startFunds) ? data.startFunds : 5000;
      Game.cityIncome = Number.isFinite(data.cityIncome) ? data.cityIncome : 1000;
      Game.baseIncome = Number.isFinite(data.baseIncome) ? data.baseIncome : 0;
      Game.coChoice = data.coChoice || {1:"ANDY",2:"ANDY"};
      Game.coMeter = data.coMeter || {1:0,2:0};
      Game.coState = data.coState || {1:null,2:null};
      Game.selectedMap = data.selectedMap || "CUSTOM";
      Game.customMapText = data.customMapText || DEFAULT_CUSTOM_MAP;
      Game.baseCycleIdx = data.baseCycleIdx || {1:0,2:0};
      Game.gameOver = data.gameOver || false;
      Game.winner = data.winner || null;
      Game.winReason = data.winReason || null;
      Game.botMode = data.botMode || "HUMAN";
      Game.shopCategory = data.shopCategory || "LAND";
      Game.sel = null;
      Game.phase = "IDLE";
      Game.moveMap = null;
      Game.moveTiles = new Set();
      Game.atkTiles = new Set();
      Game.path = [];
      UNIT_ID_SEQ = 1;
      for(let y=0;y<GRID_H;y++){
        for(let x=0;x<GRID_W;x++){
          const tid = (data.terrain && data.terrain[y] && data.terrain[y][x]) || "PLAINS";
          Game.terrain[y][x] = TERRAIN[tid] || TERRAIN.PLAINS;
          const b = data.buildings && data.buildings[y] ? data.buildings[y][x] : null;
          if(b){
            Game.buildings[y][x] = {
              kindId: b.kindId,
              def: BUILDING[b.kindId],
              owner: b.owner ?? null,
              capturePoints: b.capturePoints ?? 20
            };
          }
        }
      }
      Game.units = [];
      if(Array.isArray(data.units)){
        for(const u of data.units){
          const nu = makeUnit(u.typeId, u.owner, u.x, u.y);
          nu.hp = u.hp ?? nu.def.maxHP;
          nu.moved = !!u.moved;
          nu.acted = !!u.acted;
          nu.actionsLeft = u.actionsLeft ?? 1;
          nu.spriteIdx = u.spriteIdx ?? 0;
          if(u.cargo){
            if(Array.isArray(u.cargo)){
              nu.cargo = [];
              for(const c of u.cargo){
                if(!c) continue;
                const def = UNIT_DEF[c.typeId];
                nu.cargo.push({
                  typeId: c.typeId,
                  owner: c.owner,
                  hp: c.hp ?? (def ? def.maxHP : 10),
                  spriteIdx: c.spriteIdx ?? 0,
                  def
                });
              }
            } else {
              const def = UNIT_DEF[u.cargo.typeId];
              nu.cargo = {
                typeId: u.cargo.typeId,
                owner: u.cargo.owner,
                hp: u.cargo.hp ?? (def ? def.maxHP : 10),
                spriteIdx: u.cargo.spriteIdx ?? 0,
                def
              };
            }
          }
          Game.units.push(nu);
        }
      }
      if(data.playerNames){
        if(data.playerNames[1]) setPlayerName(1, data.playerNames[1], true);
        if(data.playerNames[2]) setPlayerName(2, data.playerNames[2], true);
      }
      renderBotButtons();
      syncIncomeInputs();
      updateUI();
      return true;
    } catch(err){
      console.warn("Load failed", err);
      return false;
    }
  }

  function initCustomGridFromText(text){
    const parsed = parseCustomText(text || DEFAULT_CUSTOM_MAP);
    customGrid = parsed.terrain;
    customUnits = parsed.units;
    if(customGridEl){
      renderCustomGrid();
    }
  }

  function terrainIdFromChar(ch){
    if(ch==="s" || ch==="S" || ch==="t") return "WATER";
    if("cbh12HRpPq".includes(ch)) return "PLAINS";
    if(ch==="f") return "FOREST";
    if(ch==="m") return "MOUNTAIN";
    if(ch==="=") return "ROAD";
    if(ch==="~") return "WATER";
    return "PLAINS";
  }

  function terrainCharFromId(id){
    if(id==="FOREST") return "f";
    if(id==="MOUNTAIN") return "m";
    if(id==="ROAD") return "=";
    if(id==="WATER") return "~";
    return ".";
  }

  function buildingFromChar(ch){
    if(ch==="c") return { kind:"CITY", owner:null };
    if(ch==="b") return { kind:"BASE", owner:null };
    if(ch==="1") return { kind:"BASE", owner:1 };
    if(ch==="2") return { kind:"BASE", owner:2 };
    if(ch==="h") return { kind:"HQ", owner:null };
    if(ch==="H") return { kind:"HQ", owner:1 };
    if(ch==="R") return { kind:"HQ", owner:2 };
    if(ch==="p") return { kind:"AIRPORT", owner:null };
    if(ch==="P") return { kind:"AIRPORT", owner:1 };
    if(ch==="q") return { kind:"AIRPORT", owner:2 };
    if(ch==="s") return { kind:"SHIPPORT", owner:null };
    if(ch==="S") return { kind:"SHIPPORT", owner:1 };
    if(ch==="t") return { kind:"SHIPPORT", owner:2 };
    return null;
  }

  function buildingChar(kind, owner){
    if(kind==="CITY") return "c";
    if(kind==="BASE"){
      if(owner===1) return "1";
      if(owner===2) return "2";
      return "b";
    }
    if(kind==="HQ"){
      if(owner===1) return "H";
      if(owner===2) return "R";
      return "h";
    }
    if(kind==="AIRPORT"){
      if(owner===1) return "P";
      if(owner===2) return "q";
      return "p";
    }
    if(kind==="SHIPPORT"){
      if(owner===1) return "S";
      if(owner===2) return "t";
      return "s";
    }
    return null;
  }

  function mapStateToCustomText(){
    const terrainChars = Array.from({length:GRID_H}, ()=>Array.from({length:GRID_W}, ()=>"."));
    for(let y=0;y<GRID_H;y++){
      for(let x=0;x<GRID_W;x++){
        const t = terrainAt(x,y);
        terrainChars[y][x] = terrainCharFromId(t.id);
        const b = buildingAt(x,y);
        if(b){
          const ch = buildingChar(b.kindId, b.owner);
          if(ch) terrainChars[y][x] = ch;
        }
      }
    }
    const emptyUnits = Array.from({length:GRID_H}, ()=>Array.from({length:GRID_W}, ()=>"."));
    return gridToTextWithUnits(terrainChars, emptyUnits);
  }

  function unitFromChar(ch){
    if(!ch || ch===".") return null;
    const unitEntry = CUSTOM_UNITS.find(u=>u.char===ch);
    if(!unitEntry || unitEntry.layer!=="unit") return null;
    return { owner: unitEntry.owner, unit: unitEntry.unit };
  }

  function setTileVisual(cell, terrainChar, unitChar=null){
    if(!cell) return;
    const tId = terrainIdFromChar(terrainChar);
    const t = TERRAIN[tId] || TERRAIN.PLAINS;
    const terrainSprite = getTerrainSprite(t.id);
    const b = buildingFromChar(terrainChar);
    const u = unitFromChar(unitChar);
    const isPalette = cell.classList.contains("tileSwatch");
    const isCustomPreview = cell.classList.contains("customCell"); // custom map grid
    let bg = tileByChar(terrainChar).color;
    const imgs = [];
    const sizes = [];
    const positions = [];

    if(b){
      const sprite = getBuildingSprite(b.kind, b.owner ?? 0);
      if(sprite){
        const paletteSize = (b.kind==="BASE" || b.kind==="HQ") ? "65%" : "70%";
        imgs.push(`url(${sprite.src})`);
        const useSmall = isPalette || isCustomPreview;
        sizes.push(useSmall ? paletteSize : "cover");
        positions.push("center");
      }
    } else if(terrainSprite){
      imgs.push(`url(${terrainSprite.src})`);
      sizes.push("cover");
      positions.push("center");
    }

    if(u){
      const spriteList = getSpriteList(u.unit, u.owner);
      const sprite = spriteList[0];
      if(sprite){
        imgs.unshift(`url(${sprite.src})`);
        sizes.unshift("70%");
        positions.unshift("center");
      }
      const p = owningPlayer(u.owner);
      if(p) bg = p.dark;
    }
    cell.style.backgroundColor = bg;
    cell.style.backgroundImage = imgs.length ? imgs.join(", ") : "none";
    cell.style.backgroundSize = sizes.join(", ") || "cover";
    cell.style.backgroundPosition = positions.join(", ") || "center";
    cell.style.backgroundRepeat = "no-repeat";
    cell.textContent = "";
  }

  function paintCustomCell(x,y){
    if(!customGrid[y] || customGrid[y][x]===undefined) return;
    if(!customUnits[y]) customUnits[y] = Array.from({length:GRID_W}, ()=>".");
    if(customTileSelection.layer==="unit"){
      customUnits[y][x] = customTileSelection.char;
    } else {
      customGrid[y][x] = customTileSelection.char;
    }
    const idx = y*GRID_W + x;
    const cell = customGridEl ? customGridEl.children[idx] : null;
    if(cell){
      setTileVisual(cell, customGrid[y][x], customUnits[y][x]);
    }
  }

  function renderCustomPalette(){
    if(!customPalette) return;
    customPalette.innerHTML = "";

    const makeRow = (items)=>{
      const row = document.createElement("div");
      row.className = "paletteRow";
      for(const t of items){
        const btn = document.createElement("div");
        btn.className = "tileSwatch" + (customTileSelection.id===t.id ? " active" : "");
        if(t.layer==="unit"){
          setTileVisual(btn, ".", t.char);
        } else {
          setTileVisual(btn, t.char);
        }
        btn.title = t.label;
        btn.addEventListener("click", ()=>{
          customTileSelection = t;
          renderCustomPalette();
        });
        row.appendChild(btn);
      }
      return row;
    };

    const terrainRow = makeRow(CUSTOM_TILES.filter(t=>t.id!=="AIRPORT" && t.id!=="SHIPPORT"));
    const p1Row = makeRow(CUSTOM_UNITS.filter(u=>u.owner===1));
    const p2Row = makeRow(CUSTOM_UNITS.filter(u=>u.owner===2));

    customPalette.appendChild(terrainRow);
    customPalette.appendChild(p1Row);
    customPalette.appendChild(p2Row);
  }

  function renderCustomGrid(){
    if(!customGridEl) return;
    customGridEl.innerHTML = "";
    let painting = false;
    const handlePaint = (e)=>{
      const cell = e.target;
      if(!cell.classList.contains("customCell")) return;
      const x = Number(cell.dataset.x);
      const y = Number(cell.dataset.y);
      paintCustomCell(x,y);
    };
    customGridEl.onmousedown = (e)=>{ painting=true; handlePaint(e); };
    customGridEl.onmouseup = ()=>{ painting=false; };
    customGridEl.onmouseleave = ()=>{ painting=false; };
    customGridEl.onmousemove = (e)=>{ if(painting) handlePaint(e); };
    for(let y=0;y<GRID_H;y++){
      for(let x=0;x<GRID_W;x++){
        const cell = document.createElement("div");
        cell.className = "customCell";
        const uChar = (customUnits[y] && customUnits[y][x]) || ".";
        setTileVisual(cell, customGrid[y][x], uChar);
        cell.dataset.x = String(x);
        cell.dataset.y = String(y);
        cell.addEventListener("mousedown", handlePaint);
        customGridEl.appendChild(cell);
      }
    }
    document.addEventListener("mouseup", ()=>{ painting=false; }, { once:true });
  }

  const MAPS = [
    { id:"CLASSIC", name:"Frontline Plains", desc:"Balanced lanes with central roads and forests.", gen:generateMapClassic, img:"assets/frontier.png" },
    { id:"RIVER", name:"River Run", desc:"Split by a river with flanking roads and bridges.", gen:generateMapRiverRun, img:"assets/river.png" },
    { id:"MOUNTAIN", name:"Mountain Pass", desc:"Narrow passes through heavy mountains.", gen:generateMapMountainPass, img:"assets/mountain_map.png" },
    { id:"ISLAND", name:"Island Dash", desc:"Central island brawl surrounded by water.", gen:generateMapIslandDash, img:"assets/island.png" },
    { id:"URBAN", name:"Urban Clash", desc:"Grid of roads and cities for close quarters.", gen:generateMapUrbanClash, img:"assets/urban.png" },
    { id:"BRIDGE", name:"Bridge Blitz", desc:"Two bridges with central high ground and forest flanks.", gen:generateMapBridgeBlitz, img:"assets/bridge.png" },
    { id:"SKYRIDGE", name:"Sky Ridge", desc:"Mountain lanes, double roads, and starting airports.", gen:generateMapSkyRidge, img:"assets/sky_ridge.png" },
    { id:"CLIFF_LANDING", name:"Cliff Landing", desc:"Ridge choke points with cliffside airstrips.", gen:generateMapCliffLanding, img:"assets/cliff.png" },
    { id:"SUMMIT_RUNWAY", name:"Summit Runway", desc:"High-altitude bowl with central runways and peaks.", gen:generateMapSummitRunway, img:"assets/summit.png" },
    { id:"HARBOR_SKIES", name:"Harbor Skies", desc:"Large inland sea with facing ports and airports.", gen:generateMapHarborSkies, img:"assets/harbor.png" },
    { id:"TWIN_HARBORS", name:"Twin Harbors", desc:"Parallel bays for naval play plus paired airstrips.", gen:generateMapTwinHarbors, img:"assets/twin.png" },
    { id:"ISLAND_WINGS", name:"Island Wings", desc:"Outer seas, inner lagoon, and offset airfields.", gen:generateMapIslandWings, img:"assets/island_wings.png" },
    { id:"GRAND_ARMADA", name:"Grand Armada", desc:"Combined-arms lakes with ports, airfields, and ridges.", gen:generateMapGrandArmada, img:"assets/grand_a.png" },
    { id:"FJORD_FRONT", name:"Fjord Front", desc:"Twin fjords split the fronts; every production type is live.", gen:generateMapFjordFront, img:"assets/fjord.png" },
    { id:"ARCHIPELAGO_FRONT", name:"Archipelago Front", desc:"Island clusters with runways and docks for full armies.", gen:generateMapArchipelagoFront, img:"assets/arch_front.png" },
    { id:"CUSTOM", name:"Custom Map", desc:"Use the editor text to build your own layout.", gen:generateCustomMapFromText, img:null }
  ];

  /***********************************************************************
   * Game Initialization / Reset
   ***********************************************************************/
  function loadSprites(){
    for(const [typeId, owners] of Object.entries(SPRITE_SOURCES)){
      SPRITE_IMAGES[typeId] = {};
      for(const [ownerId, srcList] of Object.entries(owners)){
        SPRITE_IMAGES[typeId][ownerId] = srcList.map(src=>{
          const img = new Image();
          img.src = src;
          return img;
        });
      }
    }

    for(const [kindId, owners] of Object.entries(BUILDING_SOURCES)){
      BUILDING_IMAGES[kindId] = {};
      for(const [ownerId, src] of Object.entries(owners)){
        const img = new Image();
        img.src = src;
        BUILDING_IMAGES[kindId][ownerId] = img;
      }
    }

    for(const [id, src] of Object.entries(TERRAIN_SOURCES)){
      const img = new Image();
      img.src = src;
      TERRAIN_IMAGES[id] = img;
    }
  }

  const DEFAULT_CUSTOM_MAP =
`.~~~~~~~........
.~......f.......
.~.H....=....R..
.~......=.......
.~..c...=...c...
.~..b...==...b..
.~......==......
.~..c...=...c...
.~......=.......
.~.1....=....2..
.~......f.......
.~~~~~~~........`;

  function applySelectedMap(){
    const id = Game.selectedMap || "CLASSIC";
    const entry = MAPS.find(m=>m.id===id);
    if(id==="CUSTOM"){
      generateCustomMapFromText(Game.customMapText || DEFAULT_CUSTOM_MAP);
    } else if(entry && entry.gen){
      entry.gen();
    } else {
      generateMapClassic();
    }
  }

  function spawnDefaultAirportUnits(){
    for(let y=0;y<GRID_H;y++){
      for(let x=0;x<GRID_W;x++){
        const b = buildingAt(x,y);
        if(b && b.kindId==="AIRPORT" && b.owner){
          if(!unitAt(x,y)){
            Game.units.push(makeUnit("BC", b.owner, x, y));
          }
        }
      }
    }
  }

  function spawnDefaultPortUnits(){
    for(let y=0;y<GRID_H;y++){
      for(let x=0;x<GRID_W;x++){
        const b = buildingAt(x,y);
        if(b && b.kindId==="SHIPPORT" && b.owner){
          if(!unitAt(x,y)){
            Game.units.push(makeUnit("SUB", b.owner, x, y));
          }
        }
      }
    }
  }

  function freshMatch(){
    Game.day = 1;
    Game.currentPlayer = 1;
    Game.funds = { 1: Game.startFunds, 2: Game.startFunds };
    Game.units = [];
    Game.sel = null;
    Game.phase = "IDLE";
    Game.moveMap = null;
    Game.moveTiles = new Set();
    Game.path = [];
    Game.atkTiles = new Set();
    Game.baseCycleIdx = {1:0, 2:0};
    Game.hovered = {x:-1,y:-1};
    Game.gameOver = false;
    Game.winner = null;
    Game.winReason = null;
    Game.coMeter = {1:0, 2:0};
    Game.coState = {1:null, 2:null};
    Game.coChoice = {1:"ANDY", 2:"ANDY"};
    sKeyHeld = false;
    sBtnHeld = false;
    dKeyHeld = false;
    dBtnHeld = false;
    mKeyHeld = false;
    mBtnHeld = false;
    updateRangePreview();
    if(!Game.customMapText) Game.customMapText = DEFAULT_CUSTOM_MAP;

    applySelectedMap();
    if(Game.selectedMap!=="CUSTOM"){
      spawnDefaultAirportUnits();
      spawnDefaultPortUnits();
    }

    if(Game.selectedMap!=="CUSTOM"){
      // Starting units (balanced; includes some new unit types)
      Game.units.push(makeUnit("INF",1, 2,2));
      Game.units.push(makeUnit("INF",1, 3,1));
      Game.units.push(makeUnit("RECON",1, 3,2));
      Game.units.push(makeUnit("TANK",1, 2,3));
      Game.units.push(makeUnit("ART",1, 4,2));

      Game.units.push(makeUnit("INF",2, GRID_W-3, GRID_H-3));
      Game.units.push(makeUnit("INF",2, GRID_W-4, GRID_H-2));
      Game.units.push(makeUnit("RECON",2, GRID_W-4, GRID_H-4));
      Game.units.push(makeUnit("TANK",2, GRID_W-3, GRID_H-4));
      Game.units.push(makeUnit("ART",2, GRID_W-5, GRID_H-3));
    }

    clearLog();
    logLine("Match start. Player 1 begins.", 1);
    updateUI();
    renderLegend(); // NEW
    autoOpenShopForCurrentPlayer();
  }

  function hardReset(){
    UNIT_ID_SEQ = 1;
    freshMatch();
  }

  /***********************************************************************
   * Logging
   ***********************************************************************/
  function clearLog(){
    logBox.innerHTML = "";
  }

  function logLine(text, playerId=null){
    const p = document.createElement("p");
    p.className = "line " + (playerId===1 ? "p1" : playerId===2 ? "p2" : "");
    p.textContent = text;
    logBox.appendChild(p);
    logBox.scrollTop = logBox.scrollHeight;
  }

  function consumeAction(u){
    if(!u) return;
    if(typeof u.actionsLeft!=="number") u.actionsLeft = 1;
    u.actionsLeft = Math.max(0, u.actionsLeft - 1);
    if(u.actionsLeft > 0){
      u.moved = false;
      u.acted = false;
    } else {
      u.moved = true;
      u.acted = true;
    }
  }

  function refreshPlayerUnits(playerId, minActions=1){
    for(const u of Game.units){
      if(u.owner===playerId){
        const targetActions = Math.max(minActions, 1);
        u.actionsLeft = targetActions;
        u.moved = false;
        u.acted = false;
      }
    }
  }

  /***********************************************************************
   * Income & Turn Progression
   ***********************************************************************/
  function buildingIncome(b){
    if(!b || !b.def) return 0;
    const cityIncome = Number.isFinite(Game.cityIncome) ? Game.cityIncome : b.def.income;
    if(b.kindId==="CITY") return Math.max(0, cityIncome);
    return b.def.income;
  }

  function countOwnedIncome(playerId){
    let total = Number.isFinite(Game.baseIncome) ? Game.baseIncome : 0;
    for(let y=0;y<GRID_H;y++){
      for(let x=0;x<GRID_W;x++){
        const b = buildingAt(x,y);
        if(b && b.owner===playerId){
          total += buildingIncome(b);
        }
      }
    }
    return total;
  }

  function resetUnitsForTurn(playerId){
    for(const u of Game.units){
      if(u.owner===playerId){
        const dbl = hasDoubleActions(playerId);
        u.moved = false;
        u.acted = false;
        u.actionsLeft = dbl ? 2 : 1;
      }
    }
  }

  function endTurn(){
    if(Game.gameOver) return;

    clearCOState(Game.currentPlayer);

    closeShop();
    closeKey(); // NEW

    clearSelection();

    Game.currentPlayer = (Game.currentPlayer===1) ? 2 : 1;

    if(Game.currentPlayer===1){
      Game.day += 1;
      logLine("— Day " + Game.day + " —", null);
    }

    const income = countOwnedIncome(Game.currentPlayer);
    Game.funds[Game.currentPlayer] += income;
    logLine(`${owningPlayer(Game.currentPlayer).name} receives $${income} funds (income).`, Game.currentPlayer);

    resetUnitsForTurn(Game.currentPlayer);
    grantCOMeter(Game.currentPlayer, 10);

    updateUI();
    autoOpenShopForCurrentPlayer();
    showTurnOverlay({
      playerId: Game.currentPlayer,
      day: Game.day,
      income,
      co: getCOChoice(Game.currentPlayer)
    });

    if(Game.botMode!=="HUMAN" && Game.currentPlayer===2){
      runBotTurn(Game.botMode);
    }
  }

  /***********************************************************************
   * Selection & Phases
   ***********************************************************************/
  function clearSelection(){
    Game.sel = null;
    Game.phase = "IDLE";
    Game.moveMap = null;
    Game.moveTiles = new Set();
    Game.atkTiles = new Set();
    Game.path = [];
    elSelHint.textContent = "Click a unit, building, or tile.";
    elSelKv.innerHTML = "";
    elSelStats.innerHTML = "";
    if(damagePreviewEl) damagePreviewEl.style.display = "none";
  }

  function selectUnit(u){
    if(Game.gameOver) return;
    clearSelection();
    Game.sel = { type:"unit", unit:u, x:u.x, y:u.y };
    updateSelectionPanel();
    computeMoveOverlayIfApplicable();
    computeAttackOverlayIfApplicable();
    if(canAttackThisTurn(u)){
      Game.phase = "ATTACKING";
    }
    updateDamagePreview();
  }

  function selectBuilding(b, x, y){
    if(Game.gameOver) return;
    clearSelection();
    Game.sel = { type:"building", building:b, x, y };
    updateSelectionPanel();
    updateDamagePreview();
  }

  // NEW: select tile (even empty) so we can show defense stat
  function selectTile(x,y){
    if(Game.gameOver) return;
    clearSelection();
    Game.sel = { type:"tile", x, y };
    updateSelectionPanel();
  }

  function updateSelectionPanel(){
    elSelKv.innerHTML = "";
    elSelStats.innerHTML = "";

    if(!Game.sel){
      elSelHint.textContent = "Click a unit, building, or tile.";
      return;
    }

    if(Game.sel.type==="unit"){
      const u = Game.sel.unit;
      const p = owningPlayer(u.owner);
      const hpPct = u.hp / u.def.maxHP;
      const { minR, maxR } = getRangeForUnit(u);
      const rangeText = formatRangeText(minR, maxR);
      const sprite = makeSpriteNode(u.typeId, u.owner, 80);
      const imgRow = document.createElement("div");
      imgRow.className = "selImgRow";
      imgRow.appendChild(sprite);
      const moveStatus = u.moved ? "Moved" : "Can Move";
      const canFire = canAttackThisTurn(u);
      let atkStatus = "Can Atk";
      if(u.acted) atkStatus = "Attacked";
      else if(isIndirectUnit(u) && u.moved) atkStatus = "No Atk (moved)";
      else if(u.owner!==Game.currentPlayer) atkStatus = "Enemy";
      else if(!canFire) atkStatus = "No Atk";
      const statusGood = (u.owner===Game.currentPlayer) && (!u.moved && !u.acted);

      elSelHint.textContent = "Press ESC to unselect";
      addKV("Owner", p.name);
      addKV("Type", `${u.def.name} (${u.def.abbr})`); // NEW: show abbr
      addKV("HP", `${u.hp}/${u.def.maxHP}`);
      addKV("Move", `${u.def.move} (${u.def.movementType})`);
      addKV("Range", rangeText);
      addKV("Status", `${moveStatus} / ${atkStatus}`);
      addKV("Damage", damageDisplayText(u.def.id).replace("Damage: ",""));

      const tile = terrainAt(u.x,u.y);
      addKV("Terrain", tile.name);
      const b = buildingAt(u.x,u.y);
      addKV("Tile Cover", formatStars(tileDefenseStat(u.x,u.y)));

      if(b){
        addKV("Building", b.def.name + (b.owner ? ` (Owned by P${b.owner})` : " (Neutral)"));
      }
      const blurb = UNIT_BLURB[u.def.id];
      if(blurb) addKV("Role", blurb);

      // Detailed stat pills similar to shop cards
      const pills = [];
      const typePill = document.createElement("span");
      typePill.className = "pill";
      typePill.textContent = u.def.name;
      pills.push(typePill);

      const hpPill = document.createElement("span");
      hpPill.className = "pill " + (hpPct>0.66 ? "good" : hpPct>0.33 ? "warn" : "bad");
      hpPill.textContent = `HP ${u.hp}/${u.def.maxHP}`;
      pills.push(hpPill);

      const dmgPill = document.createElement("span");
      dmgPill.className = "pill warn";
      dmgPill.style.cursor = "pointer";
      const setDmgText = ()=>{ dmgPill.textContent = damageDisplayText(u.def.id); };
      setDmgText();
      dmgPill.title = "Click to toggle detailed damage view";
      dmgPill.addEventListener("click", ()=>{
        Game.dmgDetail = !Game.dmgDetail;
        updateSelectionPanel();
      });
      pills.push(dmgPill);

      const capPill = document.createElement("span");
      capPill.className = "pill " + (u.def.canCapture ? "good" : "");
      capPill.textContent = u.def.canCapture ? "Can capture" : "No capture";
      pills.push(capPill);

      const movePill = document.createElement("span");
      movePill.className = "pill";
      movePill.textContent = `Move: ${u.def.move} (${u.def.movementType})`;

      const rangePill = document.createElement("span");
      rangePill.className = "pill";
      rangePill.textContent = `Range: ${rangeText}`;

      const statusPill = document.createElement("span");
      const bothReady = (!u.moved && !u.acted);
      const bothSpent = (u.moved && u.acted);
      const partial = (!bothReady && !bothSpent);
      statusPill.className = "pill " + (bothReady ? "good" : bothSpent ? "bad" : "warn");
      statusPill.textContent = `Status: ${moveStatus} / ${atkStatus}`;

      const terrain = terrainAt(u.x,u.y);
      const terrainPill = document.createElement("span");
      terrainPill.className = "pill";
      terrainPill.textContent = `Terrain: ${terrain.name}`;

      const defPill = document.createElement("span");
      defPill.className = "pill";
      defPill.textContent = `Cover: ${formatStars(tileDefenseStat(u.x,u.y))}`;

      const row1 = document.createElement("div");
      row1.className = "selRow center";
      row1.appendChild(typePill);
      row1.appendChild(hpPill);

      const row2 = document.createElement("div");
      row2.className = "selRow center";
      row2.appendChild(dmgPill);
      row2.appendChild(capPill);

      const row3 = document.createElement("div");
      row3.className = "selRow center";
      row3.appendChild(movePill);
      row3.appendChild(rangePill);

      const row4 = document.createElement("div");
      row4.className = "selRow center";
      row4.appendChild(statusPill);
      row4.appendChild(terrainPill);
      row4.appendChild(defPill);

      setSelStats([imgRow, row1, row2, row3, row4]);
    } else if(Game.sel.type==="building") {
      const b = Game.sel.building;
      elSelHint.textContent = "Selected building.";

      const imgRow = document.createElement("div");
      imgRow.className = "selImgRow";
      imgRow.appendChild(makeBuildingNode(b.kindId, b.owner ?? 0, 80));

      const typePill = document.createElement("span");
      typePill.className = "pill";
      typePill.textContent = b.def.name;

      const ownerPill = document.createElement("span");
      ownerPill.className = "pill";
      ownerPill.textContent = b.owner ? `Owner: P${b.owner}` : "Owner: Neutral";

      const hpPill = document.createElement("span");
      hpPill.className = "pill warn";
      hpPill.textContent = `HP: ${b.capturePoints}/20`;

      const defPill = document.createElement("span");
      defPill.className = "pill";
      defPill.textContent = `Cover: ${formatStars(tileDefenseStat(Game.sel.x, Game.sel.y))}`;

      const terrainPill = document.createElement("span");
      terrainPill.className = "pill";
      terrainPill.textContent = `Terrain: ${terrainAt(Game.sel.x, Game.sel.y).name}`;

      const row1 = document.createElement("div");
      row1.className = "selRow center";
      row1.appendChild(typePill);
      row1.appendChild(ownerPill);
      row1.appendChild(hpPill);

      const row2 = document.createElement("div");
      row2.className = "selRow center";
      row2.appendChild(defPill);
      row2.appendChild(terrainPill);

      setSelStats([imgRow, row1, row2]);
    } else {
      // NEW: tile selection view
      elSelHint.textContent = "Selected tile.";
      const t = terrainAt(Game.sel.x, Game.sel.y);

      const imgRow = document.createElement("div");
      imgRow.className = "selImgRow";
      imgRow.appendChild(makeTerrainNode(t, 80));

      const terrainPill = document.createElement("span");
      terrainPill.className = "pill";
      terrainPill.textContent = `Terrain: ${t.name}`;

      const defPill = document.createElement("span");
      defPill.className = "pill";
      defPill.textContent = `Cover: ${formatStars(tileDefenseStat(Game.sel.x, Game.sel.y))}`;

      const row1 = document.createElement("div");
      row1.className = "selRow center";
      row1.appendChild(terrainPill);
      row1.appendChild(defPill);

      setSelStats([imgRow, row1]);
    }
  }

  function addKV(k,v){
    const a=document.createElement("div"); a.textContent=k;
    const b=document.createElement("div"); b.textContent=v;
    elSelKv.appendChild(a); elSelKv.appendChild(b);
  }

  function setSelStats(nodes){
    elSelStats.innerHTML = "";
    for(const n of nodes){
      elSelStats.appendChild(n);
    }
  }

  function panelsOpen(){
    return shopBox.style.display==="block" || keyBox.style.display==="block";
  }

  function updateHelpPosition(){
    if(!helpBox || !lowerPanels) return;
    const parent = helpBox.parentElement;
    if(!parent) return;
    if(panelsOpen()){
      if(helpBox.nextElementSibling){
        parent.appendChild(helpBox);
      }
    } else {
      parent.insertBefore(helpBox, lowerPanels);
    }
  }

  /***********************************************************************
   * CO selection & income panel
   ***********************************************************************/
  function getCOChoice(playerId){
    const id = Game.coChoice[playerId] || "ANDY";
    return CO_DATA[id] || CO_DATA.ANDY;
  }

  function setCOChoice(playerId, coId){
    if(!CO_DATA[coId]) return;
    Game.coChoice[playerId] = coId;
    renderCOSection();
    logLine(`${owningPlayer(playerId).name} selects ${CO_DATA[coId].name}.`, playerId);
  }

  function setCOAvatar(el, co, playerId){
    if(!el) return;
    const p = owningPlayer(playerId);
    el.style.borderColor = p.color;
    el.style.background = `linear-gradient(135deg, ${p.dark}, ${p.color}55)`;
    el.innerHTML = "";
    if(co.img){
      const img = document.createElement("img");
      img.src = co.img;
      img.alt = co.name;
      el.appendChild(img);
    } else {
      el.textContent = co.name.slice(0,1);
    }
  }

  function renderCOSection(){
    const co1 = getCOChoice(1);
    const co2 = getCOChoice(2);

    p1COName.textContent = co1.name;
    p2COName.textContent = co2.name;
    if(p1NameLabel && !p1NameLabel.dataset.editing) p1NameLabel.textContent = owningPlayer(1).name;
    if(p2NameLabel && !p2NameLabel.dataset.editing) p2NameLabel.textContent = owningPlayer(2).name;
    p1COSpecialty.innerHTML = `<div class="abilityLine"><span class="abilityBadge">Day-to-day</span><span class="abilityCopy">${co1.specialty}</span></div>`;
    p2COSpecialty.innerHTML = `<div class="abilityLine"><span class="abilityBadge">Day-to-day</span><span class="abilityCopy">${co2.specialty}</span></div>`;
    p1COPower.innerHTML = `<div class="abilityLine"><span class="abilityBadge">CO Power</span><span class="abilityCopy">${co1.power}</span></div>`;
    p2COPower.innerHTML = `<div class="abilityLine"><span class="abilityBadge">CO Power</span><span class="abilityCopy">${co2.power}</span></div>`;
    p1COSuper.innerHTML = `<div class="abilityLine"><span class="abilityBadge">Super CO</span><span class="abilityCopy">${co1.super}</span></div>`;
    p2COSuper.innerHTML = `<div class="abilityLine"><span class="abilityBadge">Super CO</span><span class="abilityCopy">${co2.super}</span></div>`;

    setCOAvatar(p1COAvatar, co1, 1);
    setCOAvatar(p2COAvatar, co2, 2);
    setCOAvatar(p1TopAvatar, co1, 1);
    setCOAvatar(p2TopAvatar, co2, 2);
    if(p1TopTooltip) p1TopTooltip.innerHTML = `${p1COSpecialty.innerHTML}${p1COPower.innerHTML}${p1COSuper.innerHTML}`;
    if(p2TopTooltip) p2TopTooltip.innerHTML = `${p2COSpecialty.innerHTML}${p2COPower.innerHTML}${p2COSuper.innerHTML}`;

    const m1 = Game.coMeter[1] ?? 0;
    const m2 = Game.coMeter[2] ?? 0;
    if(p1MeterFill) p1MeterFill.style.width = `${clamp(m1,0,100)}%`;
    if(p2MeterFill) p2MeterFill.style.width = `${clamp(m2,0,100)}%`;
    if(p1TopMeterFill) p1TopMeterFill.style.width = `${clamp(m1,0,100)}%`;
    if(p2TopMeterFill) p2TopMeterFill.style.width = `${clamp(m2,0,100)}%`;
    if(p1MeterLabel) p1MeterLabel.textContent = `Meter ${Math.round(m1)}%`;
    if(p2MeterLabel) p2MeterLabel.textContent = `Meter ${Math.round(m2)}%`;

    const powerCost = 60, superCost = 100;
    const p1State = Game.coState[1];
    const p2State = Game.coState[2];
    const p1PowerDisabled = m1 < powerCost || p1State;
    const p2PowerDisabled = m2 < powerCost || p2State;
    const p1SuperDisabled = m1 < superCost || p1State;
    const p2SuperDisabled = m2 < superCost || p2State;
    if(p1PowerBtn) p1PowerBtn.disabled = p1PowerDisabled;
    if(p2PowerBtn) p2PowerBtn.disabled = p2PowerDisabled;
    if(p1SuperBtn) p1SuperBtn.disabled = p1SuperDisabled;
    if(p2SuperBtn) p2SuperBtn.disabled = p2SuperDisabled;
    if(p1TopPower) p1TopPower.disabled = p1PowerDisabled;
    if(p2TopPower) p2TopPower.disabled = p2PowerDisabled;
    if(p1TopSuper) p1TopSuper.disabled = p1SuperDisabled;
    if(p2TopSuper) p2TopSuper.disabled = p2SuperDisabled;
  }

  function openCOModal(playerId){
    coModalTarget = playerId;
    if(coModalHint) coModalHint.textContent = `Assign a CO for Player ${playerId}`;
    renderCOList();
    if(coModal) coModal.style.display = "flex";
  }

  function closeCOModal(){
    if(coModal) coModal.style.display = "none";
    coModalTarget = null;
  }

  function renderCOList(){
    if(!coList) return;
    coList.innerHTML = "";
    const current = Game.coChoice[coModalTarget] || "ANDY";
    for(const coId of Object.keys(CO_DATA)){
      const co = CO_DATA[coId];
      const row = document.createElement("div");
      row.className = "coOption";

      const avatar = document.createElement("div");
      avatar.className = "coAvatar";
      setCOAvatar(avatar, co, coModalTarget || 1);

      const textBox = document.createElement("div");
      textBox.className = "coText";
      const name = document.createElement("div");
      name.className = "coName";
      name.textContent = co.name;
      const spec = document.createElement("div");
      spec.className = "coBuff";
      spec.innerHTML = `<div class="abilityLine"><span class="abilityBadge">Day-to-day</span><span class="abilityCopy">${co.specialty}</span></div>`;
      const power = document.createElement("div");
      power.className = "coBuff small";
      power.innerHTML = `<div class="abilityLine"><span class="abilityBadge">CO Power</span><span class="abilityCopy">${co.power}</span></div>`;
      const sup = document.createElement("div");
      sup.className = "coBuff small";
      sup.innerHTML = `<div class="abilityLine"><span class="abilityBadge">Super CO</span><span class="abilityCopy">${co.super}</span></div>`;

      textBox.appendChild(name);
      textBox.appendChild(spec);
      textBox.appendChild(power);
      textBox.appendChild(sup);

      const btn = document.createElement("button");
      btn.className = "btn tiny";
      btn.textContent = coId===current ? "Selected" : "Choose";
      if(coId===current) btn.classList.add("primary");
      btn.addEventListener("click", ()=>{
        if(coModalTarget){
          setCOChoice(coModalTarget, coId);
          closeCOModal();
        }
      });

      row.appendChild(avatar);
      row.appendChild(textBox);
      row.appendChild(btn);
      coList.appendChild(row);
    }
  }

  /***********************************************************************
   * CO meter & powers
   ***********************************************************************/
  const CO_POWER_COST = 60;
  const CO_SUPER_COST = 100;

  function grantCOMeter(playerId, amount){
    const cur = Game.coMeter[playerId] ?? 0;
    Game.coMeter[playerId] = clamp(cur + amount, 0, 100);
  }

  function clearCOState(playerId){
    Game.coState[playerId] = null;
  }

  function hasDoubleActions(playerId){
    return Game.coState[playerId] === "SUPER";
  }

  function updateRangePreview(){
    const sActive = sKeyHeld || sBtnHeld;
    const dActive = dKeyHeld || dBtnHeld;
    const mActive = mKeyHeld || mBtnHeld;
    if(rangeBtn) rangeBtn.classList.toggle("primary", sActive);
    if(dmgBtn) dmgBtn.classList.toggle("primary", dActive);
    if(moveBtn) moveBtn.classList.toggle("primary", mActive);
  }

  function grantExtraActions(playerId, minimum=2){
    for(const u of Game.units){
      if(u.owner===playerId){
        u.actionsLeft = Math.max(u.actionsLeft || 1, minimum);
        u.moved = false;
        u.acted = false;
      }
    }
  }

  function healPlayerUnits(playerId, amount){
    for(const u of Game.units){
      if(u.owner===playerId){
        u.hp = clamp(u.hp + amount, 0, u.def.maxHP);
      }
    }
  }

  function useCOPower(playerId, tier){
    const cost = tier==="SUPER" ? CO_SUPER_COST : CO_POWER_COST;
    if((Game.coMeter[playerId] ?? 0) < cost) return;
    if(Game.coState[playerId]) return; // already active
    Game.coMeter[playerId] -= cost;
    Game.coState[playerId] = tier;
    const co = getCOChoice(playerId);
    logLine(`${owningPlayer(playerId).name} activates ${co.name} ${tier==="SUPER" ? "Super CO Power" : "CO Power"}!`, playerId);
    if(co.id==="ANDY"){
      healPlayerUnits(playerId, tier==="SUPER" ? 5 : 2);
    }
    refreshPlayerUnits(playerId, tier==="SUPER" ? 2 : 1);
    renderCOSection();
    updateUI();
  }

  function showTurnOverlay({ playerId, day, income, co }){
    if(!turnOverlay || !turnOverlayBox) return;
    const pillClass = playerId===1 ? "coPill p1" : "coPill p2";
    turnOverlayPlayer.className = pillClass;
    turnOverlayPlayer.textContent = `Player ${playerId}`;
    turnOverlayDay.textContent = `Day ${day}`;
    turnOverlayIncome.textContent = `Income +$${income}`;

    if(turnOverlayTimer) clearTimeout(turnOverlayTimer);
    turnOverlay.classList.remove("show");
    void turnOverlay.offsetWidth;
    turnOverlay.style.display = "flex";
    requestAnimationFrame(()=>{ turnOverlay.classList.add("show"); });

    turnOverlayTimer = setTimeout(()=>{
      turnOverlay.classList.remove("show");
      setTimeout(()=>{ turnOverlay.style.display = "none"; }, 320);
    }, 500);
  }

  /***********************************************************************
   * Battle Overlay
   ***********************************************************************/
  function setHPBar(el, current, max){
    const pct = clamp(current / max, 0, 1);
    el.style.width = `${pct*100}%`;
    el.style.background = pct>0.66 ? "#74ff8a" : pct>0.33 ? "#ffd166" : "#ff5d7a";
  }

  /***********************************************************************
   * Map Picker
   ***********************************************************************/
  function renderMapPicker(){
    if(!mapList) return;
    initCustomGridFromText(Game.customMapText || DEFAULT_CUSTOM_MAP);
    mapList.innerHTML = "";
    renderCustomPalette();
    renderCustomGrid();
    renderBotButtons();
    let mapIdx = 0;
    const labelFor = (slot)=>{
      if(slot>=1 && slot<=6) return "Land only";
      if(slot>=7 && slot<=9) return "Land/Air";
      if(slot>=10 && slot<=12) return "Land/Ship";
      if(slot>=13 && slot<=15) return "Land/Air/Sea";
      return "";
    };
    for(const m of MAPS.filter(m=>m.id!=="CUSTOM")){
      mapIdx += 1;
      const mapLabel = labelFor(mapIdx);
      const card = document.createElement("div");
      card.className = "mapCard";
      if(m.img){
        const img = document.createElement("img");
        img.src = m.img;
        img.alt = m.name;
        img.style.width = "100%";
        img.style.borderRadius = "10px";
        img.style.border = "1px solid #23346b";
        img.style.background = "#050814";
        img.style.objectFit = "cover";
        card.appendChild(img);
      }
      const name = document.createElement("div");
      name.className = "name";
      name.textContent = m.name;
      const meta = document.createElement("div");
      meta.className = "meta";
      const metaText = document.createElement("div");
      metaText.textContent = m.desc;
      meta.appendChild(metaText);
      if(mapLabel){
        const badgeWrap = document.createElement("div");
        badgeWrap.style.marginTop = "10px";
        badgeWrap.style.padding = "6px 0 4px";
        badgeWrap.style.display = "inline-block";
        badgeWrap.style.lineHeight = "1.4";
        const badge = document.createElement("span");
        badge.className = "pill";
        badge.style.padding = "6px 12px";
        badge.textContent = mapLabel;
        badgeWrap.appendChild(badge);
        meta.appendChild(badgeWrap);
      }
      const btnRow = document.createElement("div");
      btnRow.style.display = "flex";
      btnRow.style.gap = "8px";
      const playBtn = document.createElement("button");
      playBtn.className = "btn primary";
      playBtn.textContent = "Play";
      playBtn.addEventListener("click", ()=>{
        Game.selectedMap = m.id;
        closeMapPicker();
        freshMatch();
      });
      const editBtn = document.createElement("button");
      editBtn.className = "btn";
      editBtn.textContent = "Edit";
      editBtn.addEventListener("click", ()=>{
        Game.selectedMap = m.id;
        if(m.gen) m.gen();
        Game.customMapText = mapStateToCustomText();
        initCustomGridFromText(Game.customMapText);
        renderCustomGrid();
        Game.selectedMap = "CUSTOM";
        const target = document.getElementById("customMapSection");
        if(target){
          target.scrollIntoView({ behavior:"smooth" });
        }
      });
      btnRow.appendChild(playBtn);
      btnRow.appendChild(editBtn);
      card.appendChild(name);
      card.appendChild(meta);
      card.appendChild(btnRow);
      mapList.appendChild(card);
    }
  }

  function openMapPicker(){
    renderMapPicker();
    closeMapSettings();
    syncIncomeInputs();
    if(mapModal) mapModal.style.display = "flex";
  }

  function setBotMode(mode){
    Game.botMode = mode;
    renderBotButtons();
    saveGameState();
  }

  function renderBotButtons(){
    const modes = {
      HUMAN: botHumanBtn,
      EASY: botEasyBtn,
      MED: botMedBtn,
      HARD: botHardBtn
    };
    for(const [mode, btn] of Object.entries(modes)){
      if(!btn) continue;
      btn.classList.toggle("primary", Game.botMode===mode);
    }
  }

  function closeMapPicker(){
    closeMapSettings();
    if(mapModal) mapModal.style.display = "none";
  }
  function closeMapSettings(){
    if(mapSettingsBox) mapSettingsBox.style.display = "none";
    if(mapSettingsBtn) mapSettingsBtn.classList.remove("primary");
  }
  function toggleMapSettings(){
    if(!mapSettingsBox) return;
    const show = mapSettingsBox.style.display !== "flex";
    mapSettingsBox.style.display = show ? "flex" : "none";
    if(mapSettingsBtn) mapSettingsBtn.classList.toggle("primary", show);
    if(show) syncIncomeInputs();
  }

  function showBattleOverlay({ attacker, defender, atkBefore, atkAfter, defBefore, defAfter, attackerLabel, defenderLabel, attackerImg, defenderImg, atkMax, defMax, leftText="", rightText="" }){
    return new Promise(resolve=>{
      if(!battleOverlay) return resolve();
      let holdBattle = false;
      const holdKeyHandler = (e)=>{ if(e.key==="p"||e.key==="P") holdBattle=true; };
      const releaseKeyHandler = (e)=>{ if(e.key==="p"||e.key==="P") holdBattle=false; };
      window.addEventListener("keydown", holdKeyHandler);
      window.addEventListener("keyup", releaseKeyHandler);

      // Force blue (P1) on left, red (P2) on right by swapping when needed
      let left = { img:attackerImg, label:attackerLabel, before:atkBefore, after:atkAfter, max:atkMax, dmg:leftText };
      let right = { img:defenderImg, label:defenderLabel, before:defBefore, after:defAfter, max:defMax, dmg:rightText };
      let attackerOnLeft = true;
      if(attacker && defender && attacker.owner===2 && defender.owner===1){
        left = { img:defenderImg, label:defenderLabel, before:defBefore, after:defAfter, max:defMax, dmg:rightText };
        right = { img:attackerImg, label:attackerLabel, before:atkBefore, after:atkAfter, max:atkMax, dmg:leftText };
        attackerOnLeft = false;
      }

      battleOverlay.style.display = "flex";

      battleLeftImg.src = left.img || "";
      battleRightImg.src = right.img || "";
      battleLeftLabel.textContent = left.label;
      battleRightLabel.textContent = right.label;
      if(battleLeftDmg) battleLeftDmg.textContent = left.dmg;
      if(battleRightDmg) battleRightDmg.textContent = right.dmg;

      const leftBox = battleLeftImg.parentElement;
      const rightBox = battleRightImg.parentElement;
      leftBox.classList.remove("hitLeft","hitRight");
      rightBox.classList.remove("hitLeft","hitRight");

      setHPBar(battleLeftHP, left.before, left.max || left.before || 1);
      setHPBar(battleRightHP, right.before, right.max || right.before || 1);

      const applyHit = (box, cls)=>{ box.classList.remove(cls); void box.offsetWidth; box.classList.add(cls); };
      const attackerBox = attackerOnLeft ? leftBox : rightBox;
      const defenderBox = attackerOnLeft ? rightBox : leftBox;
      const attackerHPBar = attackerOnLeft ? battleLeftHP : battleRightHP;
      const defenderHPBar = attackerOnLeft ? battleRightHP : battleLeftHP;
      const attackerAfter = attackerOnLeft ? left.after : right.after;
      const defenderAfter = attackerOnLeft ? right.after : left.after;
      const attackerBefore = attackerOnLeft ? left.before : right.before;
      const defenderBefore = attackerOnLeft ? right.before : left.before;
      const attackerMax = attackerOnLeft ? (left.max || left.before || 1) : (right.max || right.before || 1);
      const defenderMax = attackerOnLeft ? (right.max || right.before || 1) : (left.max || left.before || 1);
      const attackerHitClass = attackerOnLeft ? "hitLeft" : "hitRight";   // attacker lunges toward enemy
      const defenderHitClass = attackerOnLeft ? "hitRight" : "hitLeft";   // defender lunges toward attacker when retaliating
      const willRetal = attackerAfter !== attackerBefore;

      // phase 1: attacker strikes
      const firstHitDelay = 30;
      setTimeout(()=>{
        // attacker animates forward, defender HP drops
        applyHit(attackerBox, attackerHitClass);
        setHPBar(defenderHPBar, defenderAfter, defenderMax);
      }, firstHitDelay);

      // phase 2: retaliation (if any)
      if(willRetal){
        const retalDelay = firstHitDelay + 500; // explicit 0.5s gap
        setTimeout(()=>{
          // defender retaliates (now acting as attacker)
          applyHit(defenderBox, defenderHitClass);
          setHPBar(attackerHPBar, attackerAfter, attackerMax);
        }, retalDelay);
      }

      const total = willRetal ? 1500 : 900;
      const endTime = performance.now() + total;
      const waitToClose = ()=>{
        if(holdBattle){
          requestAnimationFrame(waitToClose);
          return;
        }
        if(performance.now() < endTime){
          requestAnimationFrame(waitToClose);
          return;
        }
        battleOverlay.style.display = "none";
        window.removeEventListener("keydown", holdKeyHandler);
        window.removeEventListener("keyup", releaseKeyHandler);
        resolve();
      };
      waitToClose();
    });
  }

  /***********************************************************************
   * Movement
   ***********************************************************************/
  const DIRS = [
    {dx:1,dy:0},{dx:-1,dy:0},{dx:0,dy:1},{dx:0,dy:-1}
  ];

  function hasAdjacentLand(x,y){
    for(const d of DIRS){
      const nx = x+d.dx, ny = y+d.dy;
      if(!inBounds(nx,ny)) continue;
      const t = terrainAt(nx,ny);
      if(t && t.id!=="WATER") return true;
    }
    return false;
  }

  function isTileBlockedForMovement(x,y, movingUnit){
    const u = unitAt(x,y);
    if(!u) return false;
    return (u.uid !== movingUnit.uid);
  }

  function movementCost(unit, x, y){
    const t = terrainAt(x,y);
    const mtype = unit.def.movementType;
    if(mtype==="foot" && t.id==="WATER"){
      // Foot units can only step on water if adjacent to land (shoreline)
      if(!hasAdjacentLand(x,y)) return 99;
    }
    const cost = t.moveCost[mtype] ?? 99;
    return cost;
  }

  function computeMoveOverlayIfApplicable(){
    Game.moveTiles = new Set();
    Game.moveMap = null;
    Game.atkTiles = new Set();
    Game.path = [];

    if(!Game.sel || Game.sel.type!=="unit") return;
    const u = Game.sel.unit;

    const start = {x:u.x,y:u.y};
    const maxMove = unitMovePoints(u);

    const dist = new Map();
    const prev = new Map();
    const open = [];

    const sk = key(start.x,start.y);
    dist.set(sk, 0);
    prev.set(sk, null);
    open.push({k:sk, cost:0});

    function pushOrUpdate(k,c){
      for(const it of open){
        if(it.k===k){
          if(c<it.cost){ it.cost=c; }
          return;
        }
      }
      open.push({k, cost:c});
    }

    while(open.length){
      open.sort((a,b)=>a.cost-b.cost);
      const cur = open.shift();
      if(!cur) break;
      const {x,y} = parseKey(cur.k);
      const curCost = cur.cost;

      if(dist.get(cur.k) !== curCost) continue;

      for(const d of DIRS){
        const nx=x+d.dx, ny=y+d.dy;
        if(!inBounds(nx,ny)) continue;

        const step = movementCost(u,nx,ny);
        if(step>=99) continue;
        if(isTileBlockedForMovement(nx,ny,u)) continue;

        const nc = curCost + step;
        if(nc > maxMove) continue;

        const nk = key(nx,ny);
        const old = dist.get(nk);
        if(old===undefined || nc < old){
          dist.set(nk,nc);
          prev.set(nk, cur.k);
          pushOrUpdate(nk,nc);
        }
      }
    }

    Game.moveMap = { dist, prev, startKey: sk };
    for(const k of dist.keys()){
      Game.moveTiles.add(k);
    }
  }

  function computeAttackOverlayIfApplicable(){
    Game.atkTiles = new Set();
    if(!Game.sel || Game.sel.type!=="unit") return;
    const u = Game.sel.unit;

    const canProjectAfterMove = !isIndirectUnit(u) && !NO_PROJECTION_ATTACK_UNITS.has(u.def.id) && !isSeaUnit(u) && !isAirUnit(u);
    const useMoveProjection = (Game.moveTiles && Game.moveTiles.size && u.owner===Game.currentPlayer && !u.moved && canProjectAfterMove);
    const origins = [];

    if(useMoveProjection){
      for(const k of Game.moveTiles){
        origins.push(parseKey(k));
      }
    } else {
      origins.push({x:u.x, y:u.y});
    }

    for(const pos of origins){
      const tiles = computeAttackTilesFromPosition(u, pos);
      for(const k of tiles){
        Game.atkTiles.add(k);
      }
    }
  }

  function reconstructPath(toKey){
    if(!Game.moveMap) return [];
    const { prev, startKey } = Game.moveMap;

    const out = [];
    let cur = toKey;
    while(cur && cur!==startKey){
      out.push(cur);
      cur = prev.get(cur);
    }
    out.push(startKey);
    out.reverse();
    return out.map(parseKey);
  }

  /***********************************************************************
   * Attack Tiles
   ***********************************************************************/
  function computeAttackTilesFromPosition(unit, pos){
    const tiles = new Set();
    const { minR, maxR } = getRangeForUnit(unit);

    for(let y=0;y<GRID_H;y++){
      for(let x=0;x<GRID_W;x++){
        const d = Math.abs(x-pos.x)+Math.abs(y-pos.y);
        if(d>=minR && d<=maxR){
          tiles.add(key(x,y));
        }
      }
    }
    return tiles;
  }

  function unitHasEnemyInRange(u){
    if(!u || !canAttackThisTurn(u)) return false;
    const tiles = computeAttackTilesFromPosition(u, {x:u.x, y:u.y});
    for(const k of tiles){
      if(enemyInRangeAt(u, k)) return true;
    }
    return false;
  }

  function adjacent(a,b){
    return manhattan({x:a.x,y:a.y},{x:b.x,y:b.y})===1;
  }

  function enemyInRangeAt(unit, k){
    const {x,y} = parseKey(k);
    const target = unitAt(x,y);
    if(!target) return false;
    return target.owner !== unit.owner && canTarget(unit, target);
  }

  function canUnloadToTile(transporter, x, y){
    if(!transporter || !transporter.def.transport) return false;
    if(!adjacent({x:transporter.x,y:transporter.y},{x,y})) return false;
    if(unitAt(x,y)) return false;
    const t = terrainAt(x,y);
    if(isLander(transporter)){
      if(!t || t.id==="WATER") return false;
    }
    if(transporter.def.id==="TC"){
      if(!t || t.id==="WATER") return false;
    }
    return true;
  }

  function unloadCargo(transporter, x, y){
    if(!transporter || !transporter.def.transport || !transporter.cargo) return false;
    if(!canUnloadToTile(transporter, x, y)) return false;
    const list = Array.isArray(transporter.cargo) ? transporter.cargo : [transporter.cargo];
    if(!list.length) return false;
    const cargo = list.shift();
    const nu = makeUnit(cargo.typeId, cargo.owner, x, y);
    nu.hp = cargo.hp ?? nu.def.maxHP;
    nu.spriteIdx = cargo.spriteIdx ?? 0;
    nu.moved = true;
    nu.acted = true;
    Game.units.push(nu);
    transporter.cargo = Array.isArray(transporter.cargo) ? list : (list[0] || null);
    transporter.acted = true;
    logLine(`${owningPlayer(transporter.owner).name} unloads ${nu.def.name}.`, transporter.owner);
    updateUI();
    return true;
  }

  function isDirectUnit(u){ return !u.def.indirect; }
  function isIndirectUnit(u){ return !!u.def.indirect; }
  function isInfantry(u){ return u.def.id==="INF"; }
  function isAPC(u){ return u.def.id==="APC"; }
  function isLander(u){ return u.def.id==="LND"; }
  function isSeaUnit(u){ return u.def.movementType==="sea"; }
  function isAirUnit(u){ return u.def.movementType==="air"; }
  function transportCapacity(u){ return u.def.transportCapacity || 1; }
  function cargoCount(u){
    if(!u || !u.cargo) return 0;
    if(Array.isArray(u.cargo)) return u.cargo.length;
    return 1;
  }
  function transportFull(u){
    if(!u || !u.def.transport) return true;
    return cargoCount(u) >= transportCapacity(u);
  }
  function isLandUnit(u){ return !isSeaUnit(u) && !isAirUnit(u); }
  function canLandAttackSea(attacker){ return attacker.def.id==="ART" || attacker.def.id==="RKT"; }
  function canTarget(attacker, target){
    if(!attacker || !target) return false;
    const atkSea = isSeaUnit(attacker);
    const defSea = isSeaUnit(target);
    const atkAir = isAirUnit(attacker);
    const defAir = isAirUnit(target);

    if(atkSea){
      if(attacker.def.id==="BSH"){
        return defSea || !defAir; // battleship can hit sea and land
      }
      return defSea; // other sea units hit sea only
    }

    if(atkAir){
      if(attacker.def.id==="BMB"){
        // Bomber hits land+sea, not air
        return !defAir;
      }
      // Fighters/BC/TC only hit air (TC cannot attack anyway)
      return defAir;
    }

    // Land attackers
    if(defAir) return false; // land units cannot hit air
    if(defSea){
      return canLandAttackSea(attacker) && (target.def.id==="BSH" || target.def.id==="SUB" || target.def.id==="CRU" || target.def.id==="LND");
    }
    return true;
  }
  function canLoadIntoTransport(transporter, passenger){
    if(!transporter || !passenger) return false;
    if(!transporter.def.transport) return false;
    if(transporter.owner !== passenger.owner) return false;
    if(transportFull(transporter)) return false;
    if(passenger.uid===transporter.uid) return false;
    if(passenger.def.transport) return false;
    if(isSeaUnit(passenger)) return false; // no sea-into-sea
    if(isLander(transporter)) return true; // any land unit
    if(transporter.def.id==="TC") return isInfantry(passenger); // transport copter: infantry only
    return isAPC(transporter) && isInfantry(passenger); // APC only infantry
  }

  const NO_PROJECTION_ATTACK_UNITS = new Set(["INF","RECON","TANK","MDT"]);

  function canMoveThisTurn(u){
    if(!u) return false;
    if(Game.gameOver) return false;
    if(u.owner !== Game.currentPlayer) return false;
    return !u.moved;
  }

  function canAttackThisTurn(u){
    if(!u) return false;
    if(Game.gameOver) return false;
    if(u.owner !== Game.currentPlayer) return false;
    if(u.def && u.def.canAttack===false) return false;
    if(u.acted) return false;
    if(isIndirectUnit(u) && u.moved) return false;
    return true;
  }

  function overlayVisibility(u){
    const sActive = (sKeyHeld || sBtnHeld);
    const dActive = dKeyHeld || dBtnHeld;
    const mActive = mKeyHeld || mBtnHeld;
    const canMove = canMoveThisTurn(u);
    const canAtk = canAttackThisTurn(u);
    const enemyInRange = unitHasEnemyInRange(u);

    let showMove = false;
    let showAtk = false;
    let showAtkFull = false;

    if(sActive){
      showMove = true;
      showAtk = true;
      showAtkFull = true;
    } else {
      showMove = mActive ? true : canMove;
      if(dActive){
        showAtk = true;
        showAtkFull = true;
      } else {
        showAtk = canAtk && enemyInRange;
        showAtkFull = false;
      }
    }
    return { showMove, showAtk, showAtkFull };
  }

  function updateDamagePreview(){
    if(!damagePreviewEl){
      return;
    }
    damagePreviewEl.style.display = "none";
    if(!qKeyHeld) return;
    if(!Game.sel || Game.sel.type!=="unit") return;
    const su = Game.sel.unit;
    if(!canAttackThisTurn(su)) return;
    const {x,y} = Game.hovered;
    const target = unitAt(x,y);
    if(!target || target.owner===su.owner) return;
    const atkKey = key(target.x, target.y);
    if(!Game.atkTiles || !Game.atkTiles.has(atkKey)) return;

    const atkRange = computeDamageMinMax(su, target, su.hp);
    let retMin = 0, retMax = 0;
    let retText = "Retal Range: None";
    if(canRetaliate(target, su)){
      const hpAfterMax = Math.max(0, target.hp - atkRange.max);
      const hpAfterMin = Math.max(0, target.hp - atkRange.min);
      if(hpAfterMax>0){
        const rMin = computeDamageMinMax(target, su, hpAfterMax);
        retMin = rMin.min;
      }
      if(hpAfterMin>0){
        const rMax = computeDamageMinMax(target, su, hpAfterMin);
        retMax = rMax.max;
      }
      if(retMin>0 || retMax>0){
        retText = `Retal Range: ${retMin} to ${retMax}`;
      }
    }
    damagePreviewEl.innerHTML = `<div class="previewHeader">Attack Info</div>
                                 <div class="previewRow"><img src="assets/damage_2.png" class="previewIcon" alt="Dmg"><span>${atkRange.min} to ${atkRange.max}</span></div>
                                 <div class="previewRow" style="margin-bottom:0"><img src="assets/retal.png" class="previewIcon" alt="Retal"><span>${retText.replace("Retal Range: ","")}</span></div>`;

    const rect = canvas.getBoundingClientRect();
    const px = target.x * TILE + TILE/2;
    const py = target.y * TILE + TILE/2;
    damagePreviewEl.style.left = `${rect.left + px}px`;
    damagePreviewEl.style.top = `${rect.top + py - 8}px`;
    damagePreviewEl.style.transform = "translate(-50%, -100%)";
    damagePreviewEl.style.display = "block";
  }

  function unitMoveBonus(u){
    const co = getCOChoice(u.owner);
    const state = Game.coState[u.owner];
    let bonus = 0;
    if(co.id==="MAX" && isDirectUnit(u)){
      if(state==="SUPER") bonus += 2;
      else if(state==="POWER") bonus += 1;
    }
    if(co.id==="SAMI" && isInfantry(u)){
      if(state==="SUPER") bonus += 2;
      else if(state==="POWER") bonus += 1;
    }
    if(co.id==="ANDY" && state==="SUPER"){
      bonus += 1;
    }
    return bonus;
  }

  function unitMovePoints(u){
    return u.def.move + unitMoveBonus(u);
  }

  function getRangeForUnit(u){
    let minR = u.def.rangeMin;
    let maxR = u.def.rangeMax;
    const co = getCOChoice(u.owner);
    if(co.id==="MAX" && u.def.indirect){
      maxR = Math.max(minR, maxR-1);
    }
    return { minR, maxR };
  }

  function getDamageRangeEntry(attackerId, defenderId){
    const table = DAMAGE_TABLE[attackerId];
    if(!table) return null;
    return table[defenderId] || null;
  }

  const CUSTOM_DAMAGE_TEXT = {
    BC: "Damage: FTR 1-2 • BMB 2-3 • B-CPT 4-5 • T-CPT 8-9",
    FTR: "Damage: FTR 5-6 • BMB 10 • B-CPT 10 • T-CPT 10",
    BMB: "Damage: BSH 5-6 • CRU 5-6 • LND 9-10 • SUB 9-10 • INF 10 • RCN 10 • TNK 10 • MDT 9-10 • ART 10 • RKT 10 • APC 10",
    TC: "Damage: N/A"
  };

  function damageProfileText(attackerId){
    if(CUSTOM_DAMAGE_TEXT[attackerId]) return CUSTOM_DAMAGE_TEXT[attackerId];
    const order = ["INF","RECON","TANK","MDT","ART","RKT","APC","CRU","SUB","BSH","LND","FTR","BC","TC","BMB"];
    const table = DAMAGE_TABLE[attackerId];
    if(!table) return "Damage: —";
    const parts = [];
    for(const tid of order){
      const rng = table[tid];
      if(!rng) continue;
      const [a,b] = rng;
      const label = UNIT_DEF[tid]?.abbr || tid;
      parts.push(`${label} ${a}${a===b ? "" : `-${b}`}`);
    }
    return "Damage: " + parts.join(" • ");
  }

  // Show attack range text
  function formatRangeText(rangeMin, rangeMax){
    return `${rangeMin}-${rangeMax}`;
  }

  function formatStars(count){
    const stars = count>0 ? "⭐".repeat(count) : "—";
    return stars;
  }

  function damageRangeSimple(attackerId){
    const table = DAMAGE_TABLE[attackerId];
    if(!table) return {min:0, max:0};
    let min = Infinity, max = -Infinity;
    for(const rng of Object.values(table)){
      if(!rng) continue;
      min = Math.min(min, rng[0]);
      max = Math.max(max, rng[1]);
    }
    if(min===Infinity) return {min:0,max:0};
    return {min, max};
  }

  function damageDisplayText(attackerId){
    const def = UNIT_DEF[attackerId];
    if(def && def.canAttack===false) return "Damage: N/A";
    if(Game.dmgDetail){
      return damageProfileText(attackerId);
    }
    const {min,max} = damageRangeSimple(attackerId);
    return `Damage: ${min}-${max}`;
  }

  function attackMultiplier(attacker, defender){
    const co = getCOChoice(attacker.owner);
    const state = Game.coState[attacker.owner];
    const direct = isDirectUnit(attacker);
    let mult = 1;
    if(co.id==="MAX"){
      if(direct){
        if(state==="SUPER") mult = 1.6;
        else if(state==="POWER") mult = 1.4;
        else mult = 1.2;
      }
    }
    if(co.id==="SAMI" && isInfantry(attacker)){
      if(state==="SUPER") mult = 1.6;
      else if(state==="POWER") mult = 1.5;
      else mult = 1.2;
    }
    if(co.id==="ANDY" && state==="SUPER"){
      mult *= 1.2;
    }
    return mult;
  }

  function luckBonus(attacker){
    const co = getCOChoice(attacker.owner);
    const state = Game.coState[attacker.owner];
    if(co.id!=="NELL") return 0;
    if(state==="SUPER") return randInt(7); // 0-6
    if(state==="POWER") return randInt(5); // 0-4
    return randInt(3); // 0-2
  }

  /***********************************************************************
   * Combat
   ***********************************************************************/
  function terrainDefenseBonus(x,y){
    // Number of defense stars on the tile; converted to a flat % reduction elsewhere.
    const stars = tileDefenseStat(x,y);
    return stars;
  }

  function hpDamageMultiplier(hp){
    // Piecewise linear scaling based on given breakpoints.
    if(hp>=10) return 1;
    if(hp>=8) return 0.8 + (hp-8)*( (1-0.8)/2 );   // 8-10 -> 0.8-1
    if(hp>=5) return 0.5 + (hp-5)*( (0.8-0.5)/3 ); // 5-8 -> 0.5-0.8
    if(hp>=1) return 0.1 + (hp-1)*( (0.5-0.1)/4 ); // 1-5 -> 0.1-0.5
    return 0.1;
  }

  function roundDamage(val){
    return Math.floor(val + 0.5);
  }

  function allyCoverPct(unit){
    if(!unit) return 0;
    let count = 0;
    for(const d of DIRS){
      const nx = unit.x + d.dx;
      const ny = unit.y + d.dy;
      const u = unitAt(nx, ny);
      if(u && u.owner===unit.owner) count += 1;
    }
    return clamp(count * 0.05, 0, 0.2); // up to 20% reduction from nearby allies
  }

  function computeDamageRoll(attacker, defender, attackerHpOverride=null){
    if(!canTarget(attacker, defender)) return { roll:0, min:0, max:0, stars:0, guardPct:0 };
    const stars = terrainDefenseBonus(defender.x, defender.y);
    const guardPct = allyCoverPct(defender);
    // Terrain + nearby ally cover reduce damage independently of HP.
    const defScale = (1 - clamp(stars * 0.1, 0, 0.9)) * (1 - guardPct);
    const mult = attackMultiplier(attacker, defender);
    const atkHp = attackerHpOverride ?? attacker.hp ?? attacker.def?.maxHP ?? 10;
    const hpMult = hpDamageMultiplier(atkHp);

    const entry = getDamageRangeEntry(attacker.def.id, defender.def.id);
    if(entry){
      const [minBase, maxBase] = entry;

      const scaledMin = minBase * mult * defScale * hpMult;
      const scaledMax = maxBase * mult * defScale * hpMult;

      let min = clamp(roundDamage(scaledMin), 0, defender.def.maxHP);
      let max = clamp(roundDamage(scaledMax), min, defender.def.maxHP);
      let roll = clamp(randBetween(min, max), min, defender.def.maxHP);
      if(roll>0) roll = Math.max(1, roll);
      return { roll, min, max, stars, guardPct };
    }

    // Fallback to legacy calculation if a matchup isn't defined.
    const atkBase = attacker.def.baseAtk[defender.def.id] ?? 4;
    let raw = atkBase * mult * defScale * hpMult;

    let min = Math.max(0, roundDamage(raw * 0.85));
    let max = Math.max(min, roundDamage(raw * 1.15));
    let roll = clamp(randBetween(min, max), min, defender.def.maxHP);
    if(roll>0) roll = Math.max(1, roll);
    return { roll, min, max, stars, guardPct };
  }

  function computeDamageMinMax(attacker, defender, attackerHpOverride=null){
    if(!canTarget(attacker, defender)) return { min:0, max:0 };
    const stars = terrainDefenseBonus(defender.x, defender.y);
    const guardPct = allyCoverPct(defender);
    const defScale = (1 - clamp(stars * 0.1, 0, 0.9)) * (1 - guardPct);
    const mult = attackMultiplier(attacker, defender);
    const atkHp = attackerHpOverride ?? attacker.hp ?? attacker.def?.maxHP ?? 10;
    const hpMult = hpDamageMultiplier(atkHp);

    const entry = getDamageRangeEntry(attacker.def.id, defender.def.id);
    if(entry){
      const [minBase, maxBase] = entry;
      let min = clamp(roundDamage(minBase * mult * defScale * hpMult), 0, defender.def.maxHP);
      let max = clamp(roundDamage(maxBase * mult * defScale * hpMult), min, defender.def.maxHP);
      if(max>0) min = Math.max(1, min);
      return { min, max };
    }

    const atkBase = attacker.def.baseAtk[defender.def.id] ?? 4;
    let rawMin = atkBase * mult * defScale * hpMult * 0.85;
    let rawMax = atkBase * mult * defScale * hpMult * 1.15;
    let min = Math.max(0, roundDamage(rawMin));
    let max = Math.max(min, roundDamage(rawMax));
    if(max>0) min = Math.max(1, min);
    return { min, max };
  }

  function previewDamageRange(def){
    const table = DAMAGE_TABLE[def.id];
    if(table){
      let min = Infinity, max = -Infinity;
      for(const rng of Object.values(table)){
        if(!rng) continue;
        min = Math.min(min, rng[0]);
        max = Math.max(max, rng[1]);
      }
      if(min!==Infinity && max!==-Infinity){
        return { min, max };
      }
    }
    const vals = Object.values(def.baseAtk || {});
    const low = vals.length ? Math.min(...vals) : 4;
    const high = vals.length ? Math.max(...vals) : 4;
    const min = Math.max(0, Math.floor(low * 0.85));
    const max = Math.max(min, Math.ceil(high * 1.15));
    return { min, max };
  }

  function canRetaliate(defender, attacker){
    if(defender.def.indirect) return false;
    if(!canTarget(defender, attacker)) return false;
    const d = manhattan({x:defender.x,y:defender.y},{x:attacker.x,y:attacker.y});
    const { minR, maxR } = getRangeForUnit(defender);
    return d>=minR && d<=maxR;
  }

  function damageLabel(roll, min, max, prefix="", stars=0, guardPct=0){
    const span = (max - min) || 1;
    const hi = max - Math.max(1, Math.floor(span*0.2));
    const lo = min + Math.floor(span*0.2);
    const coverPct = Math.round(stars*10 + guardPct*100);
    const cover = coverPct>0 ? ` (Cover -${coverPct}%` : "";
    return `${prefix}${roll} Damage Dealt${cover ? cover + ")" : ""}`;
  }

  async function performAttack(attacker, defender){
    if(Game.gameOver) return;
    if(attacker.acted) return;
    if(isIndirectUnit(attacker) && attacker.moved) return;
    if(!canTarget(attacker, defender)) return;

    const defBefore = defender.hp;
    const atkBefore = attacker.hp;

    const atkRoll = computeDamageRoll(attacker, defender, attacker.hp);
    const dmgToDef = atkRoll.roll;
    const atkMin = atkRoll.min;
    const atkMax = atkRoll.max;
    const atkStars = atkRoll.stars || 0;
    const atkGuard = atkRoll.guardPct || 0;
    const newDefHP = clamp(defender.hp - dmgToDef, 0, defender.def.maxHP);

    let dmgToAtk = 0, defMin=0, defMax=0;
    let newAtkHP = atkBefore;
    let defStars = 0, defGuard = 0;
    if(canRetaliate(defender, attacker) && newDefHP>0){
      const res = computeDamageRoll(defender, attacker, newDefHP);
      dmgToAtk = res.roll; defMin = res.min; defMax = res.max; defStars = res.stars || 0; defGuard = res.guardPct || 0;
      newAtkHP = clamp(attacker.hp - dmgToAtk, 0, attacker.def.maxHP);
    }

    grantCOMeter(attacker.owner, 15);
    if(dmgToAtk>0) grantCOMeter(defender.owner, 10);

    const leftText = damageLabel(dmgToDef, atkMin, atkMax, "", atkStars, atkGuard);
    const rightText = dmgToAtk>0 ? damageLabel(dmgToAtk, defMin, defMax, "Retaliated ", defStars, defGuard) : "No Retaliation";

    const skipOverlay = Game.botMode!=="HUMAN" && attacker.owner===2 && defender.owner===1;
    if(!skipOverlay){
      await showBattleOverlay({
        attacker,
        defender,
        atkBefore,
        atkAfter: newAtkHP,
        defBefore,
        defAfter: newDefHP,
        attackerLabel: `${attacker.def.name}`,
        defenderLabel: `${defender.def.name}`,
        attackerImg: getUnitSpriteSrc(attacker),
        defenderImg: getUnitSpriteSrc(defender),
        atkMax: attacker.def.maxHP,
        defMax: defender.def.maxHP,
        leftText,
        rightText
      });
    }

    defender.hp = newDefHP;
    logLine(`${owningPlayer(attacker.owner).name} ${attacker.def.name} hits ${defender.def.name} for ${dmgToDef} (roll ${atkMin}-${atkMax}).`, attacker.owner);

    if(defender.hp<=0){
      logLine(`${defender.def.name} destroyed.`, attacker.owner);
      removeUnit(defender);
      attacker.acted = true;
      return;
    }

    if(dmgToAtk>0){
      attacker.hp = newAtkHP;
      logLine(`${defender.def.name} retaliates for ${dmgToAtk} (roll ${defMin}-${defMax}).`, defender.owner);

      if(attacker.hp<=0){
        logLine(`${attacker.def.name} destroyed.`, defender.owner);
        removeUnit(attacker);
      } else {
        consumeAction(attacker);
      }
    } else {
      consumeAction(attacker);
    }

    renderCOSection();
  }

  /***********************************************************************
   * Capture Mechanics
   ***********************************************************************/
  async function tryCapture(unit){
    if(!unit.def.canCapture) return false;

    const b = buildingAt(unit.x, unit.y);
    if(!b) return false;

    if(b.owner === unit.owner && b.capturePoints===20) return false;

    const co = getCOChoice(unit.owner);
    const state = Game.coState[unit.owner];
    const before = b.capturePoints;
    let capturePower = unit.hp;
    if(co.id==="SAMI"){
      if(state==="SUPER"){
        capturePower = 99; // one-turn capture
      } else if(state==="POWER"){
        capturePower = unit.hp * 2;
      } else {
        capturePower = Math.floor(unit.hp * 1.5);
      }
    }
    const after = clamp(b.capturePoints - capturePower, 0, 20);

    const captureDelta = before - after;
    const capOverlay = {
      attacker: unit,
      defender: b,
      atkBefore: unit.hp,
      atkAfter: unit.hp,
      defBefore: before,
      defAfter: after,
      attackerLabel: `${unit.def.name}`,
      defenderLabel: `${b.def.name}`,
      attackerImg: getUnitSpriteSrc(unit),
      defenderImg: (getBuildingSprite(b.kindId, b.owner ?? 0)||{}).src || "",
      atkMax: unit.def.maxHP,
      defMax: 20,
      leftText: `Capture -${captureDelta} Points`,
      rightText: "No Retaliation"
    };

    // Ensure blue on left, red on right for capture overlay too.
    if(unit.owner===2){
      const swapped = {
        attacker: b,
        defender: unit,
        atkBefore: before,
        atkAfter: after,
        defBefore: unit.hp,
        defAfter: unit.hp,
        attackerLabel: `${b.def.name}`,
        defenderLabel: `${unit.def.name}`,
        attackerImg: capOverlay.defenderImg,
        defenderImg: capOverlay.attackerImg,
        atkMax: 20,
        defMax: unit.def.maxHP,
        leftText: capOverlay.leftText,
        rightText: capOverlay.rightText
      };
      await showBattleOverlay(swapped);
    } else {
      await showBattleOverlay(capOverlay);
    }

    grantCOMeter(unit.owner, 20);
    consumeAction(unit);

    b.capturePoints = after;
    logLine(`${owningPlayer(unit.owner).name} captures ${b.def.name}: ${b.capturePoints}/20 remaining.`, unit.owner);

    if(b.capturePoints<=0){
      b.owner = unit.owner;
      b.capturePoints = 20;
      logLine(`${b.def.name} captured by ${owningPlayer(unit.owner).name}.`, unit.owner);

      if(b.kindId==="HQ"){
        declareWinner(unit.owner, "HQ captured");
        logLine(`${owningPlayer(unit.owner).name} wins by capturing the HQ.`, unit.owner);
      }
    }

    unit.acted = true;
    return true;
  }

  /***********************************************************************
   * Building / Shop
   ***********************************************************************/
  // UPDATED: include new units; keep existing list concept
  const SHOP_UNITS = ["INF","APC","RECON","TANK","MDT","ART","RKT"];
  const SHOP_CATEGORIES = {
    LAND: ["INF","APC","RECON","TANK","MDT","ART","RKT"],
    AIR: ["FTR","BC","TC","BMB"],
    WATER: ["LND","CRU","SUB","BSH"]
  };
  const PRODUCTION_BUILDINGS = new Set(["BASE","AIRPORT","SHIPPORT"]);
  const CATEGORY_LABEL = { LAND:"land", AIR:"air", WATER:"naval" };

  function unitCategory(typeId){
    for(const [cat, ids] of Object.entries(SHOP_CATEGORIES)){
      if(ids.includes(typeId)) return cat;
    }
    return null;
  }

  function allowedCategoriesForBuilding(b, playerId){
    if(!b || b.owner!==playerId) return [];
    if(PRODUCTION_BUILDINGS.has(b.kindId)){
      if(b.kindId==="AIRPORT") return ["AIR"];
      if(b.kindId==="SHIPPORT") return ["WATER"];
      return ["LAND"];
    }
    const co = getCOChoice(playerId);
    const state = Game.coState[playerId];
    if(co.id==="HACHI" && state==="SUPER" && b.kindId==="CITY") return ["LAND"];
    return [];
  }

  function primaryCategoryForBuilding(b, playerId){
    const cats = allowedCategoriesForBuilding(b, playerId);
    if(cats.length) return cats[0];
    return Game.shopCategory || "LAND";
  }

  function isUnitAllowedAtBuilding(typeId, b, playerId){
    const cats = allowedCategoriesForBuilding(b, playerId);
    if(!cats.length) return false;
    const cat = unitCategory(typeId);
    if(!cat) return false;
    return cats.includes(cat);
  }

  function canBuildFromBuilding(b, playerId){
    return allowedCategoriesForBuilding(b, playerId).length>0;
  }

  function hachiCostMultiplier(playerId){
    const co = getCOChoice(playerId);
    if(!co || co.id!=="HACHI") return 1;
    const state = Game.coState[playerId];
    if(state==="POWER" || state==="SUPER") return 0.5;
    return 0.9; // day-to-day passive
  }

  function getUnitCost(def, playerId){
    const mult = hachiCostMultiplier(playerId);
    return Math.floor(def.cost * mult);
  }

  function openShopIfOnOwnedBase(){
    if(Game.gameOver) return;
    if(!Game.sel || Game.sel.type!=="building") return;
    const b = Game.sel.building;
    if(!canBuildFromBuilding(b, Game.currentPlayer)) return;

    Game.shopCategory = primaryCategoryForBuilding(b, Game.currentPlayer);
    Game.phase = "SHOP";
    shopBox.style.display = "block";
    renderShop();
    updateHelpPosition();
  }

  function closeShop(){
    if(Game.phase==="SHOP"){
      Game.phase = "IDLE";
    }
    shopBox.style.display = "block";
    renderShop();
    updateHelpPosition();
  }

  function renderShop(){
    shopList.innerHTML = "";
    const funds = Game.funds[Game.currentPlayer];
    const validSel = Game.sel && Game.sel.type==="building" && canBuildFromBuilding(Game.sel.building, Game.currentPlayer);
    const baseX = validSel ? Game.sel.x : -1;
    const baseY = validSel ? Game.sel.y : -1;
    const allowedCats = validSel ? allowedCategoriesForBuilding(Game.sel.building, Game.currentPlayer) : [];
    const buildingLabel = validSel ? Game.sel.building.def.name : "Base";

    if(validSel && allowedCats.length && !allowedCats.includes(Game.shopCategory)){
      Game.shopCategory = allowedCats[0];
    }

    if(!validSel){
      shopHint.textContent = "Select your owned production building to build." + (getCOChoice(Game.currentPlayer).id==="HACHI" && Game.coState[Game.currentPlayer]==="SUPER" ? " (Cities allowed with Hachi Super)" : "");
    } else if(!allowedCats.length){
      shopHint.textContent = `${buildingLabel} cannot produce units right now.`;
    } else if(unitAt(baseX, baseY)){
      shopHint.textContent = `${buildingLabel} is occupied; move the unit off to build.`;
    } else {
      const catText = allowedCats.map(c=>CATEGORY_LABEL[c] || c.toLowerCase()).join(" / ");
      shopHint.textContent = `Build ${catText} units on your ${buildingLabel}${Game.sel.building.kindId==="CITY" ? " (Hachi Super)" : ""} (tile must be empty).`;
    }

    // category buttons
    const catRow = document.createElement("div");
    catRow.className = "row";
    catRow.style.justifyContent = "center";
    catRow.style.flexWrap = "wrap";
    catRow.style.gap = "6px";
    const makeCatBtn = (cat, label)=>{
      const btn = document.createElement("button");
      btn.className = "btn" + (Game.shopCategory===cat ? " primary" : "");
      btn.textContent = label;
      btn.disabled = validSel && allowedCats.length>0 && !allowedCats.includes(cat);
      btn.addEventListener("click", ()=>{
        if(!btn.disabled){
          Game.shopCategory = cat;
          renderShop();
        }
      });
      return btn;
    };
    catRow.appendChild(makeCatBtn("LAND","Land"));
    catRow.appendChild(makeCatBtn("AIR","Air"));
    catRow.appendChild(makeCatBtn("WATER","Water"));
    shopList.appendChild(catRow);

    const ids = SHOP_CATEGORIES[Game.shopCategory] || [];
    if(!ids.length){
      const empty = document.createElement("div");
      empty.className = "meta";
      empty.style.textAlign = "center";
      empty.style.marginTop = "10px";
      empty.textContent = "No units available in this category yet.";
      shopList.appendChild(empty);
    }
    for(const id of ids){
        const def = UNIT_DEF[id];
        if(!def) continue;
        const price = getUnitCost(def, Game.currentPlayer);
        const canAfford = funds >= price;
        const occupied = validSel && unitAt(baseX, baseY) !== null;
        const allowedHere = validSel ? isUnitAllowedAtBuilding(id, Game.sel.building, Game.currentPlayer) : false;

        const div = document.createElement("div");
        div.className = "shopItem";

        const left = document.createElement("div");
        left.style.display = "grid";
        left.style.gridTemplateColumns = "64px 1fr";
        left.style.gap = "10px";
        const sprite = makeSpriteNode(id, Game.currentPlayer, 64);
        left.appendChild(sprite);

        const info = document.createElement("div");
        const role = def.indirect ? "Indirect fire" : (def.canAttack===false ? "No attack" : "Direct fire");
        const rangeLabel = formatRangeText(def.rangeMin, def.rangeMax);
        info.innerHTML = `<div class="name">${def.name} <span class="abbr">${def.abbr}</span></div>`;
        const statRow = document.createElement("div");
        statRow.className = "shopStats";
        statRow.style.marginTop = "8px";
        const dmgPill = document.createElement("span");
        dmgPill.className = "pill warn";
        dmgPill.style.cursor = "pointer";
        const setDmgText = ()=>{ dmgPill.textContent = damageDisplayText(def.id); };
        setDmgText();
        dmgPill.title = "Click to toggle detailed damage view";
        dmgPill.addEventListener("click", ()=>{
          Game.dmgDetail = !Game.dmgDetail;
          renderShop();
        });
        statRow.appendChild(dmgPill);

        const capPill = document.createElement("span");
        capPill.className = "pill " + (def.canCapture ? "good" : "");
        capPill.textContent = def.canCapture ? "Can capture" : "No capture";
        statRow.appendChild(capPill);

        const blurb = UNIT_BLURB[def.id];
        if(blurb){
          const desc = document.createElement("div");
          desc.className = "meta";
          desc.textContent = blurb;
          desc.style.marginBottom = "6px";
          info.appendChild(desc);
        }

        const moveRow = document.createElement("div");
        moveRow.className = "shopStats";
        moveRow.style.marginTop = "6px";
        const movePill = document.createElement("span");
        movePill.className = "pill good";
        movePill.textContent = `Move ${def.move} (${def.movementType})`;
        const rangePill = document.createElement("span");
        rangePill.className = "pill";
        rangePill.style.background = "#152252";
        rangePill.textContent = `Range ${rangeLabel}`;
        const rolePill = document.createElement("span");
        rolePill.className = "pill warn";
        rolePill.textContent = role;
        moveRow.appendChild(movePill);
        moveRow.appendChild(rangePill);
        moveRow.appendChild(rolePill);

        info.appendChild(statRow);
        info.appendChild(moveRow);
        left.appendChild(info);
        div.appendChild(left);

        const right = document.createElement("div");
        right.style.display = "flex";
        right.style.flexDirection = "column";
        right.style.alignItems = "flex-end";
        right.style.gap = "6px";
        const pill = document.createElement("span");
        pill.className = "pill " + (canAfford ? "good" : "bad");
        pill.textContent = canAfford ? "Affordable" : "Too expensive";
        right.appendChild(pill);

        const btn = document.createElement("button");
        btn.className = "btn good";
        btn.style.marginLeft = "0";
        btn.textContent = `$${price}`;
        btn.disabled = (!canAfford) || occupied || !validSel || !allowedHere;

        btn.addEventListener("click", ()=>{
          buildUnitAtBase(id, baseX, baseY);
        });

        right.appendChild(btn);
        div.appendChild(right);

        shopList.appendChild(div);
      }
  }

  function buildUnitAtBase(typeId, x, y){
    if(Game.gameOver) return;

    const b = buildingAt(x,y);
    if(!b || !canBuildFromBuilding(b, Game.currentPlayer)) return;

    if(unitAt(x,y)){
      logLine("Cannot build: production tile occupied.", Game.currentPlayer);
      return;
    }

    const def = UNIT_DEF[typeId];
    if(!def){
      logLine("Cannot build: unknown unit type.", Game.currentPlayer);
      return;
    }
    if(!isUnitAllowedAtBuilding(typeId, b, Game.currentPlayer)){
      logLine("Cannot build: that unit type cannot deploy from this building.", Game.currentPlayer);
      return;
    }
    const price = getUnitCost(def, Game.currentPlayer);
    if(Game.funds[Game.currentPlayer] < price){
      logLine("Cannot build: insufficient funds.", Game.currentPlayer);
      return;
    }

    Game.funds[Game.currentPlayer] -= price;
    const u = makeUnit(typeId, Game.currentPlayer, x, y);
    u.moved = true;
    u.acted = true;

    Game.units.push(u);
      logLine(`${owningPlayer(Game.currentPlayer).name} builds ${def.name} for $${price}.`, Game.currentPlayer);

    updateUI();
    renderShop();
  }

  /***********************************************************************
   * NEW: Key/Legend
   ***********************************************************************/
  function openKey(){
    keyBox.style.display = "block";
    renderLegend();
    updateHelpPosition();
  }
  function closeKey(){
    keyBox.style.display = "none";
    updateHelpPosition();
  }
  function toggleKey(){
    if(keyBox.style.display === "block") closeKey();
    else openKey();
  }

  function renderLegend(){
    terrainLegend.innerHTML = "";
    unitLegend.innerHTML = "";

    const terrainItems = [TERRAIN.PLAINS, TERRAIN.ROAD, TERRAIN.FOREST, TERRAIN.MOUNTAIN, TERRAIN.WATER];
    for(const t of terrainItems){
      const row = document.createElement("div");
      row.className = "legendRow";

      const left = document.createElement("div");
      left.style.display = "flex";
      left.style.alignItems = "center";
      left.style.gap = "10px";

      const sw = document.createElement("span");
      sw.className = "swatch";
      const img = getTerrainSprite(t.id);
      if(img){
        sw.style.backgroundImage = `url(${img.src})`;
        sw.style.backgroundSize = "cover";
      } else {
        sw.style.background = t.color;
      }

      const label = document.createElement("div");
      label.innerHTML = `<div style="font-weight:800">${t.name}</div><div class="muted" style="font-size:12px">Move: foot ${t.moveCost.foot}, tread ${t.moveCost.tread}, tires ${t.moveCost.tires ?? "—"}, sea ${t.moveCost.sea ?? "—"}</div>`;

      left.appendChild(sw);
      left.appendChild(label);

      const right = document.createElement("div");
      const stars = defenseStarsForTerrainId(t.id);
      right.innerHTML = `<span class="pill">Cover: ${formatStars(stars)}</span>`;

      row.appendChild(left);
      row.appendChild(right);

      terrainLegend.appendChild(row);
    }

    for(const id of Object.keys(UNIT_DEF)){
      const u = UNIT_DEF[id];
      const row = document.createElement("div");
      row.className = "legendRow";

      const left = document.createElement("div");
      const rangeLabel = formatRangeText(u.rangeMin, u.rangeMax);
      const blurb = UNIT_BLURB[u.id];
      left.innerHTML = `<div style="font-weight:800">${u.name} <span class="abbr">${u.abbr}</span></div>
                        <div class="muted" style="font-size:12px">Cost ${u.cost} • Move ${u.move} • Range ${rangeLabel}${u.indirect ? " (Indirect)" : ""}</div>
                        ${blurb ? `<div class="muted" style="font-size:12px">${blurb}</div>` : ""}`;
      const right = document.createElement("div");
      right.innerHTML = `<span class="pill ${u.canCapture ? "good" : ""}">${u.canCapture ? "Can capture" : "No capture"}</span>`;

      row.appendChild(left);
      row.appendChild(right);
      unitLegend.appendChild(row);
    }
  }

  /***********************************************************************
   * Input Handling
   ***********************************************************************/
  function canvasToGrid(mx,my){
    const rect = canvas.getBoundingClientRect();
    const x = Math.floor((mx - rect.left) * (canvas.width / rect.width) / TILE);
    const y = Math.floor((my - rect.top) * (canvas.height / rect.height) / TILE);
    return {x,y};
  }

  async function onLeftClickGrid(x,y){
    if(Game.gameOver) return;

    if(Game.phase==="SHOP"){
      if(!(Game.sel && Game.sel.type==="building" && Game.sel.x===x && Game.sel.y===y)){
        closeShop();
      }
    }

    const u = unitAt(x,y);
    const b = buildingAt(x,y);

    if(Game.sel && Game.sel.type==="unit"){
      const su = Game.sel.unit;

      if(su.owner === Game.currentPlayer){
        const clickedKey = key(x,y);
        if(!su.moved && Game.moveTiles.has(clickedKey) && !(x===su.x && y===su.y)){
          const occ = unitAt(x,y);
          if(occ && occ.uid!==su.uid) return;

          const destK = key(x,y);
          const path = reconstructPath(destK);

          su.x = x; su.y = y;
          su.animMove = { path, start: performance.now(), step: 200 };
          su.moved = true;

          logLine(`${owningPlayer(su.owner).name} moves ${su.def.name}.`, su.owner);

          Game.atkTiles = computeAttackTilesFromPosition(su, {x,y});
          Game.phase = canAttackThisTurn(su) ? "ATTACKING" : "IDLE";
          computeAttackOverlayIfApplicable();
          updateSelectionPanel();
          updateUI();
          return;
        }

        // Boarding: infantry -> adjacent friendly APC
        const targetUnit = unitAt(x,y);
        if(targetUnit && targetUnit.owner===su.owner && targetUnit.def.transport && canLoadIntoTransport(targetUnit, su) && adjacent({x:su.x,y:su.y},{x,y})){
          const cargoObj = { typeId: su.typeId, owner: su.owner, hp: su.hp, spriteIdx: su.spriteIdx, def: su.def };
          if(Array.isArray(targetUnit.cargo)){
            targetUnit.cargo.push(cargoObj);
          } else if(targetUnit.cargo){
            targetUnit.cargo = [targetUnit.cargo, cargoObj];
          } else {
            targetUnit.cargo = [cargoObj];
          }
          removeUnit(su);
          logLine(`${owningPlayer(targetUnit.owner).name} loads ${cargoObj.def.name} into ${targetUnit.def.name}.`, targetUnit.owner);
          selectUnit(targetUnit);
          updateUI();
          return;
        }

        if(!su.acted){
          if(canAttackThisTurn(su) && Game.atkTiles.has(clickedKey) && enemyInRangeAt(su,clickedKey)){
            const target = unitAt(x,y);
            if(target){
              await performAttack(su, target);

              if(!Game.units.some(z=>z.uid===su.uid)){
                clearSelection();
              } else {
                updateSelectionPanel();
              }
              computeAttackOverlayIfApplicable();
              updateUI();
              return;
            }
          }

          if(x===su.x && y===su.y){
            const did = await tryCapture(su);
            if(did){
              computeAttackOverlayIfApplicable();
              updateSelectionPanel();
              updateUI();
              return;
            }
          }
        }
      }
    }

    // selection order: unit -> building -> tile
    if(u){
      // Unload if transport with cargo and clicking adjacent empty tile
      if(u.def.transport && u.owner===Game.currentPlayer && u.cargo && !unitAt(x,y) && adjacent({x:u.x,y:u.y},{x,y})){
        if(unloadCargo(u,x,y)) return;
      }
      selectUnit(u);
      return;
    }
    if(b){
      selectBuilding(b, x, y);
      return;
    }

    // NEW: select empty tile instead of clearing (so defense stat shows)
    selectTile(x,y);
    updateUI();
  }

  function onRightClick(e){
    e.preventDefault();
    // allow right-click unload for transport cargo
    if(Game.sel && Game.sel.type==="unit"){
      const u = Game.sel.unit;
      const g = canvasToGrid(e.clientX, e.clientY);
      if(u.def.transport && u.cargo && inBounds(g.x,g.y)){
        if(unloadCargo(u, g.x, g.y)) return;
      }
    }
    closeShop();
    closeKey();
    clearSelection();
    updateUI();
  }

  canvas.addEventListener("mousemove", (e)=>{
    const g = canvasToGrid(e.clientX, e.clientY);
    Game.hovered = g;

    if(Game.sel && Game.sel.type==="unit" && Game.moveTiles.size && Game.moveTiles.has(key(g.x,g.y))){
      Game.path = reconstructPath(key(g.x,g.y));
    } else {
      Game.path = [];
    }
    updateDamagePreview();
  });
  canvas.addEventListener("mouseleave", ()=>{
    Game.hovered = {x:-1,y:-1};
    if(damagePreviewEl) damagePreviewEl.style.display = "none";
  });

  canvas.addEventListener("mousedown", async (e)=>{
    if(e.button===2) return;
    const g = canvasToGrid(e.clientX, e.clientY);
    if(!inBounds(g.x,g.y)) return;
    await onLeftClickGrid(g.x,g.y);
  });

  canvas.addEventListener("contextmenu", onRightClick);

  window.addEventListener("keydown", (e)=>{
    if(nameEditActive){
      return;
    }
    if(e.key==="s" || e.key==="S"){
      sKeyHeld = true;
      updateRangePreview();
    } else if(e.key==="d" || e.key==="D"){
      dKeyHeld = true;
      updateRangePreview();
    } else if(e.key==="m" || e.key==="M"){
      mKeyHeld = true;
      updateRangePreview();
    } else if(e.key==="q" || e.key==="Q"){
      qKeyHeld = true;
      updateDamagePreview();
    }
    if(e.key==="e" || e.key==="E"){
      endTurn();
    } else if(e.key==="b" || e.key==="B"){
      let choice = null;
      const g = Game.hovered;
      if(g && inBounds(g.x,g.y)){
        const hb = buildingAt(g.x,g.y);
        if(hb && hb.owner===Game.currentPlayer && PRODUCTION_BUILDINGS.has(hb.kindId)){
          choice = { b: hb, x: g.x, y: g.y };
        }
      }
      if(!choice){
        choice = pickNextBase(Game.currentPlayer);
      }
      if(choice){
        selectBuilding(choice.b, choice.x, choice.y);
        openShopIfOnOwnedBase();
      } else {
        logLine("No owned production building available to open shop.", Game.currentPlayer);
      }
    } else if(e.key==="k" || e.key==="K"){
      toggleKey();
    } else if(e.key==="Escape"){
      closeCOModal();
      closeShop();
      closeKey();
      clearSelection();
      updateUI();
      updateHelpPosition();
    }
  });
  window.addEventListener("keyup", (e)=>{
    if(e.key==="s" || e.key==="S"){
      sKeyHeld = false;
      updateRangePreview();
    } else if(e.key==="d" || e.key==="D"){
      dKeyHeld = false;
      updateRangePreview();
    } else if(e.key==="m" || e.key==="M"){
      mKeyHeld = false;
      updateRangePreview();
    } else if(e.key==="q" || e.key==="Q"){
      qKeyHeld = false;
      updateDamagePreview();
    }
  });
  window.addEventListener("blur", ()=>{
    sKeyHeld = false;
    sBtnHeld = false;
    dKeyHeld = false;
    dBtnHeld = false;
    mKeyHeld = false;
    mBtnHeld = false;
    updateRangePreview();
  });

  /***********************************************************************
   * UI Buttons
   ***********************************************************************/
  endTurnBtn.addEventListener("click", endTurn);
  newBtn.addEventListener("click", openMapPicker);
  resetBtn.addEventListener("click", hardReset);
  openShopBtn.addEventListener("click", ()=>{ autoOpenShopForCurrentPlayer(); });
  unselectBtn.addEventListener("click", ()=>{
    closeShop();
    closeKey();
    clearSelection();
    updateUI();
    updateHelpPosition();
  });
  closeShopBtn.addEventListener("click", ()=>{ closeShop(); updateUI(); });
  keyBtn.addEventListener("click", ()=>{ toggleKey(); });
  if(rangeBtn){
    rangeBtn.addEventListener("mousedown", ()=>{ sBtnHeld = true; updateRangePreview(); });
    rangeBtn.addEventListener("mouseup", ()=>{ sBtnHeld = false; updateRangePreview(); });
    rangeBtn.addEventListener("mouseleave", ()=>{ sBtnHeld = false; updateRangePreview(); });
    rangeBtn.addEventListener("touchstart", (e)=>{ e.preventDefault(); sBtnHeld = true; updateRangePreview(); });
    rangeBtn.addEventListener("touchend", ()=>{ sBtnHeld = false; updateRangePreview(); });
  }
  if(dmgBtn){
    dmgBtn.addEventListener("mousedown", ()=>{ dBtnHeld = true; updateRangePreview(); });
    dmgBtn.addEventListener("mouseup", ()=>{ dBtnHeld = false; updateRangePreview(); });
    dmgBtn.addEventListener("mouseleave", ()=>{ dBtnHeld = false; updateRangePreview(); });
    dmgBtn.addEventListener("touchstart", (e)=>{ e.preventDefault(); dBtnHeld = true; updateRangePreview(); });
    dmgBtn.addEventListener("touchend", ()=>{ dBtnHeld = false; updateRangePreview(); });
  }
  if(moveBtn){
    moveBtn.addEventListener("mousedown", ()=>{ mBtnHeld = true; updateRangePreview(); });
    moveBtn.addEventListener("mouseup", ()=>{ mBtnHeld = false; updateRangePreview(); });
    moveBtn.addEventListener("mouseleave", ()=>{ mBtnHeld = false; updateRangePreview(); });
    moveBtn.addEventListener("touchstart", (e)=>{ e.preventDefault(); mBtnHeld = true; updateRangePreview(); });
    moveBtn.addEventListener("touchend", ()=>{ mBtnHeld = false; updateRangePreview(); });
  }
  if(atkInfoBtn){
    atkInfoBtn.addEventListener("mousedown", ()=>{ qKeyHeld = true; updateDamagePreview(); });
    atkInfoBtn.addEventListener("mouseup", ()=>{ qKeyHeld = false; updateDamagePreview(); });
    atkInfoBtn.addEventListener("mouseleave", ()=>{ qKeyHeld = false; updateDamagePreview(); });
    atkInfoBtn.addEventListener("touchstart", (e)=>{ e.preventDefault(); qKeyHeld = true; updateDamagePreview(); });
    atkInfoBtn.addEventListener("touchend", ()=>{ qKeyHeld = false; updateDamagePreview(); });
  }
  if(botHumanBtn) botHumanBtn.addEventListener("click", ()=>setBotMode("HUMAN"));
  if(botEasyBtn) botEasyBtn.addEventListener("click", ()=>setBotMode("EASY"));
  if(botMedBtn) botMedBtn.addEventListener("click", ()=>setBotMode("MED"));
  if(botHardBtn) botHardBtn.addEventListener("click", ()=>setBotMode("HARD"));
  if(damagePreviewEl){
    // hide on mouse leave canvas or selection change handled elsewhere
  }
  closeKeyBtn.addEventListener("click", ()=>{ closeKey(); });
  if(p1ChooseCO) p1ChooseCO.addEventListener("click", ()=>openCOModal(1));
  if(p2ChooseCO) p2ChooseCO.addEventListener("click", ()=>openCOModal(2));
  if(p1COCard) p1COCard.addEventListener("click", ()=>openCOModal(1));
  if(p2COCard) p2COCard.addEventListener("click", ()=>openCOModal(2));
  function makeInlineNameEdit(el, playerId){
    if(!el) return;
    el.addEventListener("click", (e)=>{
      if(el.dataset.editing==="1") return;
      nameEditActive = true;
      el.dataset.editing = "1";
      const original = owningPlayer(playerId).name;
      const input = document.createElement("input");
      input.type = "text";
      input.value = original;
      input.className = "nameEditInput";
      input.maxLength = 20;
      const width = Math.max(120, el.offsetWidth || 0);
      input.style.width = `${width}px`;
      el.style.display = "none";
      el.parentElement.insertBefore(input, el.nextSibling);
      input.focus();
      input.select();

      function finish(commit){
        const val = commit ? input.value.trim() : original;
        setPlayerName(playerId, val || original, true);
        if(commit) saveGameState();
        cleanup();
      }
      function cleanup(){
        nameEditActive = false;
        el.style.display = "inline-block";
        if(input.parentElement) input.parentElement.removeChild(input);
        el.dataset.editing = "";
      }
      input.addEventListener("keydown", (ev)=>{
        if(ev.key==="Enter"){
          ev.preventDefault();
          finish(true);
        } else if(ev.key==="Escape"){
          ev.preventDefault();
          input.value = original;
          finish(false);
        }
      });
      input.addEventListener("blur", ()=>finish(true), { once:true });
    });
  }
  makeInlineNameEdit(p1NameLabel, 1);
  makeInlineNameEdit(p2NameLabel, 2);
  if(closeMapModal) closeMapModal.addEventListener("click", closeMapPicker);
  if(applyCustomMapBtn) applyCustomMapBtn.addEventListener("click", ()=>{
    Game.selectedMap = "CUSTOM";
    Game.customMapText = gridToTextWithUnits(customGrid, customUnits);
    closeMapPicker();
    freshMatch();
  });
  if(fillPlainsBtn) fillPlainsBtn.addEventListener("click", ()=>{
    customGrid = Array.from({length:GRID_H}, ()=>Array.from({length:GRID_W}, ()=>"."));
    customUnits = Array.from({length:GRID_H}, ()=>Array.from({length:GRID_W}, ()=>"."));
    renderCustomGrid();
  });
  if(resetCustomBtn) resetCustomBtn.addEventListener("click", ()=>{
    initCustomGridFromText(DEFAULT_CUSTOM_MAP);
    renderCustomGrid();
  });
  if(p1TopAvatar){
    p1TopAvatar.addEventListener("click", ()=>openCOModal(1));
    p1TopAvatar.addEventListener("mouseenter", ()=>showTooltip(p1TopTooltip, p1TopAvatar));
    p1TopAvatar.addEventListener("mouseleave", ()=>hideTooltip(p1TopTooltip));
  }
  if(p2TopAvatar){
    p2TopAvatar.addEventListener("click", ()=>openCOModal(2));
    p2TopAvatar.addEventListener("mouseenter", ()=>showTooltip(p2TopTooltip, p2TopAvatar));
    p2TopAvatar.addEventListener("mouseleave", ()=>hideTooltip(p2TopTooltip));
  }
  if(p1PowerBtn) p1PowerBtn.addEventListener("click", ()=>useCOPower(1,"POWER"));
  if(p2PowerBtn) p2PowerBtn.addEventListener("click", ()=>useCOPower(2,"POWER"));
  if(p1SuperBtn) p1SuperBtn.addEventListener("click", ()=>useCOPower(1,"SUPER"));
  if(p2SuperBtn) p2SuperBtn.addEventListener("click", ()=>useCOPower(2,"SUPER"));
  if(p1TopPower) p1TopPower.addEventListener("click", ()=>useCOPower(1,"POWER"));
  if(p2TopPower) p2TopPower.addEventListener("click", ()=>useCOPower(2,"POWER"));
  if(p1TopSuper) p1TopSuper.addEventListener("click", ()=>useCOPower(1,"SUPER"));
  if(p2TopSuper) p2TopSuper.addEventListener("click", ()=>useCOPower(2,"SUPER"));
  if(closeCoModal) closeCoModal.addEventListener("click", closeCOModal);
  if(coModal) coModal.addEventListener("click", (e)=>{ if(e.target===coModal) closeCOModal(); });
  if(mapSettingsBtn) mapSettingsBtn.addEventListener("click", toggleMapSettings);
  if(startFundsInput) startFundsInput.addEventListener("change", ()=>{
    applyIncomeInputs();
  });
  if(cityIncomeInput) cityIncomeInput.addEventListener("change", ()=>{
    applyIncomeInputs();
    updateUI();
  });
  if(defaultIncomeInput) defaultIncomeInput.addEventListener("change", ()=>{
    applyIncomeInputs();
    updateUI();
  });

  /***********************************************************************
   * UI Updates
   ***********************************************************************/
  function updateUI(){
    const cp = owningPlayer(Game.currentPlayer);
    const income1 = countOwnedIncome(1);
    const income2 = countOwnedIncome(2);
    const co1 = getCOChoice(1);
    const co2 = getCOChoice(2);

    if(p1TopIncome) p1TopIncome.textContent = `Income $${income1}`;
    if(p2TopIncome) p2TopIncome.textContent = `Income $${income2}`;
    elP1Funds.textContent = `Funds $${Game.funds[1]}`;
    elP2Funds.textContent = `Funds $${Game.funds[2]}`;
    if(p1TopCOName) p1TopCOName.textContent = co1.name;
    if(p2TopCOName) p2TopCOName.textContent = co2.name;
    setCOAvatar(p1TopAvatar, co1, 1);
    setCOAvatar(p2TopAvatar, co2, 2);

    if(p1Card){
      const active = Game.currentPlayer===1;
      p1Card.classList.toggle("active", active);
      p1Card.style.borderColor = active ? COLORS.p1 : "#23346b";
      p1Card.style.boxShadow = active ? "0 0 0 1px rgba(99,186,255,0.4)" : "none";
    }
    if(p2Card){
      const active = Game.currentPlayer===2;
      p2Card.classList.toggle("active", active);
      p2Card.style.borderColor = active ? COLORS.p2 : "#23346b";
      p2Card.style.boxShadow = active ? "0 0 0 1px rgba(255,95,140,0.4)" : "none";
    }
    renderCOSection();

    if(Game.sel && Game.sel.type==="unit"){
      const u = Game.sel.unit;
      computeMoveOverlayIfApplicable();
      computeAttackOverlayIfApplicable();
      Game.phase = canAttackThisTurn(u) ? "ATTACKING" : "IDLE";
    } else {
      Game.moveTiles = new Set();
      Game.atkTiles = new Set();
      Game.path = [];
    }

    endTurnBtn.disabled = Game.gameOver;

    if(Game.sel) updateSelectionPanel();

    renderShop();

    saveGameState();
    updateDamagePreview();
  }

  /***********************************************************************
   * Rendering
   ***********************************************************************/
  function getUnitRenderPos(u, now){
    if(u && u.animMove && Array.isArray(u.animMove.path)){
      const { path, start, step } = u.animMove;
      const steps = path.length-1;
      if(steps>0){
        const elapsed = now - start;
        const seg = Math.floor(elapsed / step);
        if(seg >= steps){
          u.animMove = null;
          return { x:u.x, y:u.y };
        }
        const t = (elapsed % step) / step;
        const a = path[seg];
        const b = path[seg+1];
        if(a && b){
          return { x: a.x + (b.x - a.x)*t, y: a.y + (b.y - a.y)*t };
        } else {
          u.animMove = null;
        }
      } else {
        u.animMove = null;
      }
    }
    return { x:u.x, y:u.y };
  }

  function draw(ts){
    const now = ts || performance.now();
    ctx.clearRect(0,0,canvas.width,canvas.height);

    ctx.fillStyle = COLORS.bg;
    ctx.fillRect(0,0,canvas.width,canvas.height);

    drawTerrain();
    drawBuildings();
    drawOverlays();
    drawUnits(now);
    drawGrid();
    drawTopHUD();

    requestAnimationFrame(draw);
  }

  // NEW: clearer terrain rendering (road/water/grass distinct, deterministic patterns)
  function drawTerrain(){
    for(let y=0;y<GRID_H;y++){
      for(let x=0;x<GRID_W;x++){
        const t = Game.terrain[y][x];
        const px = x*TILE, py = y*TILE;
        const img = getTerrainSprite(t.id);
        if(img && img.complete){
          ctx.drawImage(img, px, py, TILE, TILE);
        } else {
          ctx.fillStyle = t.color;
          ctx.fillRect(px, py, TILE, TILE);
        }
      }
    }
  }

  function drawBuildings(){
    for(let y=0;y<GRID_H;y++){
      for(let x=0;x<GRID_W;x++){
        const b = Game.buildings[y][x];
        if(!b) continue;

        const owner = b.owner ?? 0;
        const baseX = x*TILE, baseY = y*TILE;
        const img = getBuildingSprite(b.kindId, owner);
        const margin = TILE*0.05;
        if(img && img.complete){
          ctx.drawImage(img, baseX+margin, baseY+margin, TILE-2*margin, TILE-2*margin);
        } else {
          // fallback simple plate
          ctx.fillStyle = "#0a0f26";
          ctx.fillRect(baseX+6, baseY+6, TILE-12, TILE-12);
          ctx.strokeStyle = "#23346b";
          ctx.strokeRect(baseX+6, baseY+6, TILE-12, TILE-12);
        }

        // capture indicator (above tile to avoid overlap)
        if(b.owner===null || b.capturePoints<20){
          const pct = b.capturePoints / 20;
          const barW = TILE-16;
          const barH = 6;
          const barX = baseX+8;
          const barY = Math.max(0, baseY-8);
          ctx.fillStyle = "#0b1433";
          ctx.fillRect(barX, barY, barW, barH);
          ctx.fillStyle = owner ? owningPlayer(owner).color : "#ffd166";
          ctx.fillRect(barX, barY, Math.floor(barW*pct), barH);
          ctx.strokeStyle = "#23346b";
          ctx.strokeRect(barX, barY, barW, barH);
        }
      }
    }
  }

  // NEW: clearer unit labels (abbr) and slightly improved silhouettes
  function drawUnits(now){
    for(const u of Game.units){
      const rp = getUnitRenderPos(u, now);
      const px = rp.x*TILE, py = rp.y*TILE;
      const p = owningPlayer(u.owner);
      const margin = TILE * 0.05; // 0.9x size to reveal tile edges
      const ux = px + margin;
      const uy = py + margin;
      const size = TILE - margin*2;

      // ready highlight
      if(!u.moved && !u.acted && u.owner===Game.currentPlayer){
        ctx.fillStyle = "rgba(116, 255, 138, 0.28)";
        ctx.fillRect(px, py, TILE, TILE);
      }

      // shadow
      ctx.globalAlpha = 0.35;
      ctx.fillStyle = "#000000";
      ctx.beginPath();
      ctx.ellipse(px+TILE/2, py+TILE/2+10, size*0.45, size*0.22, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = 1;

      // sprite draw (fallback to shapes if missing)
      const spriteList = getSpriteList(u.typeId, u.owner);
      const img = spriteList.length ? spriteList[u.spriteIdx % spriteList.length] : null;
      if(img && img.complete){
        ctx.drawImage(img, ux, uy, size, size);
      } else {
        ctx.fillStyle = p.dark;
        ctx.fillRect(ux, uy+4, size, size-10);
        ctx.fillStyle = p.color;
        ctx.fillRect(ux+2, uy+6, size-4, size-14);
      }

      // HP badge
      const hpPct = u.hp / u.def.maxHP;
      const overlayTop = Math.max(0, py-24);
      const centerX = px + TILE/2;

      // Name tag (smaller, stacked)
      const labelW = 46, labelH = 12;
      const labelX = centerX - labelW/2;
      const labelY = overlayTop;
      ctx.fillStyle = "#0a0f26";
      ctx.globalAlpha = 0.65;
      ctx.fillRect(labelX, labelY, labelW, labelH);
      ctx.globalAlpha = 1;
      ctx.strokeStyle = "#23346b";
      ctx.strokeRect(labelX, labelY, labelW, labelH);
      ctx.fillStyle = "#e8eeff";
      ctx.font = "bold 9px system-ui";
      ctx.fillText(`${u.def.abbr} - ${u.hp}`, labelX+4, labelY+9);

      // HP bar (stacked under name, smaller)
      const barW = 34, barH = 10;
      const badgeX = centerX - barW/2;
      const badgeY = labelY + labelH + 2;
      const badgeFillW = Math.max(0, Math.round((barW-2)*hpPct));
      ctx.fillStyle = "#0b1433";
      ctx.fillRect(badgeX, badgeY, barW, barH);
      ctx.fillStyle = hpPct>0.66 ? "#74ff8a" : hpPct>0.33 ? "#ffd166" : "#ff5d7a";
      ctx.fillRect(badgeX+1, badgeY+1, badgeFillW, barH-2);
      ctx.strokeStyle = "#23346b";
      ctx.strokeRect(badgeX, badgeY, barW, barH);

      // exhausted overlay
      if(u.owner===Game.currentPlayer && (u.moved || u.acted)){
        ctx.globalAlpha = 0.22;
        ctx.fillStyle = "#000000";
        ctx.fillRect(px,py,TILE,TILE);
        ctx.globalAlpha = 1;
      }

      // Transport indicator
      if(u.def.transport && u.cargo){
        ctx.fillStyle = "#0b1433";
        ctx.fillRect(px+4, py+TILE-14, TILE-8, 10);
        ctx.strokeStyle = "#4a67d6";
        ctx.strokeRect(px+4, py+TILE-14, TILE-8, 10);
        ctx.fillStyle = "#e8eeff";
        ctx.font = "bold 9px system-ui";
        const cap = transportCapacity(u);
        const cnt = cargoCount(u);
        ctx.fillText(`CARGO ${cnt}/${cap}`, px+6, py+TILE-6);
      }
    }
  }

  function drawGrid(){
    ctx.strokeStyle = COLORS.grid;
    ctx.lineWidth = 1;
    for(let x=0;x<=GRID_W;x++){
      ctx.beginPath();
      ctx.moveTo(x*TILE, 0);
      ctx.lineTo(x*TILE, CANVAS_H);
      ctx.stroke();
    }
    for(let y=0;y<=GRID_H;y++){
      ctx.beginPath();
      ctx.moveTo(0, y*TILE);
      ctx.lineTo(CANVAS_W, y*TILE);
      ctx.stroke();
    }
  }

  function drawTopHUD(){
    if(Game.gameOver){
      ctx.fillStyle = "#0b1433";
      ctx.fillRect(CANVAS_W/2-220, CANVAS_H/2-40, 440, 80);
      ctx.strokeStyle = "#23346b";
      ctx.strokeRect(CANVAS_W/2-220, CANVAS_H/2-40, 440, 80);
      ctx.fillStyle = "#e8eeff";
      ctx.font = "bold 18px system-ui";
      ctx.fillText("GAME OVER", CANVAS_W/2-70, CANVAS_H/2-18);
      ctx.font = "14px system-ui";
      const winnerText = Game.winner ? `Winner: ${owningPlayer(Game.winner).name}${Game.winReason ? " ("+Game.winReason+")" : ""}` : "Winner: —";
      ctx.fillText(winnerText, CANVAS_W/2-150, CANVAS_H/2);
      ctx.fillText("Press New Game to play again.", CANVAS_W/2-110, CANVAS_H/2+24);
    }
  }

  function drawOverlays(){
    const selUnit = Game.sel && Game.sel.type==="unit" ? Game.sel.unit : null;
    const { showMove, showAtk, showAtkFull } = selUnit ? overlayVisibility(selUnit) : { showMove:false, showAtk:false, showAtkFull:false };

    if(showMove && Game.moveTiles && Game.moveTiles.size){
      for(const k of Game.moveTiles){
        const shouldSkip = showAtk && Game.atkTiles && Game.atkTiles.has(k) && selUnit && (showAtkFull || enemyInRangeAt(selUnit, k));
        if(shouldSkip) continue; // let visible red tiles dominate
        const {x,y} = parseKey(k);
        const px=x*TILE, py=y*TILE;
        ctx.fillStyle = COLORS.move;
        ctx.fillRect(px,py,TILE,TILE);
        ctx.strokeStyle = COLORS.moveEdge;
        ctx.strokeRect(px+1,py+1,TILE-2,TILE-2);
      }
    }

    // When hiding attack range (targets-only), still shade the potential attack area blue
    if(showMove && showAtk && !showAtkFull && selUnit && Game.atkTiles && Game.atkTiles.size){
      for(const k of Game.atkTiles){
        if(enemyInRangeAt(selUnit, k)) continue; // actual target stays for red overlay
        if(Game.moveTiles && Game.moveTiles.has(k)) continue; // already painted as move
        const {x,y} = parseKey(k);
        const px=x*TILE, py=y*TILE;
        ctx.fillStyle = COLORS.move;
        ctx.fillRect(px,py,TILE,TILE);
        ctx.strokeStyle = COLORS.moveEdge;
        ctx.strokeRect(px+1,py+1,TILE-2,TILE-2);
      }
    }

    if(showMove && Game.path && Game.path.length>1){
      ctx.strokeStyle = COLORS.selectEdge;
      ctx.lineWidth = 4;
      ctx.beginPath();
      for(let i=0;i<Game.path.length;i++){
        const p = Game.path[i];
        const cx = p.x*TILE + TILE/2;
        const cy = p.y*TILE + TILE/2;
        if(i===0) ctx.moveTo(cx,cy);
        else ctx.lineTo(cx,cy);
      }
      ctx.stroke();
      ctx.lineWidth = 1;
    }

    if(showAtk && Game.sel && Game.sel.type==="unit"){
      for(const k of Game.atkTiles){
        if(!showAtkFull){
          if(!enemyInRangeAt(Game.sel.unit, k)) continue;
        }
        const {x,y} = parseKey(k);
        const px=x*TILE, py=y*TILE;
        ctx.fillStyle = COLORS.atk;
        ctx.fillRect(px,py,TILE,TILE);
        ctx.strokeStyle = COLORS.atkEdge;
        ctx.strokeRect(px+1,py+1,TILE-2,TILE-2);
      }
    }

    if(Game.sel){
      const x = Game.sel.type==="unit" ? Game.sel.unit.x : Game.sel.x;
      const y = Game.sel.type==="unit" ? Game.sel.unit.y : Game.sel.y;
      const px=x*TILE, py=y*TILE;
      ctx.fillStyle = COLORS.select;
      ctx.fillRect(px,py,TILE,TILE);
      ctx.strokeStyle = COLORS.selectEdge;
      ctx.lineWidth = 3;
      ctx.strokeRect(px+2,py+2,TILE-4,TILE-4);
      ctx.lineWidth = 1;
    }

    for(const u of Game.units){
      if(u.owner!==Game.currentPlayer) continue;
      if(!u.def.canCapture || u.acted) continue;
      const b = buildingAt(u.x, u.y);
      if(!b) continue;
      if(b.owner===u.owner && b.capturePoints===20) continue;
      const px=u.x*TILE, py=u.y*TILE;
      ctx.fillStyle = COLORS.danger;
      ctx.fillRect(px,py,TILE,TILE);
      ctx.strokeStyle = COLORS.warn;
      ctx.lineWidth = 3;
      ctx.strokeRect(px+2,py+2,TILE-4,TILE-4);
      ctx.lineWidth = 1;
    }

    if(inBounds(Game.hovered.x, Game.hovered.y)){
      const px=Game.hovered.x*TILE, py=Game.hovered.y*TILE;
      ctx.globalAlpha = 0.18;
      ctx.fillStyle = "#ffffff";
      ctx.fillRect(px,py,TILE,TILE);
      ctx.globalAlpha = 1;
    }
  }

  /***********************************************************************
   * Win Checks
   ***********************************************************************/
  function hasHQ(ownerId){
    for(let y=0;y<GRID_H;y++){
      for(let x=0;x<GRID_W;x++){
        const b = buildingAt(x,y);
        if(b && b.kindId==="HQ" && b.owner===ownerId) return true;
      }
    }
    return false;
  }

  function hasTroops(ownerId){
    return Game.units.some(u=>u.owner===ownerId);
  }

  function declareWinner(playerId, reason){
    Game.gameOver = true;
    Game.winner = playerId;
    Game.winReason = reason;
  }

  function sanityWinCheck(){
    if(Game.gameOver) return;

    const p1HQ = hasHQ(1);
    const p2HQ = hasHQ(2);
    const p1Troops = hasTroops(1);
    const p2Troops = hasTroops(2);

    if(!p1HQ){
      declareWinner(2, "Player 1 HQ lost");
      logLine("Player 2 wins (Player 1 HQ lost).", 2);
    } else if(!p2HQ){
      declareWinner(1, "Player 2 HQ lost");
      logLine("Player 1 wins (Player 2 HQ lost).", 1);
    } else if(!p1Troops && p2Troops){
      declareWinner(2, "Player 1 has no troops");
      logLine("Player 2 wins (Player 1 has no troops).", 2);
    } else if(!p2Troops && p1Troops){
      declareWinner(1, "Player 2 has no troops");
      logLine("Player 1 wins (Player 2 has no troops).", 1);
    }
  }

  /***********************************************************************
   * Auto-open shop on base double click
   ***********************************************************************/
  canvas.addEventListener("dblclick", (e)=>{
    const g = canvasToGrid(e.clientX, e.clientY);
    if(!inBounds(g.x,g.y)) return;
    const b = buildingAt(g.x,g.y);
    if(b && b.owner===Game.currentPlayer && canBuildFromBuilding(b, Game.currentPlayer)){
      selectBuilding(b, g.x, g.y);
      openShopIfOnOwnedBase();
      updateUI();
    }
  });

  /***********************************************************************
   * Keep selection valid if unit dies
   ***********************************************************************/
  function validateSelection(){
    if(!Game.sel) return;
    if(Game.sel.type==="unit"){
      const uid = Game.sel.unit.uid;
      const still = Game.units.find(u=>u.uid===uid);
      if(!still){
        clearSelection();
        updateUI();
      } else {
        Game.sel.unit = still;
      }
    }
  }

  /***********************************************************************
   * Game Loop
   ***********************************************************************/
  function tick(){
    validateSelection();
    sanityWinCheck();
  }
  setInterval(tick, 120);

  /***********************************************************************
 * HOTFIX: Safe deterministic hash helpers (replaces buggy BigInt version)
 ***********************************************************************/
function hash2(x, y, seed = 1337) {
  // 32-bit integer hash (no BigInt)
  let h = (x | 0) * 374761393 ^ (y | 0) * 668265263 ^ (seed | 0) * 1442695041;
  h = (h ^ (h >>> 13)) | 0;
  h = (h * 1274126177) | 0;
  h = (h ^ (h >>> 16)) | 0;
  return h >>> 0; // unsigned
}
function hashFloat01(x, y, seed = 1337) {
  return (hash2(x, y, seed) % 100000) / 100000;
}
function hashInt(x, y, seed, mod) {
  return Math.floor(hashFloat01(x, y, seed) * mod);
}


  /***********************************************************************
   * Boot
   ***********************************************************************/
  loadSprites();
  if(!loadGameState()){
    hardReset();
  }
  syncIncomeInputs();
  requestAnimationFrame(draw);

  </script>
</body>
</html>
