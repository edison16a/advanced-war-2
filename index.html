<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="icon" type="image/png" href="assets/blue_rocket.png" />
  <title>Advanced Wars</title>
  <style>
    :root{
      --bg:#0b1020;
      --panel:#111a33;
      --panel2:#0f1730;
      --text:#e8eeff;
      --muted:#a9b6e6;
      --accent:#5dd6ff;
      --good:#74ff8a;
      --warn:#ffd166;
      --bad:#ff5d7a;
      --grid:#1c2b57;
    }
    html,body{height:100%;margin:0;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
    #wrap{display:flex;align-items:stretch;justify-content:center;gap:12px;padding:12px;box-sizing:border-box;height:100%}
    #gameCol{display:flex;flex-direction:column;gap:10px;align-items:flex-start}
    canvas{background:#050814;border:1px solid #23346b;border-radius:10px;image-rendering:pixelated}
    #panel{
      width:360px;
      max-width:38vw;
      height:calc(100vh - 24px); /* keep the full panel in view */
      background:linear-gradient(180deg,var(--panel),var(--panel2));
      border:1px solid #23346b;
      border-radius:14px;
      padding:12px;
      box-sizing:border-box;
      display:flex;
      flex-direction:column;
      gap:10px;
      overflow:auto;
      scrollbar-width:none; /* hide scrollbar in Firefox */
    }
    #panel::-webkit-scrollbar{display:none;} /* hide scrollbar in WebKit */
    .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    .btn{
      background:#152252;border:1px solid #2a3f86;color:var(--text);
      padding:8px 10px;border-radius:10px;cursor:pointer;font-weight:600
    }
    .btn:hover{border-color:#4a67d6}
    .btn:active{transform:translateY(1px)}
    .btn.primary{background:#1b2c69;border-color:#4a67d6}
    .btn.good{background:#134d2a;border-color:#2bd37e}
    .btn.bad{background:#5a1630;border-color:#ff5d7a}
    .btn:disabled{opacity:.45;cursor:not-allowed}
    .tag{padding:2px 8px;border:1px solid #2a3f86;border-radius:999px;font-size:12px;color:var(--muted)}
    .big{font-size:18px;font-weight:800}
    .muted{color:var(--muted)}
    #log{
      flex:1;
      min-height:240px; /* give the log room so it doesn't collapse */
      max-height:45vh;
      overflow:auto;
      background:#0a1026;
      border:1px solid #23346b;
      border-radius:12px;
      padding:10px;
      line-height:1.25;
      scrollbar-width:none;
    }
    #log::-webkit-scrollbar{display:none;}
    #log .line{margin:0 0 8px 0}
    #log .p1{color:#7cc6ff}
    #log .p2{color:#ff8aa7}
    #help{display:none}
    .kv{display:grid;grid-template-columns:1fr auto;gap:6px 10px;font-size:13px}
    .sep{height:1px;background:#203368;margin:6px 0}
    .list{display:flex;flex-direction:column;gap:6px}
    .shopItem{
      display:flex;align-items:center;justify-content:space-between;gap:12px;
      background:#0b1433;border:1px solid #23346b;border-radius:12px;padding:10px 12px
    }
    .shopItem .name{font-weight:700}
    .shopItem .meta{font-size:12px;color:var(--muted);line-height:1.35}
    .pill{
      padding:3px 8px;border-radius:999px;font-size:12px;font-weight:700;border:1px solid #2a3f86;color:var(--text)
    }
    .pill.good{border-color:#2bd37e;color:#a9ffd1}
    .pill.warn{border-color:#ffd166;color:#ffe7a8}
    .pill.bad{border-color:#ff5d7a;color:#ffc1cd}
    /* NEW: Key/Legend panel */
    #keyBox{
      display:none;
      background:#0a1026;
      border:1px solid #23346b;
      border-radius:12px;
      padding:10px;
    }
    .legendRow{
      display:flex;align-items:center;justify-content:space-between;gap:10px;
      padding:6px 8px;border:1px solid #23346b;border-radius:10px;background:#08102a
    }
    .swatch{
      width:18px;height:18px;border-radius:4px;border:1px solid #23346b;flex:0 0 auto;
    }
    .abbr{
      font-weight:800;letter-spacing:.5px;font-size:12px;
      padding:2px 6px;border-radius:8px;border:1px solid #23346b;background:#0b1433
    }
    /* Panels under keybinds */
    #lowerPanels{width:100%;max-width:960px;display:flex;flex-direction:column;gap:12px}
    .floatingPanel{
      display:none;
      background:#0a1026;
      border:1px solid #23346b;
      border-radius:14px;
      padding:12px;
      box-sizing:border-box;
    }
    #shopBox{display:block}
    .floatingPanel .headerRow{display:flex;justify-content:space-between;align-items:flex-end;gap:10px;flex-wrap:wrap}
    .shopStats{display:flex;gap:10px;flex-wrap:wrap;font-size:12px;color:var(--muted)}
    .shopStats .pill{font-size:12px}
    .shopGrid{display:flex;flex-direction:column;gap:8px}
    #selKv{display:none}
    #selStats{display:flex;flex-direction:column;gap:6px}
    .selRow{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
    .selRow.center{justify-content:center}
    .selImgRow{display:flex;justify-content:center}
    .thumb{
      width:80px;height:80px;border-radius:10px;
      border:1px solid #23346b;background:#0b1433;
      display:flex;align-items:center;justify-content:center;
      box-sizing:border-box;
    }
    #battleOverlay{
      position:fixed;inset:0;background:rgba(5,8,20,0.9);
      display:none;align-items:center;justify-content:center;
      z-index:9999;
    }
    #battleBox{
      width:80vw;max-width:960px;
      display:flex;justify-content:space-between;align-items:center;
      gap:20px;padding:20px;
      background:#0a1026;border:1px solid #23346b;border-radius:16px;
      box-shadow:0 20px 50px rgba(0,0,0,0.45);
    }
    .battleSide{
      flex:1;display:flex;flex-direction:column;align-items:center;gap:10px;
    }
    .battleImg{
      width:150px;height:150px;
      background:#0b1433;border:1px solid #23346b;border-radius:16px;
      display:flex;align-items:center;justify-content:center;
      overflow:hidden;image-rendering:pixelated;
    }
    .battleImg img{width:100%;height:100%;object-fit:contain;image-rendering:pixelated;}
    .battleHP{
      width:180px;height:14px;background:#0b1433;border:1px solid #23346b;border-radius:8px;overflow:hidden;
    }
    .battleHPFill{
      height:100%;background:#74ff8a;transition:width 0.4s ease;
    }
    .battleLabel{font-weight:700}
    .battleDamage{font-weight:800;font-size:13px;color:#e8eeff;min-height:16px}
    .battleDamage.sub{font-weight:700;font-size:12px;color:#a9b6e6}
    .hitLeft{animation:hitLeft 0.35s ease;}
    .hitRight{animation:hitRight 0.35s ease;}
    @keyframes hitLeft{0%{transform:translateX(0);}50%{transform:translateX(18px);}100%{transform:translateX(0);}}
    @keyframes hitRight{0%{transform:translateX(0);}50%{transform:translateX(-18px);}100%{transform:translateX(0);}}

    /* Stats header */
    #statsGrid{display:grid;grid-template-columns:1fr 1fr;gap:10px}
    .playerCard{
      background:#0a1026;
      border:1px solid #23346b;
      border-radius:12px;
      padding:10px;
      display:flex;
      flex-direction:column;
      gap:8px;
      transition:border-color 0.2s ease, box-shadow 0.2s ease;
    }
    .playerCard.active{box-shadow:0 0 0 1px rgba(93,214,255,0.35);}
    .playerCardHeader{display:flex;align-items:center;gap:10px}
    .coAvatar.mini{width:48px;height:48px}
    .playerCardHeader{position:relative}
    .coTooltip{
      display:none;
      position:fixed;
      top:58px;left:50%;
      transform:translateX(-50%);
      z-index:20;
      background:#0b1433;
      border:1px solid #23346b;
      border-radius:10px;
      padding:8px 10px;
      width:260px;
      max-width:90vw;
      box-shadow:0 10px 25px rgba(0,0,0,0.4);
    }
    .coTooltip.show{display:block;}
    .playerText .playerName{font-weight:800;font-size:14px}
    .playerText .playerCO{font-size:12px;color:#a9b6e6}
    .playerStats{display:flex;gap:8px;flex-wrap:wrap}
    .pill.mini{font-size:12px;padding:4px 8px}
    .playerTopActions{display:flex;gap:6px;flex-wrap:wrap}
    .playerTopMeter{width:100%;max-width:220px}
    #panel>.sep:first-of-type{margin-top:4px;margin-bottom:6px}
    /* Characters & Income */
    #coSection{background:#0a1026;border:1px solid #23346b;border-radius:12px;padding:10px;display:flex;flex-direction:column;gap:8px}
    #coSection{display:none!important;}
    .coCards{display:flex;flex-direction:column;gap:10px}
    .coCard{background:#0b1433;border:1px solid #23346b;border-radius:10px;padding:10px;display:flex;flex-direction:column;gap:8px}
    .coRow{display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap}
    .coSelection{display:flex;gap:10px;align-items:flex-start;cursor:pointer}
    .coSelection:hover{border-color:#4a67d6}
    .coSelection{border:1px dashed #2a3f86;border-radius:10px;padding:8px}
    .coAvatar{
      width:56px;height:56px;border-radius:12px;
      background:linear-gradient(135deg,#1b2c69,#152252);
      border:1px solid #2a3f86;
      display:flex;align-items:center;justify-content:center;
      font-weight:800;color:#e8eeff;font-size:18px;flex-shrink:0;
      overflow:hidden;
    }
    .coAvatar img{width:100%;height:100%;object-fit:cover;display:block;}
    .coAvatar.editable{position:relative;cursor:pointer;}
    .coAvatar.editable::after{
      content:"✎";
      position:absolute;
      bottom:4px;right:4px;
      width:18px;height:18px;
      border-radius:6px;
      background:rgba(5,8,20,0.8);
      border:1px solid #4a67d6;
      color:#e8eeff;
      font-size:11px;
      display:flex;align-items:center;justify-content:center;
      opacity:0;transition:opacity 0.2s ease;
      pointer-events:none;
    }
    .coAvatar.editable:hover::after{opacity:1;}
    .coText{display:flex;flex-direction:column;gap:4px}
    .coName{font-weight:800;font-size:14px}
    .coBuff{font-size:12px;color:#a9b6e6;line-height:1.35}
    .coBuff.small{font-size:11px}
    .coPill{padding:4px 8px;border-radius:999px;font-size:12px;font-weight:700;border:1px solid #2a3f86}
    .coPill.p1{color:#a9d9ff;border-color:#4a67d6}
    .coPill.p2{color:#ffc1cd;border-color:#ff5d7a}
    .btn.tiny{padding:4px 8px;font-size:12px;border-radius:8px}
    .coHelp{font-size:12px;color:#a9b6e6;line-height:1.4}
    .abilityLine{display:flex;flex-wrap:wrap;gap:6px;align-items:flex-start;margin-top:2px}
    .abilityBadge{padding:3px 7px;border-radius:8px;border:1px solid #2a3f86;font-size:11px;font-weight:700;color:#e8eeff;background:#11204a}
    .abilityCopy{font-size:12px;color:#c9d4ff;line-height:1.35}
    .coMeter{position:relative;width:100%;height:10px;border-radius:999px;background:#0a1026;border:1px solid #23346b;overflow:hidden}
    .coMeterFill{position:absolute;inset:0;width:0%;background:linear-gradient(90deg,#4a67d6,#5dd6ff);border-radius:999px;transition:width 0.2s ease}
    .coMeterLabel{font-size:11px;color:#a9b6e6;margin-top:4px}
    .coActions{display:flex;gap:6px;flex-wrap:wrap}

    /* CO modal */
    #coModal{position:fixed;inset:0;background:rgba(5,8,20,0.8);display:none;align-items:center;justify-content:center;z-index:7000}
    #coModal .modalBox{width:90vw;max-width:720px;background:#0a1026;border:1px solid #23346b;border-radius:14px;padding:14px;box-shadow:0 20px 40px rgba(0,0,0,0.55);}
    .coList{display:flex;flex-direction:column;gap:10px;margin-top:10px;max-height:70vh;overflow:auto;padding-right:4px}
    .coList{scrollbar-width:none;}
    .coList::-webkit-scrollbar{display:none;}
    .coOption{display:grid;grid-template-columns:auto 1fr auto;gap:10px;align-items:center;background:#0b1433;border:1px solid #23346b;border-radius:10px;padding:10px}
    .coOption .coText{gap:2px}
    .coOption .coName{font-size:15px}
    .coOption .coBuff{font-size:12px}
    .coOption .coBuff.small{font-size:11px}

    /* Turn overlay */
    #turnOverlay{position:fixed;inset:0;display:none;align-items:center;justify-content:center;z-index:6500;pointer-events:none;background:radial-gradient(circle at 30% 30%,rgba(93,214,255,0.12),transparent 45%),radial-gradient(circle at 70% 70%,rgba(255,93,122,0.12),transparent 45%)}
    #turnOverlay .turnBox{min-width:320px;max-width:520px;background:#0b1433;border:1px solid #23346b;border-radius:16px;padding:16px;box-shadow:0 20px 40px rgba(0,0,0,0.45);transform:translateY(20px);opacity:0;transition:opacity 0.3s ease,transform 0.3s ease}
    #turnOverlay.show .turnBox{opacity:1;transform:translateY(0)}
    .turnMeta{display:flex;align-items:center;gap:8px;flex-wrap:wrap;margin-bottom:8px}
    .turnIncome{font-size:18px;font-weight:800}
    .turnCO{font-size:13px;color:#a9b6e6;line-height:1.35}
  </style>
</head>
<body>
  <div id="wrap">
    <div id="gameCol">
      <canvas id="c" width="960" height="720"></canvas>
      <div id="help">
        <div class="row">
          <span class="tag">Mouse</span><span>Select unit/building/tile, move, attack</span>
        </div>
        <div class="row">
          <span class="tag">Right Click</span><span>Cancel selection</span>
        </div>
        <div class="row">
          <span class="tag">E</span><span>End Turn</span>
          <span class="tag">B</span><span>Open Shop (on your Base)</span>
          <span class="tag">K</span><span>Open Key/Legend</span>
          <span class="tag">Esc</span><span>Close Shop / Close Key / Cancel</span>
        </div>
      </div>

      <div id="lowerPanels">
        <div id="shopBox" class="floatingPanel">
          <div class="headerRow">
            <div>
              <div class="big" style="font-size:16px">Base Shop</div>
              <div class="muted" id="shopHint">Build units on your base.</div>
            </div>
            <button class="btn" id="closeShopBtn">Close (Esc)</button>
          </div>
          <div class="sep"></div>
          <div class="shopGrid" id="shopList"></div>
        </div>

        <div id="keyBox" class="floatingPanel">
          <div class="headerRow">
            <div>
              <div class="big" style="font-size:16px">Key / Legend</div>
              <div class="muted">Terrain and unit abbreviations (press K to toggle)</div>
            </div>
            <button class="btn" id="closeKeyBtn">Close (Esc)</button>
          </div>
          <div class="sep"></div>

          <div class="big" style="font-size:14px">Terrain</div>
          <div class="list" id="terrainLegend"></div>

          <div class="sep"></div>

          <div class="big" style="font-size:14px">Units</div>
          <div class="list" id="unitLegend"></div>
        </div>
      </div>
    </div>

    <div id="panel">
      <div class="row" style="justify-content:center">
        <div style="display:flex;justify-content:center;width:100%;">
          <img src="assets/logo.png" alt="Game Logo" style="max-width:240px; height:auto; display:block;">
        </div>
      </div>



      <div id="statsGrid">
        <div class="playerCard" id="p1Card">
          <div class="playerCardHeader">
            <div class="coAvatar mini editable" id="p1TopAvatar" title="Change CO"></div>
            <div class="playerText">
              <div class="playerName">Player 1</div>
              <div class="playerCO" id="p1TopCOName">Andy</div>
            </div>
            <div class="coTooltip" id="p1TopTooltip"></div>
          </div>
          <div class="playerStats">
            <span class="pill mini" id="p1Funds">Funds 0</span>
            <span class="pill mini" id="p1TopIncome">Income 0</span>
          </div>
          <div class="playerTopActions" id="p1TopActions">
            <button class="btn tiny primary" id="p1TopPower">Power</button>
            <button class="btn tiny primary" id="p1TopSuper">Super</button>
          </div>
          <div class="playerTopMeter coMeter playerTopMeter"><div class="coMeterFill" id="p1TopMeterFill"></div></div>
        </div>
        <div class="playerCard" id="p2Card">
          <div class="playerCardHeader">
            <div class="coAvatar mini editable" id="p2TopAvatar" title="Change CO"></div>
            <div class="playerText">
              <div class="playerName">Player 2</div>
              <div class="playerCO" id="p2TopCOName">Andy</div>
            </div>
            <div class="coTooltip" id="p2TopTooltip"></div>
          </div>
          <div class="playerStats">
            <span class="pill mini" id="p2Funds">Funds 0</span>
            <span class="pill mini" id="p2TopIncome">Income 0</span>
          </div>
          <div class="playerTopActions" id="p2TopActions">
            <button class="btn tiny primary" id="p2TopPower">Power</button>
            <button class="btn tiny primary" id="p2TopSuper">Super</button>
          </div>
          <div class="playerTopMeter coMeter playerTopMeter"><div class="coMeterFill" id="p2TopMeterFill"></div></div>
        </div>
      </div>

      <div id="selectionBox">
        <div class="big" style="font-size:16px">Tile/Troop Info</div>
        <div class="muted" id="selHint">Click a unit, building, or tile.</div>
        <br>
        
        <div class="kv" id="selKv"></div>
        
        <div class="shopStats" id="selStats"></div>
      </div>

      <div class="sep"></div>

      <div class="row">
        <button class="btn primary" id="endTurnBtn">End Turn (E)</button>
        <button class="btn" id="newBtn">New Game</button>
        <button class="btn bad" id="resetBtn" title="Hard reset the match">Reset</button>
        <button class="btn" id="openShopBtn" title="Open your shop (cycles owned bases)">Open Shop (B)</button>
        <button class="btn" id="unselectBtn" title="Clear selection / close panels">ESC</button>
        <button class="btn" id="keyBtn" title="Open unit/terrain legend">Key (K)</button>
      </div>

      <div class="sep"></div>

      <div id="coSection">
        <div class="big" style="font-size:16px">Powers</div>
        <div class="coHelp">Day-to-day buffs are always on. CO Power / Super are burst abilities (pretend the meter fills as you fight; trigger when full). Click a commander card to swap and preview their kit.</div>
        <div class="coCards">
          <div class="coCard" data-player="1">
            <div class="coRow">
              <div class="coPill p1">Player 1 (Blue)</div>
              <div style="flex:1;min-width:180px">
                <div class="coMeter"><div class="coMeterFill" id="p1MeterFill"></div></div>
                <div class="coMeterLabel" id="p1MeterLabel">Meter 0%</div>
              </div>
            </div>
            <div class="coSelection" data-player="1" id="p1COCard">
              <div class="coAvatar" id="p1COAvatar">P1</div>
              <div class="coText">
                <div class="coName" id="p1COName">Andy</div>
                <div class="coBuff" id="p1COSpecialty">No strengths or weaknesses.</div>
                <div class="coBuff small" id="p1COPower">CO Power: —</div>
                <div class="coBuff small" id="p1COSuper">Super CO Power: —</div>
              </div>
              <button class="btn tiny" data-player="1" id="p1ChooseCO">Choose</button>
            </div>
            <div class="coActions">
              <button class="btn tiny" id="p1PowerBtn">Power</button>
              <button class="btn tiny primary" id="p1SuperBtn">Super</button>
            </div>
          </div>

          <div class="coCard" data-player="2">
            <div class="coRow">
              <div class="coPill p2">Player 2 (Red)</div>
              <div style="flex:1;min-width:180px">
                <div class="coMeter"><div class="coMeterFill" id="p2MeterFill"></div></div>
                <div class="coMeterLabel" id="p2MeterLabel">Meter 0%</div>
              </div>
            </div>
            <div class="coSelection" data-player="2" id="p2COCard">
              <div class="coAvatar" id="p2COAvatar">P2</div>
              <div class="coText">
                <div class="coName" id="p2COName">Andy</div>
                <div class="coBuff" id="p2COSpecialty">No strengths or weaknesses.</div>
                <div class="coBuff small" id="p2COPower">CO Power: —</div>
                <div class="coBuff small" id="p2COSuper">Super CO Power: —</div>
              </div>
              <button class="btn tiny" data-player="2" id="p2ChooseCO">Choose</button>
            </div>
            <div class="coActions">
              <button class="btn tiny" id="p2PowerBtn">Power</button>
              <button class="btn tiny primary" id="p2SuperBtn">Super</button>
            </div>
          </div>
        </div>
      </div>

      <div class="sep"></div>

      <div class="big" style="font-size:16px">Battle Log</div>
      <div id="log"></div>
    </div>
  </div>

  <div id="battleOverlay">
    <div id="battleBox">
      <div class="battleSide" id="battleLeft">
        <div class="battleImg"><img id="battleLeftImg" alt=""></div>
        <div class="battleLabel" id="battleLeftLabel"></div>
        <div class="battleDamage" id="battleLeftDmg"></div>
        <div class="battleHP"><div class="battleHPFill" id="battleLeftHP"></div></div>
      </div>
      <div class="battleSide" id="battleRight">
        <div class="battleImg"><img id="battleRightImg" alt=""></div>
        <div class="battleLabel" id="battleRightLabel"></div>
        <div class="battleDamage sub" id="battleRightDmg"></div>
        <div class="battleHP"><div class="battleHPFill" id="battleRightHP"></div></div>
      </div>
    </div>
  </div>

  <div id="coModal">
    <div class="modalBox">
      <div class="headerRow">
        <div>
          <div class="big" style="font-size:16px">Choose CO</div>
          <div class="muted" id="coModalHint">Pick a commander to set their buffs.</div>
        </div>
        <br>
        <button class="btn" id="closeCoModal">Close (ESC)</button>
      </div>
      <div class="sep"></div>
      <div class="coList" id="coList"></div>
    </div>
  </div>

  <div id="turnOverlay">
    <div class="turnBox" id="turnOverlayBox">
      <div class="turnMeta">
        <span class="coPill p1" id="turnOverlayPlayer">Player</span>
        <span class="pill" id="turnOverlayDay">Day</span>
      </div>
      <div class="turnIncome" id="turnOverlayIncome">Income +0</div>
    </div>
  </div>

  <script>
  "use strict";

  /***********************************************************************
   * TurnGrid Tactics
   ***********************************************************************/

  /***********************************************************************
   * Constants & Utilities
   ***********************************************************************/
  const TILE = 48;
  const GRID_W = 16;
  const GRID_H = 12;

  const CANVAS_W = GRID_W * TILE;
  const CANVAS_H = GRID_H * TILE;

  const COLORS = {
    bg: "#050814",
    grid: "#1c2b57",

    // players
    p1: "#63baff",
    p2: "#ff6f90",
    p1Dark: "#1f4f8a",
    p2Dark: "#8a1f3f",

    // highlights
    move: "rgba(93, 214, 255, 0.22)",
    moveEdge: "rgba(93, 214, 255, 0.75)",
    atk: "rgba(255, 93, 122, 0.20)",
    atkEdge: "rgba(255, 93, 122, 0.75)",
    select: "rgba(116, 255, 138, 0.20)",
    selectEdge: "rgba(116, 255, 138, 0.75)",
    danger: "rgba(255, 209, 102, 0.20)",
    dangerEdge: "rgba(255, 209, 102, 0.75)"
  };

  const SPRITE_SOURCES = {
    INF: { 1:["assets/blue_inf.png","assets/blue_inf2.png"], 2:["assets/red_inf.png","assets/red_inf2.png"] },
    TANK:{ 1:["assets/blue_tank.png"], 2:["assets/red_tank.png"] },
    MDT: { 1:["assets/blue_mdtank.png"], 2:["assets/red_mdtank.png"] },
    ART: { 1:["assets/blue_art.png"], 2:["assets/red_art.png"] },
    RKT: { 1:["assets/blue_rocket.png"], 2:["assets/red_rocket.png"] }
  };
  const SPRITE_IMAGES = {};

  const BUILDING_SOURCES = {
    HQ:   { 1:"assets/blue_hq.png", 2:"assets/red_hq.png", 0:"assets/building.png" },
    BASE: { 1:"assets/blue_base.png", 2:"assets/red_base.png", 0:"assets/building.png" },
    CITY: { 1:"assets/blue_base.png", 2:"assets/red_base.png", 0:"assets/building.png" }
  };
  const BUILDING_IMAGES = {};

  const TERRAIN_SOURCES = {
    PLAINS: "assets/grass.png",
    FOREST: "assets/forest.png",
    MOUNTAIN: "assets/mountain.png",
    ROAD: "assets/road.png",
    WATER: "assets/water.png"
  };
  const TERRAIN_IMAGES = {};

  // NEW: deterministic hash helpers (avoid animated noise)
  function hash2(x, y, seed=1337){
    let n = (x * 374761393 + y * 668265263 + seed * 1442695040888963407n) % 2147483647;
    // Above used BigInt; normalize:
    n = Number((BigInt(x) * 374761393n + BigInt(y) * 668265263n + BigInt(seed) * 1013904223n) & 0x7fffffffn);
    return n;
  }
  function hashFloat01(x,y,seed=1337){
    const h = hash2(x,y,seed) % 100000;
    return h / 100000;
  }
  function hashInt(x,y,seed,mod){
    return Math.floor(hashFloat01(x,y,seed) * mod);
  }

  const TERRAIN = {
    PLAINS:  { id:"PLAINS",  name:"Grass",   moveCost:{foot:1,tread:1}, def:0, color:"#143a2a" },
    FOREST:  { id:"FOREST",  name:"Forest",  moveCost:{foot:1,tread:2}, def:1, color:"#0f2f21" },
    MOUNTAIN:{ id:"MOUNTAIN",name:"Mountain",moveCost:{foot:2,tread:99},def:2, color:"#2a2b35" },
    ROAD:    { id:"ROAD",    name:"Road",    moveCost:{foot:1,tread:1}, def:0, color:"#2a2f3a" },
    WATER:   { id:"WATER",   name:"Water",   moveCost:{foot:99,tread:99},def:0, color:"#0a2542" }
  };

  const BUILDING = {
    CITY: { id:"CITY", name:"City", income:1000, def:1 },
    BASE: { id:"BASE", name:"Base", income:1000, def:1 },
    HQ:   { id:"HQ",   name:"HQ",   income:1000, def:3 }
  };

  // Unit definitions
  const UNIT_DEF = {
    INF: {
      id:"INF", name:"Infantry", abbr:"INF",
      cost: 1000,
      maxHP: 10,
      move: 3,
      movementType: "foot",
      rangeMin: 1, rangeMax: 1,
      canCapture: true,
      // Approximate Advance Wars-style values (scaled to 10hp system)
      baseAtk: { INF: 6, TANK: 1, MDT: 1, ART: 2, RKT: 2 },
      armor: 0
    },

    // Tank #1 (existing)
    TANK: {
      id:"TANK", name:"Tank", abbr:"TNK",
      cost: 7000,
      maxHP: 10,
      move: 6,
      movementType: "tread",
      rangeMin: 1, rangeMax: 1,
      canCapture: false,
      baseAtk: { INF: 7, TANK: 5, MDT: 3, ART: 6, RKT: 6 },
      armor: 1
    },

    // NEW: Tank #2 (heavier)
    MDT: {
      id:"MDT", name:"Md Tank", abbr:"MDT",
      cost: 12000,
      maxHP: 10,
      move: 5,
      movementType: "tread",
      rangeMin: 1, rangeMax: 1,
      canCapture: false,
      baseAtk: { INF: 9, TANK: 8, MDT: 6, ART: 8, RKT: 8 },
      armor: 2
    },

    // Artillery (existing)
    ART: {
      id:"ART", name:"Artillery", abbr:"ART",
      cost: 6000,
      maxHP: 10,
      move: 5,
      movementType: "tread",
      rangeMin: 2, rangeMax: 3,
      canCapture: false,
      baseAtk: { INF: 8, TANK: 7, MDT: 5, ART: 7, RKT: 7 },
      armor: 0,
      indirect: true
    },

    // NEW: Rockets (longer-range indirect)
    RKT: {
      id:"RKT", name:"Rockets", abbr:"RKT",
      cost: 15000,
      maxHP: 10,
      move: 4,
      movementType: "tread",
      rangeMin: 3, rangeMax: 5,
      canCapture: false,
      baseAtk: { INF: 9, TANK: 8, MDT: 7, ART: 8, RKT: 7 },
      armor: 0,
      indirect: true
    }
  };

  const PLAYERS = [
    { id:1, name:"Player 1", color:COLORS.p1, dark:COLORS.p1Dark },
    { id:2, name:"Player 2", color:COLORS.p2, dark:COLORS.p2Dark }
  ];

  const CO_DATA = {
    ANDY: {
      id:"ANDY",
      name:"Andy",
      img:"assets/andy.png",
      specialty:"Balanced: no passive buffs/penalties.",
      power:"Hyper Repair: Heals all owned units by 2 HP; Activating the ability refreshes spent units so they can act again this turn.",
      super:"Hyper Upgrade: Heals all owned units by 5 HP, all units gain +1 Move and +20% attack for the turn; Activating the ability refreshes spent units so they can act again this turn."
    },
    MAX: {
      id:"MAX",
      name:"Max",
      img:"assets/max.png",
      specialty:"Direct units +20% attack; indirect units -1 max range.",
      power:"Max Force: Direct units +1 Move and ~+40% attack this turn; Activating the ability refreshes spent units so they can act again this turn.",
      super:"Max Blast: Direct units +2 Move and ~+60% attack this turn; Activating the ability refreshes spent units so they can act again this turn."
    },
    SAMI: {
      id:"SAMI",
      name:"Sami",
      img:"assets/sami.png",
      specialty:"Infantry deal ~+20% damage; capture strength ~1.5× HP.",
      power:"Double Time: Infantry +1 Move, ~+50% damage, capture strength 2× HP; Activating the ability refreshes spent units so they can act again this turn.",
      super:"Victory March: Infantry +2 Move, ~+60% damage, captures complete in one turn; Activating the ability refreshes spent units so they can act again this turn."
    },
    NELL: {
      id:"NELL",
      name:"Nell",
      img:"assets/nell.png",
      specialty:"Adds 0–2 extra “luck” damage on every hit.",
      power:"Lucky Star: Luck range 0–4 extra damage; Activating the ability refreshes spent units so they can act again this turn.",
      super:"Lady Luck: Luck range 0–6 extra damage; Activating the ability refreshes spent units so they can act again this turn."
    },
    HACHI: {
      id:"HACHI",
      name:"Hachi",
      img:"assets/Hachi.png",
      specialty:"Units cost 10% less in shops.",
      power:"Barter: Units cost 50% less this turn; Activating the ability refreshes spent units so they can act again this turn.",
      super:"Merchant Union: Units cost 50% less this turn; Activating the ability refreshes spent units so they can act again this turn."
    }
  };

  function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }
  function inBounds(x,y){ return x>=0 && y>=0 && x<GRID_W && y<GRID_H; }
  function key(x,y){ return x + "," + y; }
  function parseKey(k){ const [x,y]=k.split(",").map(Number); return {x,y}; }
  function manhattan(a,b){ return Math.abs(a.x-b.x)+Math.abs(a.y-b.y); }
  function randInt(n){ return Math.floor(Math.random()*n); }
  function randBetween(min,max){ return min + randInt(max - min + 1); }

  /***********************************************************************
   * DOM handles
   ***********************************************************************/
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");

  canvas.width = CANVAS_W;
  canvas.height = CANVAS_H;

  const elCurPlayer = null;
  const elDay = null;
  const elP1Funds = document.getElementById("p1Funds");
  const elP2Funds = document.getElementById("p2Funds");
  const p1TopIncome = document.getElementById("p1TopIncome");
  const p2TopIncome = document.getElementById("p2TopIncome");
  const p1TopCOName = document.getElementById("p1TopCOName");
  const p2TopCOName = document.getElementById("p2TopCOName");
  const p1TopAvatar = document.getElementById("p1TopAvatar");
  const p2TopAvatar = document.getElementById("p2TopAvatar");
  const p1Card = document.getElementById("p1Card");
  const p2Card = document.getElementById("p2Card");
  const p1TopTooltip = document.getElementById("p1TopTooltip");
  const p2TopTooltip = document.getElementById("p2TopTooltip");
  const p1TopActions = document.getElementById("p1TopActions");
  const p2TopActions = document.getElementById("p2TopActions");
  const p1TopPower = document.getElementById("p1TopPower");
  const p2TopPower = document.getElementById("p2TopPower");
  const p1TopSuper = document.getElementById("p1TopSuper");
  const p2TopSuper = document.getElementById("p2TopSuper");
  const p1TopMeterFill = document.getElementById("p1TopMeterFill");
  const p2TopMeterFill = document.getElementById("p2TopMeterFill");
  const panelEl = document.getElementById("panel");
  function showTooltip(tt, anchor){
    if(!tt || !anchor || !panelEl) return;
    const panelRect = panelEl.getBoundingClientRect();
    const anchorRect = anchor.getBoundingClientRect();
    tt.style.position = "fixed";
    tt.style.top = `${anchorRect.bottom + 8}px`;
    let center = panelRect.left + panelRect.width/2;
    if(p1Card && p2Card){
      const r1 = p1Card.getBoundingClientRect();
      const r2 = p2Card.getBoundingClientRect();
      center = (r1.left + r2.right) / 2;
    }
    const width = tt.offsetWidth || 260;
    tt.style.left = `${center - width/2}px`;
    tt.classList.add("show");
  }
  function hideTooltip(tt){
    if(tt) tt.classList.remove("show");
  }

  const endTurnBtn = document.getElementById("endTurnBtn");
  const newBtn = document.getElementById("newBtn");
  const resetBtn = document.getElementById("resetBtn");
  const openShopBtn = document.getElementById("openShopBtn");
  const unselectBtn = document.getElementById("unselectBtn");

  const elSelHint = document.getElementById("selHint");
  const elSelKv = document.getElementById("selKv");
  const elSelStats = document.getElementById("selStats");

  const p1COName = document.getElementById("p1COName");
  const p2COName = document.getElementById("p2COName");
  const p1COSpecialty = document.getElementById("p1COSpecialty");
  const p2COSpecialty = document.getElementById("p2COSpecialty");
  const p1COPower = document.getElementById("p1COPower");
  const p2COPower = document.getElementById("p2COPower");
  const p1COSuper = document.getElementById("p1COSuper");
  const p2COSuper = document.getElementById("p2COSuper");
  const p1COAvatar = document.getElementById("p1COAvatar");
  const p2COAvatar = document.getElementById("p2COAvatar");
  const p1ChooseCO = document.getElementById("p1ChooseCO");
  const p2ChooseCO = document.getElementById("p2ChooseCO");
  const p1COCard = document.getElementById("p1COCard");
  const p2COCard = document.getElementById("p2COCard");
  const p1MeterFill = document.getElementById("p1MeterFill");
  const p2MeterFill = document.getElementById("p2MeterFill");
  const p1MeterLabel = document.getElementById("p1MeterLabel");
  const p2MeterLabel = document.getElementById("p2MeterLabel");
  const p1PowerBtn = document.getElementById("p1PowerBtn");
  const p2PowerBtn = document.getElementById("p2PowerBtn");
  const p1SuperBtn = document.getElementById("p1SuperBtn");
  const p2SuperBtn = document.getElementById("p2SuperBtn");

  const coModal = document.getElementById("coModal");
  const coModalHint = document.getElementById("coModalHint");
  const coList = document.getElementById("coList");
  const closeCoModal = document.getElementById("closeCoModal");

  const turnOverlay = document.getElementById("turnOverlay");
  const turnOverlayBox = document.getElementById("turnOverlayBox");
  const turnOverlayPlayer = document.getElementById("turnOverlayPlayer");
  const turnOverlayDay = document.getElementById("turnOverlayDay");
  const turnOverlayIncome = document.getElementById("turnOverlayIncome");

  let coModalTarget = null;
  let turnOverlayTimer = null;

  const shopBox = document.getElementById("shopBox");
  const shopList = document.getElementById("shopList");
  const closeShopBtn = document.getElementById("closeShopBtn");
  const shopHint = document.getElementById("shopHint");

  const keyBtn = document.getElementById("keyBtn");
  const keyBox = document.getElementById("keyBox");
  const closeKeyBtn = document.getElementById("closeKeyBtn");
  const terrainLegend = document.getElementById("terrainLegend");
  const unitLegend = document.getElementById("unitLegend");

  const logBox = document.getElementById("log");
  const helpBox = document.getElementById("help");
  const lowerPanels = document.getElementById("lowerPanels");
  const battleOverlay = document.getElementById("battleOverlay");
  const battleLeftImg = document.getElementById("battleLeftImg");
  const battleRightImg = document.getElementById("battleRightImg");
  const battleLeftHP = document.getElementById("battleLeftHP");
  const battleRightHP = document.getElementById("battleRightHP");
  const battleLeftLabel = document.getElementById("battleLeftLabel");
  const battleRightLabel = document.getElementById("battleRightLabel");
  const battleLeftDmg = document.getElementById("battleLeftDmg");
  const battleRightDmg = document.getElementById("battleRightDmg");

  /***********************************************************************
   * Game State
   ***********************************************************************/
  const Game = {
    day: 1,
    currentPlayer: 1,
    funds: { 1: 5000, 2: 5000 },

    terrain: [],
    buildings: [],

    units: [],

    sel: null,              // { type:"unit"/"building"/"tile", ... }
    phase: "IDLE",          // IDLE | MOVING | ATTACKING | SHOP
    moveMap: null,
    moveTiles: new Set(),
    path: [],
    atkTiles: new Set(),
    baseCycleIdx: { 1:0, 2:0 },

    hovered: { x:-1, y:-1 },
    gameOver: false,

    coChoice: { 1:"ANDY", 2:"ANDY" },
    coMeter: { 1:0, 2:0 },
    coState: { 1:null, 2:null }
  };

  /***********************************************************************
   * Entities
   ***********************************************************************/
  let UNIT_ID_SEQ = 1;

  function makeUnit(typeId, owner, x, y){
    const def = UNIT_DEF[typeId];
    const spriteList = getSpriteList(typeId, owner);
    const spriteIdx = typeId==="INF" && spriteList.length>1 ? randInt(spriteList.length) : 0;
    return {
      uid: UNIT_ID_SEQ++,
      typeId,
      def,
      owner,
      x, y,
      hp: def.maxHP,
      moved: false,
      acted: false,
      actionsLeft: 1,
      spriteIdx
    };
  }

  function unitAt(x,y){
    for(const u of Game.units){
      if(u.x===x && u.y===y) return u;
    }
    return null;
  }

  function buildingAt(x,y){
    if(!inBounds(x,y)) return null;
    return Game.buildings[y][x];
  }

  function terrainAt(x,y){
    if(!inBounds(x,y)) return TERRAIN.WATER;
    return Game.terrain[y][x];
  }

  function getSpriteList(typeId, ownerId){
    const byType = SPRITE_IMAGES[typeId];
    if(!byType) return [];
    return byType[ownerId] || [];
  }

  function getBuildingSprite(kindId, ownerId){
    const byKind = BUILDING_IMAGES[kindId];
    if(!byKind) return null;
    const key = (ownerId && byKind[ownerId]) ? ownerId : 0;
    return byKind[key] || null;
  }

  function getTerrainSprite(id){
    return TERRAIN_IMAGES[id] || null;
  }

  function makeBuildingNode(kindId, ownerId, size){
    const img = document.createElement("img");
    const sprite = getBuildingSprite(kindId, ownerId);
    if(sprite) img.src = sprite.src;
    img.width = size;
    img.height = size;
    img.className = "thumb";
    img.style.objectFit = "contain";
    img.style.background = "#0b1433";
    img.style.imageRendering = "pixelated";
    return img;
  }

  function makeTerrainNode(terrain, size){
    const img = document.createElement("img");
    const sprite = getTerrainSprite(terrain.id);
    if(sprite) img.src = sprite.src;
    img.width = size;
    img.height = size;
    img.className = "thumb";
    img.style.objectFit = "cover";
    img.style.imageRendering = "pixelated";
    return img;
  }

  function getUnitSpriteSrc(u){
    const list = getSpriteList(u.typeId, u.owner);
    if(!list.length) return "";
    const img = list[u.spriteIdx % list.length];
    return img ? img.src : "";
  }

  function getOwnedBases(playerId){
    const bases = [];
    for(let y=0;y<GRID_H;y++){
      for(let x=0;x<GRID_W;x++){
        const b = buildingAt(x,y);
        if(b && b.kindId==="BASE" && b.owner===playerId){
          bases.push({b,x,y});
        }
      }
    }
    bases.sort((a,b)=> (a.y - b.y) || (a.x - b.x));
    return bases;
  }

  function pickNextBase(playerId){
    const bases = getOwnedBases(playerId);
    if(!bases.length) return null;
    const idx = Game.baseCycleIdx[playerId] ?? 0;
    const choice = bases[idx % bases.length];
    Game.baseCycleIdx[playerId] = (idx + 1) % bases.length;
    return choice;
  }

  function autoOpenShopForCurrentPlayer(){
    if(Game.gameOver) return;
    const choice = pickNextBase(Game.currentPlayer);
    if(!choice) return;
    selectBuilding(choice.b, choice.x, choice.y);
    openShopIfOnOwnedBase();
  }

  function makeSpriteNode(typeId, ownerId, size){
    const img = new Image();
    const list = getSpriteList(typeId, ownerId);
    img.src = list[0]?.src || "";
    img.width = size;
    img.height = size;
    img.style.imageRendering = "pixelated";
    img.style.borderRadius = "8px";
    img.style.border = "1px solid #23346b";
    img.style.background = "#0b1433";
    return img;
  }

  function removeUnit(u){
    const idx = Game.units.findIndex(z => z.uid===u.uid);
    if(idx>=0) Game.units.splice(idx,1);
  }

  function owningPlayer(id){ return PLAYERS.find(p=>p.id===id) || PLAYERS[0]; }

  /***********************************************************************
   * NEW: Tile defense stat per your rule
   * - All building tiles: 3
   * - Ground tiles: 0
   ***********************************************************************/
  function tileDefenseStat(x,y){
    const b = buildingAt(x,y);
    return b ? 3 : 0;
  }

  /***********************************************************************
   * Map Generation
   ***********************************************************************/
  function initEmptyLayers(){
    Game.terrain = Array.from({length:GRID_H}, ()=>Array.from({length:GRID_W}, ()=>TERRAIN.PLAINS));
    Game.buildings = Array.from({length:GRID_H}, ()=>Array.from({length:GRID_W}, ()=>null));
  }

  function placeBuilding(x,y, kindId, owner=null){
    Game.buildings[y][x] = {
      kindId,
      def: BUILDING[kindId],
      owner,
      capturePoints: 20
    };
  }

  function generateMap(){
    initEmptyLayers();

    for(let y=0;y<GRID_H;y++){
      for(let x=0;x<GRID_W;x++){
        Game.terrain[y][x] = TERRAIN.PLAINS;
      }
    }

    const roadY = 5;
    for(let x=1;x<GRID_W-1;x++){
      Game.terrain[roadY][x] = TERRAIN.ROAD;
      Game.terrain[roadY+1][x] = TERRAIN.ROAD;
    }

    const forests = [
      {x:3,y:2},{x:4,y:2},{x:3,y:3},
      {x:11,y:2},{x:12,y:2},{x:12,y:3},
      {x:2,y:9},{x:3,y:9},{x:3,y:8},
      {x:12,y:9},{x:13,y:9},{x:12,y:8}
    ];
    for(const p of forests){
      if(inBounds(p.x,p.y)) Game.terrain[p.y][p.x] = TERRAIN.FOREST;
    }

    const mountains = [
      {x:7,y:2},{x:8,y:2},
      {x:7,y:9},{x:8,y:9},
      {x:7,y:5},{x:8,y:6}
    ];
    for(const p of mountains){
      if(inBounds(p.x,p.y)) Game.terrain[p.y][p.x] = TERRAIN.MOUNTAIN;
    }

    for(let x=0;x<3;x++){
      Game.terrain[0][x] = TERRAIN.WATER;
      Game.terrain[0][GRID_W-1-x] = TERRAIN.WATER;
      Game.terrain[GRID_H-1][x] = TERRAIN.WATER;
      Game.terrain[GRID_H-1][GRID_W-1-x] = TERRAIN.WATER;
    }

    placeBuilding(1,1,"HQ",1);
    placeBuilding(GRID_W-2, GRID_H-2, "HQ", 2);

    placeBuilding(2,1,"BASE",1);
    placeBuilding(1,2,"BASE",1);

    placeBuilding(GRID_W-3, GRID_H-2,"BASE",2);
    placeBuilding(GRID_W-2, GRID_H-3,"BASE",2);

    const cities = [
      {x:5,y:3},{x:10,y:3},
      {x:5,y:8},{x:10,y:8},
      {x:7,y:6},{x:8,y:5},
      {x:2,y:6},{x:13,y:6}
    ];
    for(const c of cities) placeBuilding(c.x,c.y,"CITY",null);
  }

  /***********************************************************************
   * Game Initialization / Reset
   ***********************************************************************/
  function loadSprites(){
    for(const [typeId, owners] of Object.entries(SPRITE_SOURCES)){
      SPRITE_IMAGES[typeId] = {};
      for(const [ownerId, srcList] of Object.entries(owners)){
        SPRITE_IMAGES[typeId][ownerId] = srcList.map(src=>{
          const img = new Image();
          img.src = src;
          return img;
        });
      }
    }

    for(const [kindId, owners] of Object.entries(BUILDING_SOURCES)){
      BUILDING_IMAGES[kindId] = {};
      for(const [ownerId, src] of Object.entries(owners)){
        const img = new Image();
        img.src = src;
        BUILDING_IMAGES[kindId][ownerId] = img;
      }
    }

    for(const [id, src] of Object.entries(TERRAIN_SOURCES)){
      const img = new Image();
      img.src = src;
      TERRAIN_IMAGES[id] = img;
    }
  }

  function freshMatch(){
    Game.day = 1;
    Game.currentPlayer = 1;
    Game.funds = { 1: 5000, 2: 5000 };
    Game.units = [];
    Game.sel = null;
    Game.phase = "IDLE";
    Game.moveMap = null;
    Game.moveTiles = new Set();
    Game.path = [];
    Game.atkTiles = new Set();
    Game.baseCycleIdx = {1:0, 2:0};
    Game.hovered = {x:-1,y:-1};
    Game.gameOver = false;
    Game.coMeter = {1:0, 2:0};
    Game.coState = {1:null, 2:null};
    Game.coChoice = {1:"ANDY", 2:"ANDY"};

    generateMap();

    // Starting units (balanced; includes some new unit types)
    Game.units.push(makeUnit("INF",1, 2,2));
    Game.units.push(makeUnit("INF",1, 3,1));
    Game.units.push(makeUnit("TANK",1, 2,3));
    Game.units.push(makeUnit("ART",1, 4,2));

    Game.units.push(makeUnit("INF",2, GRID_W-3, GRID_H-3));
    Game.units.push(makeUnit("INF",2, GRID_W-4, GRID_H-2));
    Game.units.push(makeUnit("TANK",2, GRID_W-3, GRID_H-4));
    Game.units.push(makeUnit("ART",2, GRID_W-5, GRID_H-3));

    clearLog();
    logLine("Match start. Player 1 begins.", 1);
    updateUI();
    renderLegend(); // NEW
    autoOpenShopForCurrentPlayer();
  }

  function hardReset(){
    UNIT_ID_SEQ = 1;
    freshMatch();
  }

  /***********************************************************************
   * Logging
   ***********************************************************************/
  function clearLog(){
    logBox.innerHTML = "";
  }

  function logLine(text, playerId=null){
    const p = document.createElement("p");
    p.className = "line " + (playerId===1 ? "p1" : playerId===2 ? "p2" : "");
    p.textContent = text;
    logBox.appendChild(p);
    logBox.scrollTop = logBox.scrollHeight;
  }

  function consumeAction(u){
    if(!u) return;
    if(typeof u.actionsLeft!=="number") u.actionsLeft = 1;
    u.actionsLeft = Math.max(0, u.actionsLeft - 1);
    if(u.actionsLeft > 0){
      u.moved = false;
      u.acted = false;
    } else {
      u.moved = true;
      u.acted = true;
    }
  }

  function refreshPlayerUnits(playerId, minActions=1){
    for(const u of Game.units){
      if(u.owner===playerId){
        const targetActions = Math.max(minActions, 1);
        u.actionsLeft = targetActions;
        u.moved = false;
        u.acted = false;
      }
    }
  }

  /***********************************************************************
   * Income & Turn Progression
   ***********************************************************************/
  function countOwnedIncome(playerId){
    let total = 0;
    for(let y=0;y<GRID_H;y++){
      for(let x=0;x<GRID_W;x++){
        const b = buildingAt(x,y);
        if(b && b.owner===playerId){
          total += b.def.income;
        }
      }
    }
    return total;
  }

  function resetUnitsForTurn(playerId){
    for(const u of Game.units){
      if(u.owner===playerId){
        const dbl = hasDoubleActions(playerId);
        u.moved = false;
        u.acted = false;
        u.actionsLeft = dbl ? 2 : 1;
      }
    }
  }

  function endTurn(){
    if(Game.gameOver) return;

    clearCOState(Game.currentPlayer);

    closeShop();
    closeKey(); // NEW

    clearSelection();

    Game.currentPlayer = (Game.currentPlayer===1) ? 2 : 1;

    if(Game.currentPlayer===1){
      Game.day += 1;
      logLine("— Day " + Game.day + " —", null);
    }

    const income = countOwnedIncome(Game.currentPlayer);
    Game.funds[Game.currentPlayer] += income;
    logLine(`${owningPlayer(Game.currentPlayer).name} receives ${income} funds (income).`, Game.currentPlayer);

    resetUnitsForTurn(Game.currentPlayer);
    grantCOMeter(Game.currentPlayer, 10);

    updateUI();
    autoOpenShopForCurrentPlayer();
    showTurnOverlay({
      playerId: Game.currentPlayer,
      day: Game.day,
      income,
      co: getCOChoice(Game.currentPlayer)
    });
  }

  /***********************************************************************
   * Selection & Phases
   ***********************************************************************/
  function clearSelection(){
    Game.sel = null;
    Game.phase = "IDLE";
    Game.moveMap = null;
    Game.moveTiles = new Set();
    Game.atkTiles = new Set();
    Game.path = [];
    elSelHint.textContent = "Click a unit, building, or tile.";
    elSelKv.innerHTML = "";
    elSelStats.innerHTML = "";
  }

  function selectUnit(u){
    if(Game.gameOver) return;
    clearSelection();
    Game.sel = { type:"unit", unit:u, x:u.x, y:u.y };
    updateSelectionPanel();
    computeMoveOverlayIfApplicable();
    computeAttackOverlayIfApplicable();
    if(u.owner===Game.currentPlayer && !u.acted){
      Game.phase = "ATTACKING";
    }
  }

  function selectBuilding(b, x, y){
    if(Game.gameOver) return;
    clearSelection();
    Game.sel = { type:"building", building:b, x, y };
    updateSelectionPanel();
  }

  // NEW: select tile (even empty) so we can show defense stat
  function selectTile(x,y){
    if(Game.gameOver) return;
    clearSelection();
    Game.sel = { type:"tile", x, y };
    updateSelectionPanel();
  }

  function updateSelectionPanel(){
    elSelKv.innerHTML = "";
    elSelStats.innerHTML = "";

    if(!Game.sel){
      elSelHint.textContent = "Click a unit, building, or tile.";
      return;
    }

    if(Game.sel.type==="unit"){
      const u = Game.sel.unit;
      const p = owningPlayer(u.owner);
      const hpPct = u.hp / u.def.maxHP;
      const { minR, maxR } = getRangeForUnit(u);
      const rangeText = formatRangeText(minR, maxR, unitMovePoints(u), u.def.id==="RKT");
      const sprite = makeSpriteNode(u.typeId, u.owner, 80);
      const imgRow = document.createElement("div");
      imgRow.className = "selImgRow";
      imgRow.appendChild(sprite);

      elSelHint.textContent = "Press ESC to unselect";
      addKV("Owner", p.name);
      addKV("Type", `${u.def.name} (${u.def.abbr})`); // NEW: show abbr
      addKV("HP", `${u.hp}/${u.def.maxHP}`);
      addKV("Move", `${u.def.move} (${u.def.movementType})`);
      addKV("Range", rangeText);
      addKV("Status", `${u.moved ? "Moved" : "Can Move"} / ${u.acted ? "Attacked" : "Can Atk"}`);

      const tile = terrainAt(u.x,u.y);
      addKV("Terrain", tile.name);

      const b = buildingAt(u.x,u.y);
      addKV("Tile Defense", String(tileDefenseStat(u.x,u.y))); // NEW per your rule

      if(b){
        addKV("Building", b.def.name + (b.owner ? ` (Owned by P${b.owner})` : " (Neutral)"));
      }

      // Detailed stat pills similar to shop cards
      const pills = [];
      const typePill = document.createElement("span");
      typePill.className = "pill";
      typePill.textContent = u.def.name;
      pills.push(typePill);

      const hpPill = document.createElement("span");
      hpPill.className = "pill " + (hpPct>0.66 ? "good" : hpPct>0.33 ? "warn" : "bad");
      hpPill.textContent = `HP ${u.hp}/${u.def.maxHP}`;
      pills.push(hpPill);

      const dmgPreview = previewDamageRange(u.def);
      const dmgPill = document.createElement("span");
      dmgPill.className = "pill warn";
      dmgPill.textContent = `Damage roll vs INF: ${dmgPreview.min}-${dmgPreview.max}`;
      pills.push(dmgPill);

      const armorPill = document.createElement("span");
      armorPill.className = "pill";
      armorPill.textContent = `Armor ${u.def.armor ?? 0}`;
      pills.push(armorPill);

      const capPill = document.createElement("span");
      capPill.className = "pill " + (u.def.canCapture ? "good" : "");
      capPill.textContent = u.def.canCapture ? "Can capture" : "No capture";
      pills.push(capPill);

      const movePill = document.createElement("span");
      movePill.className = "pill";
      movePill.textContent = `Move: ${u.def.move} (${u.def.movementType})`;

      const rangePill = document.createElement("span");
      rangePill.className = "pill";
      rangePill.textContent = `Range: ${rangeText}`;

      const statusPill = document.createElement("span");
      statusPill.className = "pill";
      statusPill.textContent = `Status: ${u.moved ? "Moved" : "Can Move"} / ${u.acted ? "Attacked" : "Can Atk"}`;

      const terrain = terrainAt(u.x,u.y);
      const terrainPill = document.createElement("span");
      terrainPill.className = "pill";
      terrainPill.textContent = `Terrain: ${terrain.name}`;

      const defPill = document.createElement("span");
      defPill.className = "pill";
      defPill.textContent = `Tile Def: ${tileDefenseStat(u.x,u.y)}`;

      const row1 = document.createElement("div");
      row1.className = "selRow center";
      row1.appendChild(typePill);
      row1.appendChild(hpPill);

      const row2 = document.createElement("div");
      row2.className = "selRow";
      row2.appendChild(dmgPill);
      row2.appendChild(armorPill);
      row2.appendChild(capPill);

      const row3 = document.createElement("div");
      row3.className = "selRow center";
      row3.appendChild(movePill);
      row3.appendChild(rangePill);

      const row4 = document.createElement("div");
      row4.className = "selRow center";
      row4.appendChild(statusPill);
      row4.appendChild(terrainPill);
      row4.appendChild(defPill);

      setSelStats([imgRow, row1, row2, row3, row4]);
    } else if(Game.sel.type==="building") {
      const b = Game.sel.building;
      elSelHint.textContent = "Selected building.";

      const imgRow = document.createElement("div");
      imgRow.className = "selImgRow";
      imgRow.appendChild(makeBuildingNode(b.kindId, b.owner ?? 0, 80));

      const typePill = document.createElement("span");
      typePill.className = "pill";
      typePill.textContent = b.def.name;

      const ownerPill = document.createElement("span");
      ownerPill.className = "pill";
      ownerPill.textContent = b.owner ? `Owner: P${b.owner}` : "Owner: Neutral";

      const hpPill = document.createElement("span");
      hpPill.className = "pill warn";
      hpPill.textContent = `HP: ${b.capturePoints}/20`;

      const defPill = document.createElement("span");
      defPill.className = "pill";
      defPill.textContent = `Tile Def: ${tileDefenseStat(Game.sel.x, Game.sel.y)}`;

      const terrainPill = document.createElement("span");
      terrainPill.className = "pill";
      terrainPill.textContent = `Terrain: ${terrainAt(Game.sel.x, Game.sel.y).name}`;

      const row1 = document.createElement("div");
      row1.className = "selRow center";
      row1.appendChild(typePill);
      row1.appendChild(ownerPill);
      row1.appendChild(hpPill);

      const row2 = document.createElement("div");
      row2.className = "selRow center";
      row2.appendChild(defPill);
      row2.appendChild(terrainPill);

      setSelStats([imgRow, row1, row2]);
    } else {
      // NEW: tile selection view
      elSelHint.textContent = "Selected tile.";
      const t = terrainAt(Game.sel.x, Game.sel.y);

      const imgRow = document.createElement("div");
      imgRow.className = "selImgRow";
      imgRow.appendChild(makeTerrainNode(t, 80));

      const terrainPill = document.createElement("span");
      terrainPill.className = "pill";
      terrainPill.textContent = `Terrain: ${t.name}`;

      const defPill = document.createElement("span");
      defPill.className = "pill";
      defPill.textContent = "Tile Def: 0";

      const row1 = document.createElement("div");
      row1.className = "selRow center";
      row1.appendChild(terrainPill);
      row1.appendChild(defPill);

      setSelStats([imgRow, row1]);
    }
  }

  function addKV(k,v){
    const a=document.createElement("div"); a.textContent=k;
    const b=document.createElement("div"); b.textContent=v;
    elSelKv.appendChild(a); elSelKv.appendChild(b);
  }

  function setSelStats(nodes){
    elSelStats.innerHTML = "";
    for(const n of nodes){
      elSelStats.appendChild(n);
    }
  }

  function panelsOpen(){
    return shopBox.style.display==="block" || keyBox.style.display==="block";
  }

  function updateHelpPosition(){
    if(!helpBox || !lowerPanels) return;
    const parent = helpBox.parentElement;
    if(!parent) return;
    if(panelsOpen()){
      if(helpBox.nextElementSibling){
        parent.appendChild(helpBox);
      }
    } else {
      parent.insertBefore(helpBox, lowerPanels);
    }
  }

  /***********************************************************************
   * CO selection & income panel
   ***********************************************************************/
  function getCOChoice(playerId){
    const id = Game.coChoice[playerId] || "ANDY";
    return CO_DATA[id] || CO_DATA.ANDY;
  }

  function setCOChoice(playerId, coId){
    if(!CO_DATA[coId]) return;
    Game.coChoice[playerId] = coId;
    renderCOSection();
    logLine(`${owningPlayer(playerId).name} selects ${CO_DATA[coId].name}.`, playerId);
  }

  function setCOAvatar(el, co, playerId){
    if(!el) return;
    const p = owningPlayer(playerId);
    el.style.borderColor = p.color;
    el.style.background = `linear-gradient(135deg, ${p.dark}, ${p.color}55)`;
    el.innerHTML = "";
    if(co.img){
      const img = document.createElement("img");
      img.src = co.img;
      img.alt = co.name;
      el.appendChild(img);
    } else {
      el.textContent = co.name.slice(0,1);
    }
  }

  function renderCOSection(){
    const co1 = getCOChoice(1);
    const co2 = getCOChoice(2);

    p1COName.textContent = co1.name;
    p2COName.textContent = co2.name;
    p1COSpecialty.innerHTML = `<div class="abilityLine"><span class="abilityBadge">Day-to-day</span><span class="abilityCopy">${co1.specialty}</span></div>`;
    p2COSpecialty.innerHTML = `<div class="abilityLine"><span class="abilityBadge">Day-to-day</span><span class="abilityCopy">${co2.specialty}</span></div>`;
    p1COPower.innerHTML = `<div class="abilityLine"><span class="abilityBadge">CO Power</span><span class="abilityCopy">${co1.power}</span></div>`;
    p2COPower.innerHTML = `<div class="abilityLine"><span class="abilityBadge">CO Power</span><span class="abilityCopy">${co2.power}</span></div>`;
    p1COSuper.innerHTML = `<div class="abilityLine"><span class="abilityBadge">Super CO</span><span class="abilityCopy">${co1.super}</span></div>`;
    p2COSuper.innerHTML = `<div class="abilityLine"><span class="abilityBadge">Super CO</span><span class="abilityCopy">${co2.super}</span></div>`;

    setCOAvatar(p1COAvatar, co1, 1);
    setCOAvatar(p2COAvatar, co2, 2);
    setCOAvatar(p1TopAvatar, co1, 1);
    setCOAvatar(p2TopAvatar, co2, 2);
    if(p1TopTooltip) p1TopTooltip.innerHTML = `${p1COSpecialty.innerHTML}${p1COPower.innerHTML}${p1COSuper.innerHTML}`;
    if(p2TopTooltip) p2TopTooltip.innerHTML = `${p2COSpecialty.innerHTML}${p2COPower.innerHTML}${p2COSuper.innerHTML}`;

    const m1 = Game.coMeter[1] ?? 0;
    const m2 = Game.coMeter[2] ?? 0;
    if(p1MeterFill) p1MeterFill.style.width = `${clamp(m1,0,100)}%`;
    if(p2MeterFill) p2MeterFill.style.width = `${clamp(m2,0,100)}%`;
    if(p1TopMeterFill) p1TopMeterFill.style.width = `${clamp(m1,0,100)}%`;
    if(p2TopMeterFill) p2TopMeterFill.style.width = `${clamp(m2,0,100)}%`;
    if(p1MeterLabel) p1MeterLabel.textContent = `Meter ${Math.round(m1)}%`;
    if(p2MeterLabel) p2MeterLabel.textContent = `Meter ${Math.round(m2)}%`;

    const powerCost = 60, superCost = 100;
    const p1State = Game.coState[1];
    const p2State = Game.coState[2];
    const p1PowerDisabled = m1 < powerCost || p1State;
    const p2PowerDisabled = m2 < powerCost || p2State;
    const p1SuperDisabled = m1 < superCost || p1State;
    const p2SuperDisabled = m2 < superCost || p2State;
    if(p1PowerBtn) p1PowerBtn.disabled = p1PowerDisabled;
    if(p2PowerBtn) p2PowerBtn.disabled = p2PowerDisabled;
    if(p1SuperBtn) p1SuperBtn.disabled = p1SuperDisabled;
    if(p2SuperBtn) p2SuperBtn.disabled = p2SuperDisabled;
    if(p1TopPower) p1TopPower.disabled = p1PowerDisabled;
    if(p2TopPower) p2TopPower.disabled = p2PowerDisabled;
    if(p1TopSuper) p1TopSuper.disabled = p1SuperDisabled;
    if(p2TopSuper) p2TopSuper.disabled = p2SuperDisabled;
  }

  function openCOModal(playerId){
    coModalTarget = playerId;
    if(coModalHint) coModalHint.textContent = `Assign a CO for Player ${playerId}`;
    renderCOList();
    if(coModal) coModal.style.display = "flex";
  }

  function closeCOModal(){
    if(coModal) coModal.style.display = "none";
    coModalTarget = null;
  }

  function renderCOList(){
    if(!coList) return;
    coList.innerHTML = "";
    const current = Game.coChoice[coModalTarget] || "ANDY";
    for(const coId of Object.keys(CO_DATA)){
      const co = CO_DATA[coId];
      const row = document.createElement("div");
      row.className = "coOption";

      const avatar = document.createElement("div");
      avatar.className = "coAvatar";
      setCOAvatar(avatar, co, coModalTarget || 1);

      const textBox = document.createElement("div");
      textBox.className = "coText";
      const name = document.createElement("div");
      name.className = "coName";
      name.textContent = co.name;
      const spec = document.createElement("div");
      spec.className = "coBuff";
      spec.innerHTML = `<div class="abilityLine"><span class="abilityBadge">Day-to-day</span><span class="abilityCopy">${co.specialty}</span></div>`;
      const power = document.createElement("div");
      power.className = "coBuff small";
      power.innerHTML = `<div class="abilityLine"><span class="abilityBadge">CO Power</span><span class="abilityCopy">${co.power}</span></div>`;
      const sup = document.createElement("div");
      sup.className = "coBuff small";
      sup.innerHTML = `<div class="abilityLine"><span class="abilityBadge">Super CO</span><span class="abilityCopy">${co.super}</span></div>`;

      textBox.appendChild(name);
      textBox.appendChild(spec);
      textBox.appendChild(power);
      textBox.appendChild(sup);

      const btn = document.createElement("button");
      btn.className = "btn tiny";
      btn.textContent = coId===current ? "Selected" : "Choose";
      if(coId===current) btn.classList.add("primary");
      btn.addEventListener("click", ()=>{
        if(coModalTarget){
          setCOChoice(coModalTarget, coId);
          closeCOModal();
        }
      });

      row.appendChild(avatar);
      row.appendChild(textBox);
      row.appendChild(btn);
      coList.appendChild(row);
    }
  }

  /***********************************************************************
   * CO meter & powers
   ***********************************************************************/
  const CO_POWER_COST = 60;
  const CO_SUPER_COST = 100;

  function grantCOMeter(playerId, amount){
    const cur = Game.coMeter[playerId] ?? 0;
    Game.coMeter[playerId] = clamp(cur + amount, 0, 100);
  }

  function clearCOState(playerId){
    Game.coState[playerId] = null;
  }

  function hasDoubleActions(playerId){
    return Game.coState[playerId] === "SUPER";
  }

  function grantExtraActions(playerId, minimum=2){
    for(const u of Game.units){
      if(u.owner===playerId){
        u.actionsLeft = Math.max(u.actionsLeft || 1, minimum);
        u.moved = false;
        u.acted = false;
      }
    }
  }

  function healPlayerUnits(playerId, amount){
    for(const u of Game.units){
      if(u.owner===playerId){
        u.hp = clamp(u.hp + amount, 0, u.def.maxHP);
      }
    }
  }

  function useCOPower(playerId, tier){
    const cost = tier==="SUPER" ? CO_SUPER_COST : CO_POWER_COST;
    if((Game.coMeter[playerId] ?? 0) < cost) return;
    Game.coMeter[playerId] -= cost;
    Game.coState[playerId] = tier;
    const co = getCOChoice(playerId);
    logLine(`${owningPlayer(playerId).name} activates ${co.name} ${tier==="SUPER" ? "Super CO Power" : "CO Power"}!`, playerId);
    if(co.id==="ANDY"){
      healPlayerUnits(playerId, tier==="SUPER" ? 5 : 2);
    }
    refreshPlayerUnits(playerId, tier==="SUPER" ? 2 : 1);
    renderCOSection();
    updateUI();
  }

  function showTurnOverlay({ playerId, day, income, co }){
    if(!turnOverlay || !turnOverlayBox) return;
    const pillClass = playerId===1 ? "coPill p1" : "coPill p2";
    turnOverlayPlayer.className = pillClass;
    turnOverlayPlayer.textContent = `Player ${playerId}`;
    turnOverlayDay.textContent = `Day ${day}`;
    turnOverlayIncome.textContent = `Income +${income}`;

    if(turnOverlayTimer) clearTimeout(turnOverlayTimer);
    turnOverlay.classList.remove("show");
    void turnOverlay.offsetWidth;
    turnOverlay.style.display = "flex";
    requestAnimationFrame(()=>{ turnOverlay.classList.add("show"); });

    turnOverlayTimer = setTimeout(()=>{
      turnOverlay.classList.remove("show");
      setTimeout(()=>{ turnOverlay.style.display = "none"; }, 320);
    }, 500);
  }

  /***********************************************************************
   * Battle Overlay
   ***********************************************************************/
  function setHPBar(el, current, max){
    const pct = clamp(current / max, 0, 1);
    el.style.width = `${pct*100}%`;
    el.style.background = pct>0.66 ? "#74ff8a" : pct>0.33 ? "#ffd166" : "#ff5d7a";
  }

  function showBattleOverlay({ attacker, defender, atkBefore, atkAfter, defBefore, defAfter, attackerLabel, defenderLabel, attackerImg, defenderImg, atkMax, defMax, leftText="", rightText="" }){
    return new Promise(resolve=>{
      if(!battleOverlay) return resolve();
      battleOverlay.style.display = "flex";

      battleLeftImg.src = attackerImg || "";
      battleRightImg.src = defenderImg || "";
      battleLeftLabel.textContent = attackerLabel;
      battleRightLabel.textContent = defenderLabel;
      if(battleLeftDmg) battleLeftDmg.textContent = leftText;
      if(battleRightDmg) battleRightDmg.textContent = rightText;

      battleLeftImg.parentElement.classList.remove("hitLeft");
      battleRightImg.parentElement.classList.remove("hitRight");

      setHPBar(battleLeftHP, atkBefore, atkMax || atkBefore || 1);
      setHPBar(battleRightHP, defBefore, defMax || defBefore || 1);

      void battleOverlay.offsetWidth; // reflow

      setTimeout(()=>{
        battleLeftImg.parentElement.classList.add("hitLeft");
        battleRightImg.parentElement.classList.add("hitRight");
        setHPBar(battleLeftHP, atkAfter, atkMax || Math.max(atkBefore,1));
        setHPBar(battleRightHP, defAfter, defMax || Math.max(defBefore,1));
      }, 30);

      setTimeout(()=>{
        battleOverlay.style.display = "none";
        resolve();
      }, 1300);
    });
  }

  /***********************************************************************
   * Movement
   ***********************************************************************/
  const DIRS = [
    {dx:1,dy:0},{dx:-1,dy:0},{dx:0,dy:1},{dx:0,dy:-1}
  ];

  function isTileBlockedForMovement(x,y, movingUnit){
    const u = unitAt(x,y);
    if(!u) return false;
    return (u.uid !== movingUnit.uid);
  }

  function movementCost(unit, x, y){
    const t = terrainAt(x,y);
    const mtype = unit.def.movementType;
    const cost = t.moveCost[mtype] ?? 99;
    return cost;
  }

  function computeMoveOverlayIfApplicable(){
    Game.moveTiles = new Set();
    Game.moveMap = null;
    Game.atkTiles = new Set();
    Game.path = [];

    if(!Game.sel || Game.sel.type!=="unit") return;
    const u = Game.sel.unit;

    if(u.owner !== Game.currentPlayer) return;
    if(u.moved) return;

    const start = {x:u.x,y:u.y};
    const maxMove = unitMovePoints(u);

    const dist = new Map();
    const prev = new Map();
    const open = [];

    const sk = key(start.x,start.y);
    dist.set(sk, 0);
    prev.set(sk, null);
    open.push({k:sk, cost:0});

    function pushOrUpdate(k,c){
      for(const it of open){
        if(it.k===k){
          if(c<it.cost){ it.cost=c; }
          return;
        }
      }
      open.push({k, cost:c});
    }

    while(open.length){
      open.sort((a,b)=>a.cost-b.cost);
      const cur = open.shift();
      if(!cur) break;
      const {x,y} = parseKey(cur.k);
      const curCost = cur.cost;

      if(dist.get(cur.k) !== curCost) continue;

      for(const d of DIRS){
        const nx=x+d.dx, ny=y+d.dy;
        if(!inBounds(nx,ny)) continue;

        const step = movementCost(u,nx,ny);
        if(step>=99) continue;
        if(isTileBlockedForMovement(nx,ny,u)) continue;

        const nc = curCost + step;
        if(nc > maxMove) continue;

        const nk = key(nx,ny);
        const old = dist.get(nk);
        if(old===undefined || nc < old){
          dist.set(nk,nc);
          prev.set(nk, cur.k);
          pushOrUpdate(nk,nc);
        }
      }
    }

    Game.moveMap = { dist, prev, startKey: sk };
    for(const k of dist.keys()){
      Game.moveTiles.add(k);
    }
  }

  function computeAttackOverlayIfApplicable(){
    Game.atkTiles = new Set();
    if(!Game.sel || Game.sel.type!=="unit") return;
    const u = Game.sel.unit;
    if(u.owner !== Game.currentPlayer) return;
    if(u.acted) return;
    Game.atkTiles = computeAttackTilesFromPosition(u, {x:u.x, y:u.y});
  }

  function reconstructPath(toKey){
    if(!Game.moveMap) return [];
    const { prev, startKey } = Game.moveMap;

    const out = [];
    let cur = toKey;
    while(cur && cur!==startKey){
      out.push(cur);
      cur = prev.get(cur);
    }
    out.push(startKey);
    out.reverse();
    return out.map(parseKey);
  }

  /***********************************************************************
   * Attack Tiles
   ***********************************************************************/
  function computeAttackTilesFromPosition(unit, pos){
    const tiles = new Set();
    const { minR, maxR } = getRangeForUnit(unit);

    for(let y=0;y<GRID_H;y++){
      for(let x=0;x<GRID_W;x++){
        const d = Math.abs(x-pos.x)+Math.abs(y-pos.y);
        if(d>=minR && d<=maxR){
          tiles.add(key(x,y));
        }
      }
    }
    return tiles;
  }

  function enemyInRangeAt(unit, k){
    const {x,y} = parseKey(k);
    const target = unitAt(x,y);
    if(!target) return false;
    return target.owner !== unit.owner;
  }

  function isDirectUnit(u){ return !u.def.indirect; }
  function isInfantry(u){ return u.def.id==="INF"; }

  function unitMoveBonus(u){
    const co = getCOChoice(u.owner);
    const state = Game.coState[u.owner];
    let bonus = 0;
    if(co.id==="MAX" && isDirectUnit(u)){
      if(state==="SUPER") bonus += 2;
      else if(state==="POWER") bonus += 1;
    }
    if(co.id==="SAMI" && isInfantry(u)){
      if(state==="SUPER") bonus += 2;
      else if(state==="POWER") bonus += 1;
    }
    if(co.id==="ANDY" && state==="SUPER"){
      bonus += 1;
    }
    return bonus;
  }

  function unitMovePoints(u){
    return u.def.move + unitMoveBonus(u);
  }

  function getRangeForUnit(u){
    let minR = u.def.rangeMin;
    let maxR = u.def.rangeMax;
    const co = getCOChoice(u.owner);
    if(co.id==="MAX" && u.def.indirect){
      maxR = Math.max(minR, maxR-1);
    }
    return { minR, maxR };
  }

  // Show attack range text; rockets get a note for their move+fire reach (since this build allows it)
  function formatRangeText(rangeMin, rangeMax, move=0, isRocket=false){
    if(isRocket){
      const threat = rangeMax + move;
      return `${rangeMin}-${rangeMax} (max reach ${threat} w/ move)`;
    }
    return `${rangeMin}-${rangeMax}`;
  }

  function attackMultiplier(attacker, defender){
    const co = getCOChoice(attacker.owner);
    const state = Game.coState[attacker.owner];
    const direct = isDirectUnit(attacker);
    let mult = 1;
    if(co.id==="MAX"){
      if(direct) mult *= 1.2;
      if(direct && state==="POWER") mult *= 1.4;
      if(direct && state==="SUPER") mult *= 1.6;
    }
    if(co.id==="SAMI" && isInfantry(attacker)){
      mult *= 1.2;
      if(state==="POWER") mult *= 1.5;
      if(state==="SUPER") mult *= 1.6;
    }
    if(co.id==="ANDY" && state==="SUPER"){
      mult *= 1.2;
    }
    return mult;
  }

  function luckBonus(attacker){
    const co = getCOChoice(attacker.owner);
    const state = Game.coState[attacker.owner];
    if(co.id!=="NELL") return 0;
    if(state==="SUPER") return randInt(7); // 0-6
    if(state==="POWER") return randInt(5); // 0-4
    return randInt(3); // 0-2
  }

  /***********************************************************************
   * Combat
   ***********************************************************************/
  function terrainDefenseBonus(x,y){
    const t = terrainAt(x,y);
    let def = t.def;
    const b = buildingAt(x,y);
    if(b) def += b.def.def;
    return def;
  }

  function computeDamageRoll(attacker, defender){
    const atkBase = attacker.def.baseAtk[defender.def.id] ?? 4;
    const hpFactor = attacker.hp / attacker.def.maxHP;
    let raw = atkBase * (0.75 + 0.75*hpFactor);

    raw *= attackMultiplier(attacker, defender);

    const defBonus = terrainDefenseBonus(defender.x, defender.y);
    const armor = defender.def.armor ?? 0;

    const reduction = clamp(0.10*defBonus + 0.08*armor, 0, 0.65);
    const base = Math.max(1, raw * (1 - reduction));

    const min = Math.max(1, Math.floor(base * 0.85));
    const max = Math.max(min + 1, Math.ceil(base * 1.15));
    let roll = clamp(randBetween(min, max), 1, defender.def.maxHP);
    roll = clamp(roll + luckBonus(attacker), 1, defender.def.maxHP);
    return { roll, min, max };
  }

  function previewDamageRange(def){
    const base = def.baseAtk.INF ?? 4;
    const min = Math.max(1, Math.floor(base * 0.85));
    const max = Math.max(min + 1, Math.ceil(base * 1.15));
    return { min, max };
  }

  function canRetaliate(defender, attacker){
    if(defender.def.indirect) return false;
    const d = manhattan({x:defender.x,y:defender.y},{x:attacker.x,y:attacker.y});
    const { minR, maxR } = getRangeForUnit(defender);
    return d>=minR && d<=maxR;
  }

  function damageLabel(roll, min, max, prefix=""){
    const span = (max - min) || 1;
    const hi = max - Math.max(1, Math.floor(span*0.2));
    const lo = min + Math.floor(span*0.2);
    let tag = "Decent!";
    if(roll >= hi) tag = "Lucky!";
    else if(roll <= lo) tag = "Glancing!";
    return `${prefix}${tag} ${roll} Damage Dealt`;
  }

  async function performAttack(attacker, defender){
    if(Game.gameOver) return;
    if(attacker.acted) return;

    const defBefore = defender.hp;
    const atkBefore = attacker.hp;

    const { roll: dmgToDef, min: atkMin, max: atkMax } = computeDamageRoll(attacker, defender);
    const newDefHP = clamp(defender.hp - dmgToDef, 0, defender.def.maxHP);

    let dmgToAtk = 0, defMin=0, defMax=0;
    let newAtkHP = atkBefore;
    if(canRetaliate(defender, attacker) && newDefHP>0){
      const res = computeDamageRoll(defender, attacker);
      dmgToAtk = res.roll; defMin = res.min; defMax = res.max;
      newAtkHP = clamp(attacker.hp - dmgToAtk, 0, attacker.def.maxHP);
    }

    grantCOMeter(attacker.owner, 15);
    if(dmgToAtk>0) grantCOMeter(defender.owner, 10);

    const leftText = damageLabel(dmgToDef, atkMin, atkMax, "");
    const rightText = dmgToAtk>0 ? `Retaliated ${dmgToAtk} Damage` : "No Retaliation";

    await showBattleOverlay({
      attacker,
      defender,
      atkBefore,
      atkAfter: newAtkHP,
      defBefore,
      defAfter: newDefHP,
      attackerLabel: `${attacker.def.name}`,
      defenderLabel: `${defender.def.name}`,
      attackerImg: getUnitSpriteSrc(attacker),
      defenderImg: getUnitSpriteSrc(defender),
      atkMax: attacker.def.maxHP,
      defMax: defender.def.maxHP,
      leftText,
      rightText
    });

    defender.hp = newDefHP;
    logLine(`${owningPlayer(attacker.owner).name} ${attacker.def.name} hits ${defender.def.name} for ${dmgToDef} (roll ${atkMin}-${atkMax}).`, attacker.owner);

    if(defender.hp<=0){
      logLine(`${defender.def.name} destroyed.`, attacker.owner);
      removeUnit(defender);
      attacker.acted = true;
      return;
    }

    if(dmgToAtk>0){
      attacker.hp = newAtkHP;
      logLine(`${defender.def.name} retaliates for ${dmgToAtk} (roll ${defMin}-${defMax}).`, defender.owner);

      if(attacker.hp<=0){
        logLine(`${attacker.def.name} destroyed.`, defender.owner);
        removeUnit(attacker);
      } else {
        consumeAction(attacker);
      }
    } else {
      consumeAction(attacker);
    }

    renderCOSection();
  }

  /***********************************************************************
   * Capture Mechanics
   ***********************************************************************/
  async function tryCapture(unit){
    if(!unit.def.canCapture) return false;

    const b = buildingAt(unit.x, unit.y);
    if(!b) return false;

    if(b.owner === unit.owner && b.capturePoints===20) return false;

    const co = getCOChoice(unit.owner);
    const state = Game.coState[unit.owner];
    const before = b.capturePoints;
    let capturePower = unit.hp;
    if(co.id==="SAMI"){
      if(state==="SUPER"){
        capturePower = 99; // one-turn capture
      } else if(state==="POWER"){
        capturePower = unit.hp * 2;
      } else {
        capturePower = Math.floor(unit.hp * 1.5);
      }
    }
    const after = clamp(b.capturePoints - capturePower, 0, 20);

    const captureDelta = before - after;
    await showBattleOverlay({
      attacker: unit,
      defender: b,
      atkBefore: unit.hp,
      atkAfter: unit.hp,
      defBefore: before,
      defAfter: after,
      attackerLabel: `${unit.def.name}`,
      defenderLabel: `${b.def.name}`,
      attackerImg: getUnitSpriteSrc(unit),
      defenderImg: (getBuildingSprite(b.kindId, b.owner ?? 0)||{}).src || "",
      atkMax: unit.def.maxHP,
      defMax: 20,
      leftText: `Capture -${captureDelta} Points`,
      rightText: "No Retaliation"
    });

    grantCOMeter(unit.owner, 20);
    consumeAction(unit);

    b.capturePoints = after;
    logLine(`${owningPlayer(unit.owner).name} captures ${b.def.name}: ${b.capturePoints}/20 remaining.`, unit.owner);

    if(b.capturePoints<=0){
      b.owner = unit.owner;
      b.capturePoints = 20;
      logLine(`${b.def.name} captured by ${owningPlayer(unit.owner).name}.`, unit.owner);

      if(b.kindId==="HQ"){
        Game.gameOver = true;
        logLine(`${owningPlayer(unit.owner).name} wins by capturing the HQ.`, unit.owner);
      }
    }

    unit.acted = true;
    return true;
  }

  /***********************************************************************
   * Building / Shop
   ***********************************************************************/
  // UPDATED: include new units; keep existing list concept
  const SHOP_UNITS = ["INF","TANK","MDT","ART","RKT"];

  function canBuildFromBuilding(b, playerId){
    if(!b || b.owner!==playerId) return false;
    if(b.kindId==="BASE") return true;
    const co = getCOChoice(playerId);
    const state = Game.coState[playerId];
    if(co.id==="HACHI" && state==="SUPER" && b.kindId==="CITY") return true;
    return false;
  }

  function getUnitCost(def, playerId){
    const co = getCOChoice(playerId);
    const state = Game.coState[playerId];
    let cost = def.cost;
    if(co.id==="HACHI"){
      if(state==="POWER" || state==="SUPER") cost = Math.floor(cost * 0.5);
      else cost = Math.floor(cost * 0.9);
    }
    return cost;
  }

  function openShopIfOnOwnedBase(){
    if(Game.gameOver) return;
    if(!Game.sel || Game.sel.type!=="building") return;
    const b = Game.sel.building;
    if(!canBuildFromBuilding(b, Game.currentPlayer)) return;

    Game.phase = "SHOP";
    shopBox.style.display = "block";
    renderShop();
    updateHelpPosition();
  }

  function closeShop(){
    if(Game.phase==="SHOP"){
      Game.phase = "IDLE";
    }
    shopBox.style.display = "block";
    renderShop();
    updateHelpPosition();
  }

  function renderShop(){
    shopList.innerHTML = "";
    const funds = Game.funds[Game.currentPlayer];
    const validSel = Game.sel && Game.sel.type==="building" && canBuildFromBuilding(Game.sel.building, Game.currentPlayer);
    const baseX = validSel ? Game.sel.x : -1;
    const baseY = validSel ? Game.sel.y : -1;

    if(!validSel){
      shopHint.textContent = "Select your owned Base to build." + (getCOChoice(Game.currentPlayer).id==="HACHI" && Game.coState[Game.currentPlayer]==="SUPER" ? " (Cities allowed with Hachi Super)" : "");
    } else if(unitAt(baseX, baseY)){
      shopHint.textContent = "Base is occupied; move the unit off to build.";
    } else {
      shopHint.textContent = "Build units on your base" + (Game.sel.building.kindId==="CITY" ? " (Hachi Super)" : "") + " (tile must be empty).";
    }

    for(const id of SHOP_UNITS){
      const def = UNIT_DEF[id];
      const price = getUnitCost(def, Game.currentPlayer);
      const canAfford = funds >= price;
      const occupied = validSel && unitAt(baseX, baseY) !== null;

      const div = document.createElement("div");
      div.className = "shopItem";

      const left = document.createElement("div");
      left.style.display = "grid";
      left.style.gridTemplateColumns = "64px 1fr";
      left.style.gap = "10px";
      const sprite = makeSpriteNode(id, Game.currentPlayer, 64);
      left.appendChild(sprite);

      const info = document.createElement("div");
      const dmgPreview = previewDamageRange(def);
      const role = def.indirect ? "Indirect fire" : "Direct fire";
      const rangeLabel = formatRangeText(def.rangeMin, def.rangeMax, def.move, def.id==="RKT");
      info.innerHTML = `<div class="name">${def.name} <span class="abbr">${def.abbr}</span></div>
                        <div class="meta">Cost ${price} • Move ${def.move} (${def.movementType}) • Range ${rangeLabel} • ${role}</div>`;
      const statRow = document.createElement("div");
      statRow.className = "shopStats";
      statRow.innerHTML = `<span class="pill warn">Damage roll vs INF: ${dmgPreview.min}-${dmgPreview.max}</span>
                           <span class="pill">Armor: ${def.armor ?? 0}</span>
                           ${def.canCapture ? '<span class="pill good">Can capture</span>' : '<span class="pill">No capture</span>'}`;
      info.appendChild(statRow);
      left.appendChild(info);
      div.appendChild(left);

      const right = document.createElement("div");
      const pill = document.createElement("span");
      pill.className = "pill " + (canAfford ? "good" : "bad");
      pill.textContent = canAfford ? "Affordable" : "Too expensive";
      right.appendChild(pill);

      const btn = document.createElement("button");
      btn.className = "btn good";
      btn.style.marginLeft = "8px";
      btn.textContent = "Build";
      btn.disabled = (!canAfford) || occupied || !validSel;

      btn.addEventListener("click", ()=>{
        buildUnitAtBase(id, baseX, baseY);
      });

      right.appendChild(btn);
      div.appendChild(right);

      shopList.appendChild(div);
    }
  }

  function buildUnitAtBase(typeId, x, y){
    if(Game.gameOver) return;

    const b = buildingAt(x,y);
    if(!b || !canBuildFromBuilding(b, Game.currentPlayer)) return;

    if(unitAt(x,y)){
      logLine("Cannot build: base tile occupied.", Game.currentPlayer);
      return;
    }

    const def = UNIT_DEF[typeId];
    const price = getUnitCost(def, Game.currentPlayer);
    if(Game.funds[Game.currentPlayer] < price){
      logLine("Cannot build: insufficient funds.", Game.currentPlayer);
      return;
    }

    Game.funds[Game.currentPlayer] -= price;
    const u = makeUnit(typeId, Game.currentPlayer, x, y);
    u.moved = true;
    u.acted = true;

    Game.units.push(u);
    logLine(`${owningPlayer(Game.currentPlayer).name} builds ${def.name} for ${price}.`, Game.currentPlayer);

    updateUI();
    renderShop();
  }

  /***********************************************************************
   * NEW: Key/Legend
   ***********************************************************************/
  function openKey(){
    keyBox.style.display = "block";
    renderLegend();
    updateHelpPosition();
  }
  function closeKey(){
    keyBox.style.display = "none";
    updateHelpPosition();
  }
  function toggleKey(){
    if(keyBox.style.display === "block") closeKey();
    else openKey();
  }

  function renderLegend(){
    terrainLegend.innerHTML = "";
    unitLegend.innerHTML = "";

    const terrainItems = [TERRAIN.PLAINS, TERRAIN.ROAD, TERRAIN.FOREST, TERRAIN.MOUNTAIN, TERRAIN.WATER];
    for(const t of terrainItems){
      const row = document.createElement("div");
      row.className = "legendRow";

      const left = document.createElement("div");
      left.style.display = "flex";
      left.style.alignItems = "center";
      left.style.gap = "10px";

      const sw = document.createElement("span");
      sw.className = "swatch";
      const img = getTerrainSprite(t.id);
      if(img){
        sw.style.backgroundImage = `url(${img.src})`;
        sw.style.backgroundSize = "cover";
      } else {
        sw.style.background = t.color;
      }

      const label = document.createElement("div");
      label.innerHTML = `<div style="font-weight:800">${t.name}</div><div class="muted" style="font-size:12px">Move: foot ${t.moveCost.foot}, tread ${t.moveCost.tread}</div>`;

      left.appendChild(sw);
      left.appendChild(label);

      const right = document.createElement("div");
      right.innerHTML = `<span class="pill">Tile Def (click): ${t.name === "Water" ? "0" : "0"}</span>`;
      // defense shown is per your rule; terrain always ground => 0 (buildings handled separately)

      row.appendChild(left);
      row.appendChild(right);

      terrainLegend.appendChild(row);
    }

    for(const id of Object.keys(UNIT_DEF)){
      const u = UNIT_DEF[id];
      const row = document.createElement("div");
      row.className = "legendRow";

      const left = document.createElement("div");
      const rangeLabel = formatRangeText(u.rangeMin, u.rangeMax, u.move, u.id==="RKT");
      left.innerHTML = `<div style="font-weight:800">${u.name} <span class="abbr">${u.abbr}</span></div>
                        <div class="muted" style="font-size:12px">Cost ${u.cost} • Move ${u.move} • Range ${rangeLabel}${u.indirect ? " (Indirect)" : ""}</div>`;
      const right = document.createElement("div");
      right.innerHTML = `<span class="pill ${u.canCapture ? "good" : ""}">${u.canCapture ? "Can capture" : "No capture"}</span>`;

      row.appendChild(left);
      row.appendChild(right);
      unitLegend.appendChild(row);
    }
  }

  /***********************************************************************
   * Input Handling
   ***********************************************************************/
  function canvasToGrid(mx,my){
    const rect = canvas.getBoundingClientRect();
    const x = Math.floor((mx - rect.left) * (canvas.width / rect.width) / TILE);
    const y = Math.floor((my - rect.top) * (canvas.height / rect.height) / TILE);
    return {x,y};
  }

  async function onLeftClickGrid(x,y){
    if(Game.gameOver) return;

    if(Game.phase==="SHOP"){
      if(!(Game.sel && Game.sel.type==="building" && Game.sel.x===x && Game.sel.y===y)){
        closeShop();
      }
    }

    const u = unitAt(x,y);
    const b = buildingAt(x,y);

    if(Game.sel && Game.sel.type==="unit"){
      const su = Game.sel.unit;

      if(su.owner === Game.currentPlayer){
        const clickedKey = key(x,y);
        if(!su.moved && Game.moveTiles.has(clickedKey) && !(x===su.x && y===su.y)){
          const occ = unitAt(x,y);
          if(occ && occ.uid!==su.uid) return;

          const destK = key(x,y);
          const path = reconstructPath(destK);

          su.x = x; su.y = y;
          su.animMove = { path, start: performance.now(), step: 200 };
          su.moved = true;

          logLine(`${owningPlayer(su.owner).name} moves ${su.def.name}.`, su.owner);

          Game.atkTiles = computeAttackTilesFromPosition(su, {x,y});
          Game.phase = "ATTACKING";
          computeAttackOverlayIfApplicable();
          updateSelectionPanel();
          updateUI();
          return;
        }

        if(!su.acted){
          if(Game.atkTiles.has(clickedKey) && enemyInRangeAt(su,clickedKey)){
            const target = unitAt(x,y);
            if(target){
              await performAttack(su, target);

              if(!Game.units.some(z=>z.uid===su.uid)){
                clearSelection();
              } else {
                updateSelectionPanel();
              }
              computeAttackOverlayIfApplicable();
              updateUI();
              return;
            }
          }

          if(x===su.x && y===su.y){
            const did = await tryCapture(su);
            if(did){
              computeAttackOverlayIfApplicable();
              updateSelectionPanel();
              updateUI();
              return;
            }
          }
        }
      }
    }

    // selection order: unit -> building -> tile
    if(u){
      selectUnit(u);
      return;
    }
    if(b){
      selectBuilding(b, x, y);
      return;
    }

    // NEW: select empty tile instead of clearing (so defense stat shows)
    selectTile(x,y);
    updateUI();
  }

  function onRightClick(e){
    e.preventDefault();
    closeShop();
    closeKey();
    clearSelection();
    updateUI();
  }

  canvas.addEventListener("mousemove", (e)=>{
    const g = canvasToGrid(e.clientX, e.clientY);
    Game.hovered = g;

    if(Game.sel && Game.sel.type==="unit" && Game.moveTiles.size && Game.moveTiles.has(key(g.x,g.y))){
      Game.path = reconstructPath(key(g.x,g.y));
    } else {
      Game.path = [];
    }
  });

  canvas.addEventListener("mousedown", async (e)=>{
    if(e.button===2) return;
    const g = canvasToGrid(e.clientX, e.clientY);
    if(!inBounds(g.x,g.y)) return;
    await onLeftClickGrid(g.x,g.y);
  });

  canvas.addEventListener("contextmenu", onRightClick);

  window.addEventListener("keydown", (e)=>{
    if(e.key==="e" || e.key==="E"){
      endTurn();
    } else if(e.key==="b" || e.key==="B"){
      const choice = pickNextBase(Game.currentPlayer);
      if(choice){
        selectBuilding(choice.b, choice.x, choice.y);
        openShopIfOnOwnedBase();
      } else {
        logLine("No owned Base available to open shop.", Game.currentPlayer);
      }
    } else if(e.key==="k" || e.key==="K"){
      toggleKey();
    } else if(e.key==="Escape"){
      closeCOModal();
      closeShop();
      closeKey();
      clearSelection();
      updateUI();
      updateHelpPosition();
    }
  });

  /***********************************************************************
   * UI Buttons
   ***********************************************************************/
  endTurnBtn.addEventListener("click", endTurn);
  newBtn.addEventListener("click", freshMatch);
  resetBtn.addEventListener("click", hardReset);
  openShopBtn.addEventListener("click", ()=>{ autoOpenShopForCurrentPlayer(); });
  unselectBtn.addEventListener("click", ()=>{
    closeShop();
    closeKey();
    clearSelection();
    updateUI();
    updateHelpPosition();
  });
  closeShopBtn.addEventListener("click", ()=>{ closeShop(); updateUI(); });
  keyBtn.addEventListener("click", ()=>{ toggleKey(); });
  closeKeyBtn.addEventListener("click", ()=>{ closeKey(); });
  if(p1ChooseCO) p1ChooseCO.addEventListener("click", ()=>openCOModal(1));
  if(p2ChooseCO) p2ChooseCO.addEventListener("click", ()=>openCOModal(2));
  if(p1COCard) p1COCard.addEventListener("click", ()=>openCOModal(1));
  if(p2COCard) p2COCard.addEventListener("click", ()=>openCOModal(2));
  if(p1TopAvatar){
    p1TopAvatar.addEventListener("click", ()=>openCOModal(1));
    p1TopAvatar.addEventListener("mouseenter", ()=>showTooltip(p1TopTooltip, p1TopAvatar));
    p1TopAvatar.addEventListener("mouseleave", ()=>hideTooltip(p1TopTooltip));
  }
  if(p2TopAvatar){
    p2TopAvatar.addEventListener("click", ()=>openCOModal(2));
    p2TopAvatar.addEventListener("mouseenter", ()=>showTooltip(p2TopTooltip, p2TopAvatar));
    p2TopAvatar.addEventListener("mouseleave", ()=>hideTooltip(p2TopTooltip));
  }
  if(p1PowerBtn) p1PowerBtn.addEventListener("click", ()=>useCOPower(1,"POWER"));
  if(p2PowerBtn) p2PowerBtn.addEventListener("click", ()=>useCOPower(2,"POWER"));
  if(p1SuperBtn) p1SuperBtn.addEventListener("click", ()=>useCOPower(1,"SUPER"));
  if(p2SuperBtn) p2SuperBtn.addEventListener("click", ()=>useCOPower(2,"SUPER"));
  if(p1TopPower) p1TopPower.addEventListener("click", ()=>useCOPower(1,"POWER"));
  if(p2TopPower) p2TopPower.addEventListener("click", ()=>useCOPower(2,"POWER"));
  if(p1TopSuper) p1TopSuper.addEventListener("click", ()=>useCOPower(1,"SUPER"));
  if(p2TopSuper) p2TopSuper.addEventListener("click", ()=>useCOPower(2,"SUPER"));
  if(closeCoModal) closeCoModal.addEventListener("click", closeCOModal);
  if(coModal) coModal.addEventListener("click", (e)=>{ if(e.target===coModal) closeCOModal(); });

  /***********************************************************************
   * UI Updates
   ***********************************************************************/
  function updateUI(){
    const cp = owningPlayer(Game.currentPlayer);
    const income1 = countOwnedIncome(1);
    const income2 = countOwnedIncome(2);
    const co1 = getCOChoice(1);
    const co2 = getCOChoice(2);

    if(p1TopIncome) p1TopIncome.textContent = `Income ${income1}`;
    if(p2TopIncome) p2TopIncome.textContent = `Income ${income2}`;
    elP1Funds.textContent = `Funds ${Game.funds[1]}`;
    elP2Funds.textContent = `Funds ${Game.funds[2]}`;
    if(p1TopCOName) p1TopCOName.textContent = co1.name;
    if(p2TopCOName) p2TopCOName.textContent = co2.name;
    setCOAvatar(p1TopAvatar, co1, 1);
    setCOAvatar(p2TopAvatar, co2, 2);

    if(p1Card){
      const active = Game.currentPlayer===1;
      p1Card.classList.toggle("active", active);
      p1Card.style.borderColor = active ? COLORS.p1 : "#23346b";
      p1Card.style.boxShadow = active ? "0 0 0 1px rgba(99,186,255,0.4)" : "none";
    }
    if(p2Card){
      const active = Game.currentPlayer===2;
      p2Card.classList.toggle("active", active);
      p2Card.style.borderColor = active ? COLORS.p2 : "#23346b";
      p2Card.style.boxShadow = active ? "0 0 0 1px rgba(255,95,140,0.4)" : "none";
    }
    renderCOSection();

    if(Game.sel && Game.sel.type==="unit"){
      const u = Game.sel.unit;
      if(u.owner===Game.currentPlayer && !u.moved){
        computeMoveOverlayIfApplicable();
      } else {
        Game.moveTiles = new Set();
      }
      computeAttackOverlayIfApplicable();
      if(u.owner===Game.currentPlayer && !u.acted){
        Game.phase = "ATTACKING";
      }
    } else {
      Game.moveTiles = new Set();
      Game.atkTiles = new Set();
      Game.path = [];
    }

    endTurnBtn.disabled = Game.gameOver;

    if(Game.sel) updateSelectionPanel();

    renderShop();
  }

  /***********************************************************************
   * Rendering
   ***********************************************************************/
  function getUnitRenderPos(u, now){
    if(u && u.animMove && Array.isArray(u.animMove.path)){
      const { path, start, step } = u.animMove;
      const steps = path.length-1;
      if(steps>0){
        const elapsed = now - start;
        const seg = Math.floor(elapsed / step);
        if(seg >= steps){
          u.animMove = null;
          return { x:u.x, y:u.y };
        }
        const t = (elapsed % step) / step;
        const a = path[seg];
        const b = path[seg+1];
        if(a && b){
          return { x: a.x + (b.x - a.x)*t, y: a.y + (b.y - a.y)*t };
        } else {
          u.animMove = null;
        }
      } else {
        u.animMove = null;
      }
    }
    return { x:u.x, y:u.y };
  }

  function draw(ts){
    const now = ts || performance.now();
    ctx.clearRect(0,0,canvas.width,canvas.height);

    ctx.fillStyle = COLORS.bg;
    ctx.fillRect(0,0,canvas.width,canvas.height);

    drawTerrain();
    drawBuildings();
    drawOverlays();
    drawUnits(now);
    drawGrid();
    drawTopHUD();

    requestAnimationFrame(draw);
  }

  // NEW: clearer terrain rendering (road/water/grass distinct, deterministic patterns)
  function drawTerrain(){
    for(let y=0;y<GRID_H;y++){
      for(let x=0;x<GRID_W;x++){
        const t = Game.terrain[y][x];
        const px = x*TILE, py = y*TILE;
        const img = getTerrainSprite(t.id);
        if(img && img.complete){
          ctx.drawImage(img, px, py, TILE, TILE);
        } else {
          ctx.fillStyle = t.color;
          ctx.fillRect(px, py, TILE, TILE);
        }
      }
    }
  }

  function drawBuildings(){
    for(let y=0;y<GRID_H;y++){
      for(let x=0;x<GRID_W;x++){
        const b = Game.buildings[y][x];
        if(!b) continue;

        const owner = b.owner ?? 0;
        const baseX = x*TILE, baseY = y*TILE;
        const img = getBuildingSprite(b.kindId, owner);
        const margin = TILE*0.05;
        if(img && img.complete){
          ctx.drawImage(img, baseX+margin, baseY+margin, TILE-2*margin, TILE-2*margin);
        } else {
          // fallback simple plate
          ctx.fillStyle = "#0a0f26";
          ctx.fillRect(baseX+6, baseY+6, TILE-12, TILE-12);
          ctx.strokeStyle = "#23346b";
          ctx.strokeRect(baseX+6, baseY+6, TILE-12, TILE-12);
        }

        // capture indicator (above tile to avoid overlap)
        if(b.owner===null || b.capturePoints<20){
          const pct = b.capturePoints / 20;
          const barW = TILE-16;
          const barH = 6;
          const barX = baseX+8;
          const barY = Math.max(0, baseY-8);
          ctx.fillStyle = "#0b1433";
          ctx.fillRect(barX, barY, barW, barH);
          ctx.fillStyle = owner ? owningPlayer(owner).color : "#ffd166";
          ctx.fillRect(barX, barY, Math.floor(barW*pct), barH);
          ctx.strokeStyle = "#23346b";
          ctx.strokeRect(barX, barY, barW, barH);
        }
      }
    }
  }

  // NEW: clearer unit labels (abbr) and slightly improved silhouettes
  function drawUnits(now){
    for(const u of Game.units){
      const rp = getUnitRenderPos(u, now);
      const px = rp.x*TILE, py = rp.y*TILE;
      const p = owningPlayer(u.owner);
      const margin = TILE * 0.05; // 0.9x size to reveal tile edges
      const ux = px + margin;
      const uy = py + margin;
      const size = TILE - margin*2;

      // shadow
      ctx.globalAlpha = 0.35;
      ctx.fillStyle = "#000000";
      ctx.beginPath();
      ctx.ellipse(px+TILE/2, py+TILE/2+10, size*0.45, size*0.22, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = 1;

      // sprite draw (fallback to shapes if missing)
      const spriteList = getSpriteList(u.typeId, u.owner);
      const img = spriteList.length ? spriteList[u.spriteIdx % spriteList.length] : null;
      if(img && img.complete){
        ctx.drawImage(img, ux, uy, size, size);
      } else {
        ctx.fillStyle = p.dark;
        ctx.fillRect(ux, uy+4, size, size-10);
        ctx.fillStyle = p.color;
        ctx.fillRect(ux+2, uy+6, size-4, size-14);
      }

      // HP badge
      const hpPct = u.hp / u.def.maxHP;
      const overlayTop = Math.max(0, py-24);
      const centerX = px + TILE/2;

      // Name tag (smaller, stacked)
      const labelW = 46, labelH = 12;
      const labelX = centerX - labelW/2;
      const labelY = overlayTop;
      ctx.fillStyle = "#0a0f26";
      ctx.globalAlpha = 0.65;
      ctx.fillRect(labelX, labelY, labelW, labelH);
      ctx.globalAlpha = 1;
      ctx.strokeStyle = "#23346b";
      ctx.strokeRect(labelX, labelY, labelW, labelH);
      ctx.fillStyle = "#e8eeff";
      ctx.font = "bold 9px system-ui";
      ctx.fillText(`${u.def.abbr} - ${u.hp}`, labelX+4, labelY+9);

      // HP bar (stacked under name, smaller)
      const barW = 34, barH = 10;
      const badgeX = centerX - barW/2;
      const badgeY = labelY + labelH + 2;
      const badgeFillW = Math.max(0, Math.round((barW-2)*hpPct));
      ctx.fillStyle = "#0b1433";
      ctx.fillRect(badgeX, badgeY, barW, barH);
      ctx.fillStyle = hpPct>0.66 ? "#74ff8a" : hpPct>0.33 ? "#ffd166" : "#ff5d7a";
      ctx.fillRect(badgeX+1, badgeY+1, badgeFillW, barH-2);
      ctx.strokeStyle = "#23346b";
      ctx.strokeRect(badgeX, badgeY, barW, barH);

      // exhausted overlay
      if(u.owner===Game.currentPlayer && (u.moved || u.acted)){
        ctx.globalAlpha = 0.22;
        ctx.fillStyle = "#000000";
        ctx.fillRect(px,py,TILE,TILE);
        ctx.globalAlpha = 1;
      }
    }
  }

  function drawGrid(){
    ctx.strokeStyle = COLORS.grid;
    ctx.lineWidth = 1;
    for(let x=0;x<=GRID_W;x++){
      ctx.beginPath();
      ctx.moveTo(x*TILE, 0);
      ctx.lineTo(x*TILE, CANVAS_H);
      ctx.stroke();
    }
    for(let y=0;y<=GRID_H;y++){
      ctx.beginPath();
      ctx.moveTo(0, y*TILE);
      ctx.lineTo(CANVAS_W, y*TILE);
      ctx.stroke();
    }
  }

  function drawTopHUD(){
    if(Game.gameOver){
      ctx.fillStyle = "#0b1433";
      ctx.fillRect(CANVAS_W/2-220, CANVAS_H/2-40, 440, 80);
      ctx.strokeStyle = "#23346b";
      ctx.strokeRect(CANVAS_W/2-220, CANVAS_H/2-40, 440, 80);
      ctx.fillStyle = "#e8eeff";
      ctx.font = "bold 18px system-ui";
      ctx.fillText("GAME OVER", CANVAS_W/2-70, CANVAS_H/2-10);
      ctx.font = "14px system-ui";
      ctx.fillText("Press New Game to play again.", CANVAS_W/2-110, CANVAS_H/2+18);
    }
  }

  function drawOverlays(){
    if(Game.moveTiles && Game.moveTiles.size){
      for(const k of Game.moveTiles){
        const {x,y} = parseKey(k);
        const px=x*TILE, py=y*TILE;
        ctx.fillStyle = COLORS.move;
        ctx.fillRect(px,py,TILE,TILE);
        ctx.strokeStyle = COLORS.moveEdge;
        ctx.strokeRect(px+1,py+1,TILE-2,TILE-2);
      }
    }

    if(Game.path && Game.path.length>1){
      ctx.strokeStyle = COLORS.selectEdge;
      ctx.lineWidth = 4;
      ctx.beginPath();
      for(let i=0;i<Game.path.length;i++){
        const p = Game.path[i];
        const cx = p.x*TILE + TILE/2;
        const cy = p.y*TILE + TILE/2;
        if(i===0) ctx.moveTo(cx,cy);
        else ctx.lineTo(cx,cy);
      }
      ctx.stroke();
      ctx.lineWidth = 1;
    }

    if(Game.sel && Game.sel.type==="unit"){
      const su = Game.sel.unit;
      if(su.owner===Game.currentPlayer && !su.acted){
        for(const k of Game.atkTiles){
          if(!enemyInRangeAt(su,k)) continue;
          const {x,y} = parseKey(k);
          const px=x*TILE, py=y*TILE;
          ctx.fillStyle = COLORS.atk;
          ctx.fillRect(px,py,TILE,TILE);
          ctx.strokeStyle = COLORS.atkEdge;
          ctx.strokeRect(px+1,py+1,TILE-2,TILE-2);
        }
      }
    }

    if(Game.sel){
      const x = Game.sel.type==="unit" ? Game.sel.unit.x : Game.sel.x;
      const y = Game.sel.type==="unit" ? Game.sel.unit.y : Game.sel.y;
      const px=x*TILE, py=y*TILE;
      ctx.fillStyle = COLORS.select;
      ctx.fillRect(px,py,TILE,TILE);
      ctx.strokeStyle = COLORS.selectEdge;
      ctx.lineWidth = 3;
      ctx.strokeRect(px+2,py+2,TILE-4,TILE-4);
      ctx.lineWidth = 1;
    }

    for(const u of Game.units){
      if(u.owner!==Game.currentPlayer) continue;
      if(!u.def.canCapture || u.acted) continue;
      const b = buildingAt(u.x, u.y);
      if(!b) continue;
      if(b.owner===u.owner && b.capturePoints===20) continue;
      const px=u.x*TILE, py=u.y*TILE;
      ctx.fillStyle = COLORS.danger;
      ctx.fillRect(px,py,TILE,TILE);
      ctx.strokeStyle = COLORS.warn;
      ctx.lineWidth = 3;
      ctx.strokeRect(px+2,py+2,TILE-4,TILE-4);
      ctx.lineWidth = 1;
    }

    if(inBounds(Game.hovered.x, Game.hovered.y)){
      const px=Game.hovered.x*TILE, py=Game.hovered.y*TILE;
      ctx.globalAlpha = 0.18;
      ctx.fillStyle = "#ffffff";
      ctx.fillRect(px,py,TILE,TILE);
      ctx.globalAlpha = 1;
    }
  }

  /***********************************************************************
   * Win Checks
   ***********************************************************************/
  function hasHQ(ownerId){
    for(let y=0;y<GRID_H;y++){
      for(let x=0;x<GRID_W;x++){
        const b = buildingAt(x,y);
        if(b && b.kindId==="HQ" && b.owner===ownerId) return true;
      }
    }
    return false;
  }

  function sanityWinCheck(){
    if(!hasHQ(1)){
      Game.gameOver = true;
      logLine("Player 2 wins (Player 1 HQ lost).", 2);
    } else if(!hasHQ(2)){
      Game.gameOver = true;
      logLine("Player 1 wins (Player 2 HQ lost).", 1);
    }
  }

  /***********************************************************************
   * Auto-open shop on base double click
   ***********************************************************************/
  canvas.addEventListener("dblclick", (e)=>{
    const g = canvasToGrid(e.clientX, e.clientY);
    if(!inBounds(g.x,g.y)) return;
    const b = buildingAt(g.x,g.y);
    if(b && b.kindId==="BASE" && b.owner===Game.currentPlayer){
      selectBuilding(b, g.x, g.y);
      openShopIfOnOwnedBase();
      updateUI();
    }
  });

  /***********************************************************************
   * Keep selection valid if unit dies
   ***********************************************************************/
  function validateSelection(){
    if(!Game.sel) return;
    if(Game.sel.type==="unit"){
      const uid = Game.sel.unit.uid;
      const still = Game.units.find(u=>u.uid===uid);
      if(!still){
        clearSelection();
        updateUI();
      } else {
        Game.sel.unit = still;
      }
    }
  }

  /***********************************************************************
   * Game Loop
   ***********************************************************************/
  function tick(){
    validateSelection();
    sanityWinCheck();
  }
  setInterval(tick, 120);

  /***********************************************************************
 * HOTFIX: Safe deterministic hash helpers (replaces buggy BigInt version)
 ***********************************************************************/
function hash2(x, y, seed = 1337) {
  // 32-bit integer hash (no BigInt)
  let h = (x | 0) * 374761393 ^ (y | 0) * 668265263 ^ (seed | 0) * 1442695041;
  h = (h ^ (h >>> 13)) | 0;
  h = (h * 1274126177) | 0;
  h = (h ^ (h >>> 16)) | 0;
  return h >>> 0; // unsigned
}
function hashFloat01(x, y, seed = 1337) {
  return (hash2(x, y, seed) % 100000) / 100000;
}
function hashInt(x, y, seed, mod) {
  return Math.floor(hashFloat01(x, y, seed) * mod);
}


  /***********************************************************************
   * Boot
   ***********************************************************************/
  loadSprites();
  hardReset();
  requestAnimationFrame(draw);

  </script>
</body>
</html>
